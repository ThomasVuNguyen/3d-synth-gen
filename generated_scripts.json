[
  {
    "input": "abs bag",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create main bag body\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1))\nbag_body = bpy.context.active_object\nbag_body.name = \"bag_body\"\nbag_body.scale = (1.5, 0.8, 1.2)\n\n# Create bag bottom\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.2))\nbag_bottom = bpy.context.active_object\nbag_bottom.name = \"bag_bottom\"\nbag_bottom.scale = (1.4, 0.75, 0.1)\n\n# Create left handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=1.5, location=(-0.8, 0, 2.5))\nleft_handle = bpy.context.active_object\nleft_handle.name = \"left_handle\"\nleft_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create right handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=1.5, location=(0.8, 0, 2.5))\nright_handle = bpy.context.active_object\nright_handle.name = \"right_handle\"\nright_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create handle connectors\nbpy.ops.mesh.primitive_cube_add(size=0.2, location=(-0.8, 0, 2.2))\nleft_connector = bpy.context.active_object\nleft_connector.name = \"left_connector\"\nleft_connector.scale = (0.5, 1, 0.3)\n\nbpy.ops.mesh.primitive_cube_add(size=0.2, location=(0.8, 0, 2.2))\nright_connector = bpy.context.active_object\nright_connector.name = \"right_connector\"\nright_connector.scale = (0.5, 1, 0.3)\n\n# Create zipper detail\nbpy.ops.mesh.primitive_cylinder_add(radius=0.02, depth=2.5, location=(0, 0.6, 1.8))\nzipper = bpy.context.active_object\nzipper.name = \"zipper\"\nzipper.rotation_euler = (0, 1.5708, 0)\n\n# Create zipper pull\nbpy.ops.mesh.primitive_cube_add(size=0.1, location=(1.2, 0.6, 1.8))\nzipper_pull = bpy.context.active_object\nzipper_pull.name = \"zipper_pull\"\nzipper_pull.scale = (0.3, 0.5, 1)\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"abs_bag\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs basket",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create basket base\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=0.2, location=(0, 0, 0))\nbase = bpy.context.active_object\nbase.name = \"basket_base\"\n\n# Create basket walls\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=1.5, location=(0, 0, 0.85))\nwalls = bpy.context.active_object\nwalls.name = \"basket_walls\"\n\n# Make walls hollow by scaling inner faces\nbpy.context.view_layer.objects.active = walls\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='DESELECT')\nbm = bmesh.from_mesh(walls.data)\nbm.faces.ensure_lookup_table()\n\n# Select top face\nfor face in bm.faces:\n    if face.normal.z > 0.9:\n        face.select = True\n\nbmesh.update_edit_mesh(walls.data)\nbpy.ops.mesh.inset_faces(thickness=0.2)\nbpy.ops.mesh.delete(type='FACE')\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Create basket handle - left side\nbpy.ops.mesh.primitive_torus_add(major_radius=0.3, minor_radius=0.1, location=(-2.2, 0, 1.2))\nhandle_left = bpy.context.active_object\nhandle_left.name = \"handle_left\"\nhandle_left.rotation_euler = (0, 1.5708, 0)\n\n# Create basket handle - right side\nbpy.ops.mesh.primitive_torus_add(major_radius=0.3, minor_radius=0.1, location=(2.2, 0, 1.2))\nhandle_right = bpy.context.active_object\nhandle_right.name = \"handle_right\"\nhandle_right.rotation_euler = (0, 1.5708, 0)\n\n# Create handle connector\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=4.4, location=(0, 0, 1.2))\nhandle_connector = bpy.context.active_object\nhandle_connector.name = \"handle_connector\"\nhandle_connector.rotation_euler = (0, 1.5708, 0)\n\n# Create basket weave pattern with small cylinders\nweave_objects = []\nfor i in range(8):\n    angle = i * 0.785398  # 45 degrees in radians\n    x = 2.1 * bpy.context.scene.cursor.location[0] + 2.1 * (1 * bpy.context.scene.cursor.location[0] + 1) * 0.866025  # cos approximation\n    y = 2.1 * (1 * bpy.context.scene.cursor.location[1] + 1) * 0.5  # sin approximation\n    \n    # Vertical weave elements\n    for j in range(3):\n        z_pos = 0.3 + j * 0.5\n        bpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.4, location=(2.1, 0, z_pos))\n        weave = bpy.context.active_object\n        weave.rotation_euler = (0, 0, angle)\n        weave_objects.append(weave)\n\n# Select all basket parts\nbpy.ops.object.select_all(action='DESELECT')\nbase.select_set(True)\nwalls.select_set(True)\nhandle_left.select_set(True)\nhandle_right.select_set(True)\nhandle_connector.select_set(True)\n\nfor obj in weave_objects:\n    obj.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = base\n\n# Join all objects\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"basket\"\n\n# Export as STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nif not bpy.path.abspath(\"//\"):\n    export_path = os.path.expanduser(\"~/duck.stl\")\n\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=True,\n    ascii=True\n)\n\nprint(f\"Basket exported as: {export_path}\")\n```"
  },
  {
    "input": "abs beam",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create I-beam cross-section using primitives\nbeam_length = 4.0\nflange_width = 1.0\nflange_thickness = 0.2\nweb_height = 1.0\nweb_thickness = 0.15\n\n# Top flange\nbpy.ops.mesh.primitive_cube_add(\n    size=2,\n    location=(0, 0, web_height/2 + flange_thickness/2)\n)\ntop_flange = bpy.context.active_object\ntop_flange.scale = (beam_length/2, flange_width/2, flange_thickness/2)\ntop_flange.name = \"TopFlange\"\n\n# Bottom flange\nbpy.ops.mesh.primitive_cube_add(\n    size=2,\n    location=(0, 0, -web_height/2 - flange_thickness/2)\n)\nbottom_flange = bpy.context.active_object\nbottom_flange.scale = (beam_length/2, flange_width/2, flange_thickness/2)\nbottom_flange.name = \"BottomFlange\"\n\n# Web (vertical part)\nbpy.ops.mesh.primitive_cube_add(\n    size=2,\n    location=(0, 0, 0)\n)\nweb = bpy.context.active_object\nweb.scale = (beam_length/2, web_thickness/2, web_height/2)\nweb.name = \"Web\"\n\n# Select all beam parts\nbpy.ops.object.select_all(action='DESELECT')\ntop_flange.select_set(True)\nbottom_flange.select_set(True)\nweb.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = top_flange\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"IBeam\"\n\n# Create collection and add beam to it\ncollection = bpy.data.collections.new(\"BeamAssembly\")\nbpy.context.scene.collection.children.link(collection)\ncollection.objects.link(bpy.context.active_object)\nbpy.context.scene.collection.objects.unlink(bpy.context.active_object)\n\n# Export as STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    ascii=True,\n    use_selection=False\n)\n```"
  },
  {
    "input": "abs bed",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bed frame base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.1))\nbed_base = bpy.context.active_object\nbed_base.name = \"bed_base\"\nbed_base.scale = (2, 1.5, 0.1)\n\n# Create mattress\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.3))\nmattress = bpy.context.active_object\nmattress.name = \"mattress\"\nmattress.scale = (1.9, 1.4, 0.2)\n\n# Create headboard\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -1.4, 0.8))\nheadboard = bpy.context.active_object\nheadboard.name = \"headboard\"\nheadboard.scale = (1.9, 0.1, 0.6)\n\n# Create bed legs (4 cylinders)\nleg_positions = [(-3.5, -2, -0.4), (3.5, -2, -0.4), (-3.5, 2, -0.4), (3.5, 2, -0.4)]\nlegs = []\n\nfor i, pos in enumerate(leg_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.8, location=pos)\n    leg = bpy.context.active_object\n    leg.name = f\"leg_{i+1}\"\n    legs.append(leg)\n\n# Create pillow\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -0.8, 0.6))\npillow = bpy.context.active_object\npillow.name = \"pillow\"\npillow.scale = (0.8, 0.4, 0.15)\n\n# Select all bed parts for grouping\nbpy.ops.object.select_all(action='DESELECT')\nbed_parts = [bed_base, mattress, headboard, pillow] + legs\n\nfor part in bed_parts:\n    part.select_set(True)\n\n# Set active object for join operation\nbpy.context.view_layer.objects.active = bed_base\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs bin",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create the main bin body\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nbin_body = bpy.context.active_object\nbin_body.name = \"bin_body\"\nbin_body.scale = (1, 0.8, 0.6)\n\n# Create the bin interior (hollow out effect)\nbpy.ops.mesh.primitive_cube_add(size=1.8, location=(0, 0, 0.1))\nbin_interior = bpy.context.active_object\nbin_interior.name = \"bin_interior\"\nbin_interior.scale = (0.9, 0.7, 0.5)\n\n# Create bin handles - left handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.3, location=(-1.1, 0, 0.2))\nleft_handle = bpy.context.active_object\nleft_handle.name = \"left_handle\"\nleft_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create bin handles - right handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.3, location=(1.1, 0, 0.2))\nright_handle = bpy.context.active_object\nright_handle.name = \"right_handle\"\nright_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create handle supports - left\nbpy.ops.mesh.primitive_cube_add(size=0.1, location=(-1.05, 0, 0))\nleft_support = bpy.context.active_object\nleft_support.name = \"left_support\"\nleft_support.scale = (1, 1, 2)\n\n# Create handle supports - right\nbpy.ops.mesh.primitive_cube_add(size=0.1, location=(1.05, 0, 0))\nright_support = bpy.context.active_object\nright_support.name = \"right_support\"\nright_support.scale = (1, 1, 2)\n\n# Create bin feet\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(-0.7, -0.5, -0.65))\nfoot1 = bpy.context.active_object\nfoot1.name = \"foot1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(0.7, -0.5, -0.65))\nfoot2 = bpy.context.active_object\nfoot2.name = \"foot2\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(-0.7, 0.5, -0.65))\nfoot3 = bpy.context.active_object\nfoot3.name = \"foot3\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(0.7, 0.5, -0.65))\nfoot4 = bpy.context.active_object\nfoot4.name = \"foot4\"\n\n# Boolean operation to hollow out the bin\nbpy.context.view_layer.objects.active = bin_body\nbin_body.select_set(True)\nbin_interior.select_set(True)\n\nmodifier = bin_body.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nmodifier.operation = 'DIFFERENCE'\nmodifier.object = bin_interior\n\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete the interior object\nbpy.ops.object.select_all(action='DESELECT')\nbin_interior.select_set(True)\nbpy.ops.object.delete()\n\n# Select all remaining objects and join them\nbpy.ops.object.select_all(action='SELECT')\nbpy.context.view_layer.objects.active = bin_body\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"abs_bin\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "abs blanket",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create blanket using subdivided plane\nbpy.ops.mesh.primitive_plane_add(size=4, location=(0, 0, 0))\nblanket = bpy.context.active_object\nblanket.name = \"Blanket\"\n\n# Add subdivision surface modifier for smoothness\nblanket.modifiers.new(name=\"Subdivision\", type='SUBSURF')\nblanket.modifiers[\"Subdivision\"].levels = 2\n\n# Enter edit mode to add wave deformation\nbpy.context.view_layer.objects.active = blanket\nbpy.ops.object.mode_set(mode='EDIT')\n\n# Add more geometry for better deformation\nbpy.ops.mesh.subdivide(number_cuts=8)\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Add wave modifier for blanket-like appearance\nwave_modifier = blanket.modifiers.new(name=\"Wave\", type='WAVE')\nwave_modifier.use_x = True\nwave_modifier.use_y = True\nwave_modifier.height = 0.1\nwave_modifier.width = 1.0\nwave_modifier.speed = 0\n\n# Add displace modifier for more organic look\ndisplace_modifier = blanket.modifiers.new(name=\"Displace\", type='DISPLACE')\ndisplace_modifier.strength = 0.05\n\n# Create corner weights using spheres (to simulate blanket corners)\ncorners = []\ncorner_positions = [(-1.8, -1.8, -0.1), (1.8, -1.8, -0.1), (-1.8, 1.8, -0.1), (1.8, 1.8, -0.1)]\n\nfor i, pos in enumerate(corner_positions):\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.1, location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"Corner_{i+1}\"\n    corner.scale = (1, 1, 0.5)\n    corners.append(corner)\n\n# Create blanket edges using cylinders\nedges = []\nedge_configs = [\n    ((0, -2, 0), (0, 0, 1.57), (2, 0.05, 0.05)),  # front edge\n    ((0, 2, 0), (0, 0, 1.57), (2, 0.05, 0.05)),   # back edge\n    ((-2, 0, 0), (0, 0, 0), (2, 0.05, 0.05)),     # left edge\n    ((2, 0, 0), (0, 0, 0), (2, 0.05, 0.05))       # right edge\n]\n\nfor i, (pos, rot, scale) in enumerate(edge_configs):\n    bpy.ops.mesh.primitive_cylinder_add(radius=1, depth=1, location=pos)\n    edge = bpy.context.active_object\n    edge.name = f\"Edge_{i+1}\"\n    edge.rotation_euler = rot\n    edge.scale = scale\n    edges.append(edge)\n\n# Select all blanket objects\nall_objects = [blanket] + corners + edges\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set blanket as active object\nbpy.context.view_layer.objects.active = blanket\n\n# Join all objects\nbpy.ops.object.join()\n\n# Create collection and add the blanket\ncollection = bpy.data.collections.new(\"Blanket_Collection\")\nbpy.context.scene.collection.children.link(collection)\ncollection.objects.link(blanket)\nbpy.context.scene.collection.objects.unlink(blanket)\n\n# Apply all modifiers\nbpy.context.view_layer.objects.active = blanket\nfor modifier in blanket.modifiers:\n    bpy.ops.object.modifier_apply(modifier=modifier.name)\n\n# Export as ASCII STL\nfilepath = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=filepath, use_selection=False, ascii=True)\n```"
  },
  {
    "input": "abs bolt",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bolt head (hexagonal approximation using cylinder)\nbpy.ops.mesh.primitive_cylinder_add(vertices=6, radius=0.4, depth=0.2, location=(0, 0, 0.1))\nbolt_head = bpy.context.active_object\nbolt_head.name = \"BoltHead\"\n\n# Create bolt shaft\nbpy.ops.mesh.primitive_cylinder_add(vertices=16, radius=0.15, depth=2.0, location=(0, 0, -1.0))\nbolt_shaft = bpy.context.active_object\nbolt_shaft.name = \"BoltShaft\"\n\n# Create thread ridges using scaled toruses\nthread_positions = [-0.2, -0.4, -0.6, -0.8, -1.0, -1.2, -1.4, -1.6, -1.8]\nthread_objects = []\n\nfor i, z_pos in enumerate(thread_positions):\n    bpy.ops.mesh.primitive_torus_add(major_radius=0.18, minor_radius=0.03, location=(0, 0, z_pos))\n    thread = bpy.context.active_object\n    thread.name = f\"Thread_{i}\"\n    thread_objects.append(thread)\n\n# Create bolt tip (cone)\nbpy.ops.mesh.primitive_cone_add(radius1=0.15, radius2=0.05, depth=0.3, location=(0, 0, -2.15))\nbolt_tip = bpy.context.active_object\nbolt_tip.name = \"BoltTip\"\n\n# Select all bolt parts\nall_objects = [bolt_head, bolt_shaft, bolt_tip] + thread_objects\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set the active object to bolt_head for joining\nbpy.context.view_layer.objects.active = bolt_head\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Bolt\"\n\n# Select the bolt for export\nbolt = bpy.context.active_object\nbolt.select_set(True)\nbpy.context.view_layer.objects.active = bolt\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs bottle",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bottle body (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=4, location=(0, 0, 0))\nbottle_body = bpy.context.active_object\nbottle_body.name = \"BottleBody\"\nbottle_body.scale = (0.8, 0.8, 1.2)\n\n# Create bottle neck (smaller cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.4, depth=1, location=(0, 0, 2.8))\nbottle_neck = bpy.context.active_object\nbottle_neck.name = \"BottleNeck\"\n\n# Create bottle cap (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.45, depth=0.3, location=(0, 0, 3.4))\nbottle_cap = bpy.context.active_object\nbottle_cap.name = \"BottleCap\"\n\n# Create bottle bottom (flattened sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.8, location=(0, 0, -2.2))\nbottle_bottom = bpy.context.active_object\nbottle_bottom.name = \"BottleBottom\"\nbottle_bottom.scale = (1, 1, 0.3)\n\n# Create label area (flattened cube)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0.85, 0))\nlabel = bpy.context.active_object\nlabel.name = \"Label\"\nlabel.scale = (0.6, 0.05, 0.8)\n\n# Select all bottle parts\nbottle_parts = [bottle_body, bottle_neck, bottle_cap, bottle_bottom, label]\nbpy.ops.object.select_all(action='DESELECT')\n\nfor part in bottle_parts:\n    part.select_set(True)\n\n# Set the first object as active\nbpy.context.view_layer.objects.active = bottle_body\n\n# Join all parts\nbpy.ops.object.join()\n\n# Rename the joined object\nbottle_body.name = \"AbsBottle\"\n\n# Apply all transforms\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Export as ASCII STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=export_path, use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "abs bowl",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bowl base using UV sphere\nbpy.ops.mesh.primitive_uv_sphere_add(location=(0, 0, 0), scale=(2, 2, 1.5))\nbowl_base = bpy.context.active_object\nbowl_base.name = \"Bowl_Base\"\n\n# Enter edit mode and delete top half to create bowl shape\nbpy.context.view_layer.objects.active = bowl_base\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='DESELECT')\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Use boolean modifier approach - create inner sphere to hollow out\nbpy.ops.mesh.primitive_uv_sphere_add(location=(0, 0, 0.2), scale=(1.7, 1.7, 1.3))\ninner_sphere = bpy.context.active_object\ninner_sphere.name = \"Inner_Sphere\"\n\n# Add boolean modifier to bowl base\nbowl_base.select_set(True)\nbpy.context.view_layer.objects.active = bowl_base\nbool_modifier = bowl_base.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nbool_modifier.operation = 'DIFFERENCE'\nbool_modifier.object = inner_sphere\n\n# Apply boolean modifier\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete inner sphere\nbpy.data.objects.remove(inner_sphere, do_unlink=True)\n\n# Create bowl rim using torus\nbpy.ops.mesh.primitive_torus_add(location=(0, 0, 1.2), major_radius=2, minor_radius=0.1)\nbowl_rim = bpy.context.active_object\nbowl_rim.name = \"Bowl_Rim\"\n\n# Select both objects and join them\nbowl_base.select_set(True)\nbowl_rim.select_set(True)\nbpy.context.view_layer.objects.active = bowl_base\nbpy.ops.object.join()\n\n# Rename final object\nbowl_base.name = \"Bowl\"\n\n# Create collection and add bowl to it\ncollection = bpy.data.collections.new(\"Bowl_Collection\")\nbpy.context.scene.collection.children.link(collection)\nbpy.context.scene.collection.objects.unlink(bowl_base)\ncollection.objects.link(bowl_base)\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=False,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs box",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create abs box parts\nparts = []\n\n# Main box body\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0))\nmain_box = bpy.context.active_object\nmain_box.name = \"MainBox\"\nmain_box.scale = (2, 1.5, 0.3)\nparts.append(main_box)\n\n# Top cover (slightly smaller)\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0.35))\ntop_cover = bpy.context.active_object\ntop_cover.name = \"TopCover\"\ntop_cover.scale = (1.9, 1.4, 0.1)\nparts.append(top_cover)\n\n# Corner reinforcements\ncorner_positions = [\n    (1.8, 1.3, 0),\n    (-1.8, 1.3, 0),\n    (1.8, -1.3, 0),\n    (-1.8, -1.3, 0)\n]\n\nfor i, pos in enumerate(corner_positions):\n    bpy.ops.mesh.primitive_cylinder_add(location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"Corner_{i}\"\n    corner.scale = (0.1, 0.1, 0.3)\n    parts.append(corner)\n\n# Mounting holes (cylinders to subtract)\nhole_positions = [\n    (1.5, 1, 0),\n    (-1.5, 1, 0),\n    (1.5, -1, 0),\n    (-1.5, -1, 0)\n]\n\nfor i, pos in enumerate(hole_positions):\n    bpy.ops.mesh.primitive_cylinder_add(location=pos)\n    hole = bpy.context.active_object\n    hole.name = f\"MountHole_{i}\"\n    hole.scale = (0.08, 0.08, 0.4)\n    parts.append(hole)\n\n# LED indicator\nbpy.ops.mesh.primitive_cylinder_add(location=(1.6, 0, 0.36))\nled = bpy.context.active_object\nled.name = \"LED\"\nled.scale = (0.05, 0.05, 0.02)\nparts.append(led)\n\n# Ventilation grilles (small cylinders)\nfor x in range(-3, 4):\n    for y in range(-2, 3):\n        bpy.ops.mesh.primitive_cylinder_add(location=(x * 0.3, y * 0.3, 0.31))\n        vent = bpy.context.active_object\n        vent.name = f\"Vent_{x}_{y}\"\n        vent.scale = (0.03, 0.03, 0.05)\n        parts.append(vent)\n\n# Connector port\nbpy.ops.mesh.primitive_cube_add(location=(0, -1.6, 0))\nconnector = bpy.context.active_object\nconnector.name = \"Connector\"\nconnector.scale = (0.3, 0.2, 0.15)\nparts.append(connector)\n\n# Select all parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = parts[0]\n\n# Join all parts\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs bulb",
    "output": "# Error generating script for abs bulb: name 'objects' is not defined"
  },
  {
    "input": "abs cabinet",
    "output": "# Error: All Bedrock models failed for abs cabinet. Please check AWS credentials and model access."
  },
  {
    "input": "abs cable",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create main cable body (long cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.03, depth=2.0, location=(0, 0, 0))\ncable_body = bpy.context.active_object\ncable_body.name = \"Cable_Body\"\n\n# Create USB connector housing (cube)\nbpy.ops.mesh.primitive_cube_add(size=0.25, location=(-1.2, 0, 0))\nusb_connector = bpy.context.active_object\nusb_connector.name = \"USB_Connector\"\nusb_connector.scale = (0.6, 1.0, 0.4)\n\n# Create USB connector metal part (smaller cube)\nbpy.ops.mesh.primitive_cube_add(size=0.15, location=(-1.35, 0, 0))\nusb_metal = bpy.context.active_object\nusb_metal.name = \"USB_Metal\"\nusb_metal.scale = (0.4, 0.8, 0.6)\n\n# Create strain relief 1 (cone)\nbpy.ops.mesh.primitive_cone_add(radius1=0.05, radius2=0.03, depth=0.2, location=(-1.0, 0, 0))\nstrain_relief_1 = bpy.context.active_object\nstrain_relief_1.name = \"Strain_Relief_1\"\nstrain_relief_1.rotation_euler = (0, 1.5708, 0)\n\n# Create other end connector (cube)\nbpy.ops.mesh.primitive_cube_add(size=0.3, location=(1.2, 0, 0))\nother_connector = bpy.context.active_object\nother_connector.name = \"Other_Connector\"\nother_connector.scale = (0.5, 1.2, 0.5)\n\n# Create other end metal part (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.15, location=(1.35, 0, 0))\nother_metal = bpy.context.active_object\nother_metal.name = \"Other_Metal\"\nother_metal.rotation_euler = (1.5708, 0, 0)\n\n# Create strain relief 2 (cone)\nbpy.ops.mesh.primitive_cone_add(radius1=0.05, radius2=0.03, depth=0.2, location=(1.0, 0, 0))\nstrain_relief_2 = bpy.context.active_object\nstrain_relief_2.name = \"Strain_Relief_2\"\nstrain_relief_2.rotation_euler = (0, -1.5708, 0)\n\n# Create cable bend (torus for curved section)\nbpy.ops.mesh.primitive_torus_add(major_radius=0.15, minor_radius=0.03, location=(0, 0.3, 0))\ncable_bend = bpy.context.active_object\ncable_bend.name = \"Cable_Bend\"\n\n# Select all cable parts\ncable_parts = [cable_body, usb_connector, usb_metal, strain_relief_1, \n               other_connector, other_metal, strain_relief_2, cable_bend]\n\nfor obj in cable_parts:\n    obj.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = cable_body\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"ABS_Cable\"\n\n# Export as ASCII STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=export_path, ascii=True, use_selection=True)\n```"
  },
  {
    "input": "abs carpet",
    "output": "# Error: All Bedrock models failed for abs carpet. Please check AWS credentials and model access."
  },
  {
    "input": "abs chain",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create abs chain links\nchain_links = []\nnum_links = 5\nlink_spacing = 2.5\n\nfor i in range(num_links):\n    # Create outer cylinder for chain link\n    bpy.ops.mesh.primitive_cylinder_add(\n        radius=0.8,\n        depth=0.3,\n        location=(i * link_spacing, 0, 0)\n    )\n    outer_cylinder = bpy.context.active_object\n    outer_cylinder.name = f\"chain_link_outer_{i}\"\n    \n    # Create inner cylinder to subtract (boolean)\n    bpy.ops.mesh.primitive_cylinder_add(\n        radius=0.6,\n        depth=0.4,\n        location=(i * link_spacing, 0, 0)\n    )\n    inner_cylinder = bpy.context.active_object\n    inner_cylinder.name = f\"chain_link_inner_{i}\"\n    \n    # Add boolean modifier to create hollow link\n    bool_modifier = outer_cylinder.modifiers.new(name=\"Boolean\", type='BOOLEAN')\n    bool_modifier.operation = 'DIFFERENCE'\n    bool_modifier.object = inner_cylinder\n    \n    # Apply modifier\n    bpy.context.view_layer.objects.active = outer_cylinder\n    bpy.ops.object.modifier_apply(modifier=\"Boolean\")\n    \n    # Delete inner cylinder\n    bpy.ops.object.select_all(action='DESELECT')\n    inner_cylinder.select_set(True)\n    bpy.ops.object.delete()\n    \n    # Rotate every other link 90 degrees\n    if i % 2 == 1:\n        outer_cylinder.rotation_euler = (0, 1.5708, 0)\n    \n    chain_links.append(outer_cylinder)\n\n# Create connecting elements between links\nfor i in range(num_links - 1):\n    # Create small cube connector\n    bpy.ops.mesh.primitive_cube_add(\n        size=0.2,\n        location=(i * link_spacing + link_spacing/2, 0, 0)\n    )\n    connector = bpy.context.active_object\n    connector.name = f\"connector_{i}\"\n    connector.scale = (1, 0.5, 0.5)\n    chain_links.append(connector)\n\n# Add decorative elements\nfor i in range(0, num_links, 2):\n    # Add small spheres as rivets\n    bpy.ops.mesh.primitive_uv_sphere_add(\n        radius=0.1,\n        location=(i * link_spacing, 0.7, 0)\n    )\n    rivet1 = bpy.context.active_object\n    rivet1.name = f\"rivet_{i}_1\"\n    chain_links.append(rivet1)\n    \n    bpy.ops.mesh.primitive_uv_sphere_add(\n        radius=0.1,\n        location=(i * link_spacing, -0.7, 0)\n    )\n    rivet2 = bpy.context.active_object\n    rivet2.name = f\"rivet_{i}_2\"\n    chain_links.append(rivet2)\n\n# Add end caps\nbpy.ops.mesh.primitive_cone_add(\n    radius1=0.6,\n    radius2=0.3,\n    depth=0.5,\n    location=(-1, 0, 0)\n)\nend_cap1 = bpy.context.active_object\nend_cap1.name = \"end_cap_1\"\nend_cap1.rotation_euler = (0, 1.5708, 0)\nchain_links.append(end_cap1)\n\nbpy.ops.mesh.primitive_cone_add(\n    radius1=0.6,\n    radius2=0.3,\n    depth=0.5,\n    location=((num_links-1) * link_spacing + 1, 0, 0)\n)\nend_cap2 = bpy.context.active_object\nend_cap2.name = \"end_cap_2\"\nend_cap2.rotation_euler = (0, -1.5708, 0)\nchain_links.append(end_cap2)\n\n# Select all chain parts\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in chain_links:\n    obj.select_set(True)\n\n# Join all objects\nbpy.context.view_layer.objects.active = chain_links[0]\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"abs_chain\"\n\n# Export as STL\nbpy.ops.export_mesh.stl(\n    filepath=os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\"),\n    use_mesh_modifiers=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs chair",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Chair seat\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1))\nseat = bpy.context.object\nseat.name = \"Chair_Seat\"\nseat.scale = (1.2, 1.2, 0.1)\n\n# Chair backrest\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -1.1, 2))\nbackrest = bpy.context.object\nbackrest.name = \"Chair_Backrest\"\nbackrest.scale = (1.2, 0.1, 1)\n\n# Chair legs (4 cylinders)\nleg_positions = [\n    (1, 1, 0.5),\n    (-1, 1, 0.5),\n    (1, -1, 0.5),\n    (-1, -1, 0.5)\n]\n\nlegs = []\nfor i, pos in enumerate(leg_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=1, location=pos)\n    leg = bpy.context.object\n    leg.name = f\"Chair_Leg_{i+1}\"\n    legs.append(leg)\n\n# Armrests (2 cubes)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(1.3, 0, 1.3))\narmrest1 = bpy.context.object\narmrest1.name = \"Chair_Armrest_1\"\narmrest1.scale = (0.1, 0.8, 0.1)\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-1.3, 0, 1.3))\narmrest2 = bpy.context.object\narmrest2.name = \"Chair_Armrest_2\"\narmrest2.scale = (0.1, 0.8, 0.1)\n\n# Group all chair parts\nchair_parts = [seat, backrest] + legs + [armrest1, armrest2]\n\n# Deselect all objects\nbpy.ops.object.select_all(action='DESELECT')\n\n# Select all chair parts\nfor part in chair_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = seat\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.object.name = \"Chair\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs clock",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create clock base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=3, depth=0.5, location=(0, 0, 0))\nclock_base = bpy.context.active_object\nclock_base.name = \"clock_base\"\n\n# Create clock face (cylinder, thinner)\nbpy.ops.mesh.primitive_cylinder_add(radius=2.8, depth=0.1, location=(0, 0, 0.3))\nclock_face = bpy.context.active_object\nclock_face.name = \"clock_face\"\n\n# Create center dot\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.05, location=(0, 0, 0.35))\ncenter_dot = bpy.context.active_object\ncenter_dot.name = \"center_dot\"\n\n# Create hour hand\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0.8, 0.37))\nbpy.context.active_object.scale = (0.05, 1.6, 0.02)\nhour_hand = bpy.context.active_object\nhour_hand.name = \"hour_hand\"\n\n# Create minute hand\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 1.2, 0.38))\nbpy.context.active_object.scale = (0.03, 2.4, 0.02)\nminute_hand = bpy.context.active_object\nminute_hand.name = \"minute_hand\"\n\n# Create hour markers (12 small cylinders)\nhour_markers = []\nfor i in range(12):\n    angle = i * (2 * math.pi / 12)\n    x = 2.3 * math.cos(angle)\n    y = 2.3 * math.sin(angle)\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.08, location=(x, y, 0.35))\n    marker = bpy.context.active_object\n    marker.name = f\"hour_marker_{i+1}\"\n    hour_markers.append(marker)\n\n# Create clock frame (torus)\nbpy.ops.mesh.primitive_torus_add(major_radius=3.2, minor_radius=0.2, location=(0, 0, 0.25))\nclock_frame = bpy.context.active_object\nclock_frame.name = \"clock_frame\"\n\n# Select all clock parts\nclock_parts = [clock_base, clock_face, center_dot, hour_hand, minute_hand, clock_frame] + hour_markers\n\nfor obj in clock_parts:\n    obj.select_set(True)\n\n# Set the active object\nbpy.context.view_layer.objects.active = clock_base\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"Clock\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    ascii=True,\n    use_selection=True\n)\n```"
  },
  {
    "input": "abs column",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create base of column\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.1))\nbase = bpy.context.active_object\nbase.name = \"Column_Base\"\nbase.scale = (2, 2, 0.2)\n\n# Create main column shaft\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=8, location=(0, 0, 4.2))\nshaft = bpy.context.active_object\nshaft.name = \"Column_Shaft\"\n\n# Create column capital (top)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 8.5))\ncapital = bpy.context.active_object\ncapital.name = \"Column_Capital\"\ncapital.scale = (1.8, 1.8, 0.3)\n\n# Create decorative top sphere\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.6, location=(0, 0, 9.1))\ntop_sphere = bpy.context.active_object\ntop_sphere.name = \"Column_Top\"\n\n# Create decorative middle ring\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=0.3, location=(0, 0, 4.2))\nring = bpy.context.active_object\nring.name = \"Column_Ring\"\n\n# Select all column parts\ncolumn_parts = [base, shaft, capital, top_sphere, ring]\nbpy.ops.object.select_all(action='DESELECT')\nfor part in column_parts:\n    part.select_set(True)\n\n# Set active object and join all parts\nbpy.context.view_layer.objects.active = shaft\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Column\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs container",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create container base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nbase = bpy.context.active_object\nbase.name = \"Container_Base\"\nbase.scale = (2, 1.5, 0.1)\n\n# Create container walls - front\nbpy.ops.mesh.primitive_cube_add(size=2, location=(2, 0, 1))\nfront_wall = bpy.context.active_object\nfront_wall.name = \"Front_Wall\"\nfront_wall.scale = (0.05, 1.5, 1)\n\n# Create container walls - back\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-2, 0, 1))\nback_wall = bpy.context.active_object\nback_wall.name = \"Back_Wall\"\nback_wall.scale = (0.05, 1.5, 1)\n\n# Create container walls - left\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -1.5, 1))\nleft_wall = bpy.context.active_object\nleft_wall.name = \"Left_Wall\"\nleft_wall.scale = (2, 0.05, 1)\n\n# Create container walls - right\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 1.5, 1))\nright_wall = bpy.context.active_object\nright_wall.name = \"Right_Wall\"\nright_wall.scale = (2, 0.05, 1)\n\n# Create lid\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 2.2))\nlid = bpy.context.active_object\nlid.name = \"Container_Lid\"\nlid.scale = (2.1, 1.6, 0.1)\n\n# Create handle - cylinder\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=1, location=(0, 0, 2.5))\nhandle = bpy.context.active_object\nhandle.name = \"Handle\"\nhandle.rotation_euler = (0, 1.5708, 0)\nhandle.scale = (1, 1, 0.8)\n\n# Create corner reinforcements using spheres\npositions = [\n    (1.8, 1.3, 0.2),\n    (1.8, -1.3, 0.2),\n    (-1.8, 1.3, 0.2),\n    (-1.8, -1.3, 0.2)\n]\n\nreinforcements = []\nfor i, pos in enumerate(positions):\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.15, location=pos)\n    sphere = bpy.context.active_object\n    sphere.name = f\"Reinforcement_{i}\"\n    sphere.scale = (1, 1, 0.5)\n    reinforcements.append(sphere)\n\n# Select all container parts\ncontainer_parts = [base, front_wall, back_wall, left_wall, right_wall, lid, handle] + reinforcements\n\n# Deselect all first\nbpy.ops.object.select_all(action='DESELECT')\n\n# Select all container parts\nfor part in container_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = base\n\n# Join all parts\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs cup",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cup base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=2, location=(0, 0, 1))\ncup_base = bpy.context.active_object\ncup_base.name = \"CupBase\"\n\n# Create cup hollow interior (smaller cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.3, depth=1.8, location=(0, 0, 1.1))\ncup_interior = bpy.context.active_object\ncup_interior.name = \"CupInterior\"\n\n# Boolean operation to hollow out the cup\nmodifier = cup_base.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nmodifier.operation = 'DIFFERENCE'\nmodifier.object = cup_interior\n\n# Apply the modifier\nbpy.context.view_layer.objects.active = cup_base\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete the interior cylinder\nbpy.ops.object.select_all(action='DESELECT')\ncup_interior.select_set(True)\nbpy.ops.object.delete()\n\n# Create cup handle (torus)\nbpy.ops.mesh.primitive_torus_add(major_radius=0.8, minor_radius=0.15, location=(1.8, 0, 1.2))\ncup_handle = bpy.context.active_object\ncup_handle.name = \"CupHandle\"\ncup_handle.rotation_euler = (0, 1.5708, 0)\n\n# Create cup bottom (cylinder for base)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.4, depth=0.1, location=(0, 0, 0.05))\ncup_bottom = bpy.context.active_object\ncup_bottom.name = \"CupBottom\"\n\n# Select all cup parts\nbpy.ops.object.select_all(action='DESELECT')\ncup_base.select_set(True)\ncup_handle.select_set(True)\ncup_bottom.select_set(True)\n\n# Join all parts\nbpy.context.view_layer.objects.active = cup_base\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs curtain",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create curtain rod (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.02, depth=4, location=(0, 0, 2))\ncurtain_rod = bpy.context.active_object\ncurtain_rod.name = \"CurtainRod\"\n\n# Create curtain panels using scaled cubes\ncurtain_parts = []\n\n# Main curtain panel 1\nbpy.ops.mesh.primitive_cube_add(size=1, location=(-1.5, 0, 1))\npanel1 = bpy.context.active_object\npanel1.name = \"CurtainPanel1\"\npanel1.scale = (0.8, 0.05, 2)\ncurtain_parts.append(panel1)\n\n# Main curtain panel 2\nbpy.ops.mesh.primitive_cube_add(size=1, location=(1.5, 0, 1))\npanel2 = bpy.context.active_object\npanel2.name = \"CurtainPanel2\"\npanel2.scale = (0.8, 0.05, 2)\ncurtain_parts.append(panel2)\n\n# Create curtain folds using deformed cubes\nfor i in range(6):\n    x_pos = -1.8 + i * 0.7\n    bpy.ops.mesh.primitive_cube_add(size=1, location=(x_pos, 0.1, 1))\n    fold = bpy.context.active_object\n    fold.name = f\"CurtainFold{i}\"\n    fold.scale = (0.15, 0.08, 1.8)\n    fold.rotation_euler = (0, 0, 0.3 * (i % 2 - 0.5))\n    curtain_parts.append(fold)\n\n# Create curtain rings using torus primitives (made from scaled spheres)\nfor i in range(8):\n    x_pos = -1.75 + i * 0.5\n    bpy.ops.mesh.primitive_torus_add(major_radius=0.05, minor_radius=0.01, location=(x_pos, 0, 1.95))\n    ring = bpy.context.active_object\n    ring.name = f\"CurtainRing{i}\"\n    curtain_parts.append(ring)\n\n# Create curtain tie-backs using cylinders\nbpy.ops.mesh.primitive_cylinder_add(radius=0.03, depth=0.4, location=(-2.2, 0.2, 1))\ntieback1 = bpy.context.active_object\ntieback1.name = \"TieBack1\"\ntieback1.rotation_euler = (0, 1.57, 0)\ncurtain_parts.append(tieback1)\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.03, depth=0.4, location=(2.2, 0.2, 1))\ntieback2 = bpy.context.active_object\ntieback2.name = \"TieBack2\"\ntieback2.rotation_euler = (0, 1.57, 0)\ncurtain_parts.append(tieback2)\n\n# Create wall brackets using cubes\nbpy.ops.mesh.primitive_cube_add(size=0.1, location=(-2, 0, 2))\nbracket1 = bpy.context.active_object\nbracket1.name = \"Bracket1\"\nbracket1.scale = (1, 2, 1)\ncurtain_parts.append(bracket1)\n\nbpy.ops.mesh.primitive_cube_add(size=0.1, location=(2, 0, 2))\nbracket2 = bpy.context.active_object\nbracket2.name = \"Bracket2\"\nbracket2.scale = (1, 2, 1)\ncurtain_parts.append(bracket2)\n\n# Add curtain rod to parts list\ncurtain_parts.append(curtain_rod)\n\n# Select all curtain parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in curtain_parts:\n    part.select_set(True)\n\n# Make one object active\nbpy.context.view_layer.objects.active = curtain_parts[0]\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Create collection and add the curtain\ncollection = bpy.data.collections.new(\"Curtain\")\nbpy.context.scene.collection.children.link(collection)\ncurtain_obj = bpy.context.active_object\ncurtain_obj.name = \"Curtain\"\n\n# Move to collection\nbpy.context.scene.collection.objects.unlink(curtain_obj)\ncollection.objects.link(curtain_obj)\n\n# Export as STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "abs cushion",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cushion base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.2))\nbase = bpy.context.active_object\nbase.name = \"cushion_base\"\nbase.scale = (2, 2, 0.3)\n\n# Create cushion top padding\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1, location=(0, 0, 0.8))\ntop = bpy.context.active_object\ntop.name = \"cushion_top\"\ntop.scale = (2, 2, 0.5)\n\n# Create corner supports\ncorners = []\npositions = [(-1.5, -1.5, 0), (1.5, -1.5, 0), (-1.5, 1.5, 0), (1.5, 1.5, 0)]\nfor i, pos in enumerate(positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.4, location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"corner_{i}\"\n    corners.append(corner)\n\n# Create center support\nbpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=0.6, location=(0, 0, 0))\ncenter = bpy.context.active_object\ncenter.name = \"center_support\"\n\n# Create decorative buttons\nbuttons = []\nbutton_positions = [(-0.8, -0.8, 1.1), (0.8, -0.8, 1.1), (-0.8, 0.8, 1.1), (0.8, 0.8, 1.1)]\nfor i, pos in enumerate(button_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=0.1, location=pos)\n    button = bpy.context.active_object\n    button.name = f\"button_{i}\"\n    buttons.append(button)\n\n# Select all cushion parts\nall_objects = [base, top, center] + corners + buttons\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = base\n\n# Join all parts\nbpy.ops.object.join()\n\n# Apply modifiers and smooth\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='SELECT')\nbpy.ops.mesh.faces_shade_smooth()\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Export as STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs desk",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create desk top\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1))\ndesk_top = bpy.context.active_object\ndesk_top.name = \"DeskTop\"\ndesk_top.scale = (2, 1, 0.05)\n\n# Create leg 1\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-3.5, -1.5, 0))\nleg1 = bpy.context.active_object\nleg1.name = \"Leg1\"\nleg1.scale = (0.1, 0.1, 0.5)\n\n# Create leg 2\nbpy.ops.mesh.primitive_cube_add(size=2, location=(3.5, -1.5, 0))\nleg2 = bpy.context.active_object\nleg2.name = \"Leg2\"\nleg2.scale = (0.1, 0.1, 0.5)\n\n# Create leg 3\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-3.5, 1.5, 0))\nleg3 = bpy.context.active_object\nleg3.name = \"Leg3\"\nleg3.scale = (0.1, 0.1, 0.5)\n\n# Create leg 4\nbpy.ops.mesh.primitive_cube_add(size=2, location=(3.5, 1.5, 0))\nleg4 = bpy.context.active_object\nleg4.name = \"Leg4\"\nleg4.scale = (0.1, 0.1, 0.5)\n\n# Create drawer\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -1.8, 0.5))\ndrawer = bpy.context.active_object\ndrawer.name = \"Drawer\"\ndrawer.scale = (1.5, 0.3, 0.2)\n\n# Create drawer handle\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, -2.2, 0.5))\nhandle = bpy.context.active_object\nhandle.name = \"Handle\"\nhandle.scale = (0.05, 0.05, 0.3)\nhandle.rotation_euler = (1.5708, 0, 0)\n\n# Select all desk parts\nbpy.ops.object.select_all(action='DESELECT')\ndesk_parts = [desk_top, leg1, leg2, leg3, leg4, drawer, handle]\n\nfor part in desk_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = desk_top\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"Desk\"\n\n# Export as STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs door",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create door frame (main rectangle)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1))\ndoor_frame = bpy.context.active_object\ndoor_frame.name = \"DoorFrame\"\ndoor_frame.scale = (1.5, 0.1, 2)\n\n# Create door panel (slightly smaller rectangle)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0.05, 1))\ndoor_panel = bpy.context.active_object\ndoor_panel.name = \"DoorPanel\"\ndoor_panel.scale = (1.4, 0.05, 1.9)\n\n# Create door handle (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.3, location=(1.2, 0.15, 1))\ndoor_handle = bpy.context.active_object\ndoor_handle.name = \"DoorHandle\"\ndoor_handle.rotation_euler = (0, 1.5708, 0)\n\n# Create door knob (sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.08, location=(1.2, 0.25, 1))\ndoor_knob = bpy.context.active_object\ndoor_knob.name = \"DoorKnob\"\n\n# Create hinges (cylinders)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.2, location=(-1.4, 0.12, 1.5))\nhinge1 = bpy.context.active_object\nhinge1.name = \"Hinge1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.2, location=(-1.4, 0.12, 0.5))\nhinge2 = bpy.context.active_object\nhinge2.name = \"Hinge2\"\n\n# Create door window (cube scaled thin)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0.06, 1.8))\ndoor_window = bpy.context.active_object\ndoor_window.name = \"DoorWindow\"\ndoor_window.scale = (0.8, 0.02, 0.6)\n\n# Select all door parts\ndoor_parts = [door_frame, door_panel, door_handle, door_knob, hinge1, hinge2, door_window]\n\n# Deselect all first\nbpy.ops.object.select_all(action='DESELECT')\n\n# Select all door parts\nfor part in door_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = door_frame\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Door\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs engine",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Engine block (main body)\nbpy.ops.mesh.primitive_cube_add(size=4, location=(0, 0, 0))\nengine_block = bpy.context.object\nengine_block.name = \"Engine_Block\"\nengine_block.scale = (2, 1.5, 1)\n\n# Cylinder head\nbpy.ops.mesh.primitive_cube_add(size=3, location=(0, 0, 2.5))\ncylinder_head = bpy.context.object\ncylinder_head.name = \"Cylinder_Head\"\ncylinder_head.scale = (1.8, 1.3, 0.8)\n\n# Oil pan\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, -2.5))\noil_pan = bpy.context.object\noil_pan.name = \"Oil_Pan\"\noil_pan.scale = (1.5, 1.2, 0.5)\n\n# Cylinders\nfor i in range(4):\n    x_pos = -3 + i * 2\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.6, depth=2, location=(x_pos, 0, 1))\n    cylinder = bpy.context.object\n    cylinder.name = f\"Cylinder_{i+1}\"\n\n# Pistons\nfor i in range(4):\n    x_pos = -3 + i * 2\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.5, depth=1.5, location=(x_pos, 0, 0.5))\n    piston = bpy.context.object\n    piston.name = f\"Piston_{i+1}\"\n\n# Crankshaft\nbpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=8, location=(0, 0, -1))\ncrankshaft = bpy.context.object\ncrankshaft.name = \"Crankshaft\"\ncrankshaft.rotation_euler = (0, 1.5708, 0)\n\n# Intake manifold\nbpy.ops.mesh.primitive_cube_add(size=1.5, location=(0, 2, 3))\nintake_manifold = bpy.context.object\nintake_manifold.name = \"Intake_Manifold\"\nintake_manifold.scale = (2, 0.8, 0.6)\n\n# Exhaust manifold\nbpy.ops.mesh.primitive_cube_add(size=1.5, location=(0, -2, 2.5))\nexhaust_manifold = bpy.context.object\nexhaust_manifold.name = \"Exhaust_Manifold\"\nexhaust_manifold.scale = (2, 0.6, 0.8)\n\n# Air filter\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=1.5, location=(0, 3.5, 3))\nair_filter = bpy.context.object\nair_filter.name = \"Air_Filter\"\n\n# Spark plugs\nfor i in range(4):\n    x_pos = -3 + i * 2\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=1, location=(x_pos, 0, 4))\n    spark_plug = bpy.context.object\n    spark_plug.name = f\"Spark_Plug_{i+1}\"\n\n# Alternator\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=1.5, location=(4, 1, 1))\nalternator = bpy.context.object\nalternator.name = \"Alternator\"\n\n# Water pump\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=1, location=(-4, 1.5, 1.5))\nwater_pump = bpy.context.object\nwater_pump.name = \"Water_Pump\"\n\n# Radiator\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 4, 1))\nradiator = bpy.context.object\nradiator.name = \"Radiator\"\nradiator.scale = (2.5, 0.3, 1.5)\n\n# Oil filter\nbpy.ops.mesh.primitive_cylinder_add(radius=0.6, depth=1.2, location=(3, -1, -1))\noil_filter = bpy.context.object\noil_filter.name = \"Oil_Filter\"\n\n# Timing belt cover\nbpy.ops.mesh.primitive_cube_add(size=1, location=(-4, 0, 2))\ntiming_cover = bpy.context.object\ntiming_cover.name = \"Timing_Cover\"\ntiming_cover.scale = (0.3, 1.2, 1.8)\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.object.name = \"Engine\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "abs filter",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create ABS filter components\n# Main filter housing (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=1, location=(0, 0, 0))\nhousing = bpy.context.active_object\nhousing.name = \"FilterHousing\"\n\n# Inlet pipe (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=1.5, location=(-2.5, 0, 0))\nbpy.ops.transform.rotate(value=1.5708, orient_axis='Y')\ninlet = bpy.context.active_object\ninlet.name = \"InletPipe\"\n\n# Outlet pipe (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=1.5, location=(2.5, 0, 0))\nbpy.ops.transform.rotate(value=1.5708, orient_axis='Y')\noutlet = bpy.context.active_object\noutlet.name = \"OutletPipe\"\n\n# Filter element (smaller cylinder inside)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=0.8, location=(0, 0, 0))\nfilter_element = bpy.context.active_object\nfilter_element.name = \"FilterElement\"\n\n# Top cap (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2.1, depth=0.2, location=(0, 0, 0.6))\ntop_cap = bpy.context.active_object\ntop_cap.name = \"TopCap\"\n\n# Bottom cap (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2.1, depth=0.2, location=(0, 0, -0.6))\nbottom_cap = bpy.context.active_object\nbottom_cap.name = \"BottomCap\"\n\n# Mounting bracket (cube)\nbpy.ops.mesh.primitive_cube_add(size=0.5, location=(0, 2.5, 0))\nbpy.ops.transform.resize(value=(4, 0.5, 0.5))\nbracket = bpy.context.active_object\nbracket.name = \"MountingBracket\"\n\n# Select all filter parts\nfilter_parts = [housing, inlet, outlet, filter_element, top_cap, bottom_cap, bracket]\nbpy.ops.object.select_all(action='DESELECT')\n\nfor part in filter_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = housing\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Export as ASCII STL\noutput_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=output_path,\n    use_selection=False,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs floor",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create abs floor components\ncomponents = []\n\n# Main floor base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nfloor_base = bpy.context.active_object\nfloor_base.name = \"FloorBase\"\nfloor_base.scale = (4, 4, 0.1)\ncomponents.append(floor_base)\n\n# Abs texture pattern - create raised rectangular sections\nfor i in range(-3, 4):\n    for j in range(-3, 4):\n        if (i + j) % 2 == 0:\n            bpy.ops.mesh.primitive_cube_add(size=0.4, location=(i * 0.5, j * 0.5, 0.12))\n            abs_section = bpy.context.active_object\n            abs_section.name = f\"AbsSection_{i}_{j}\"\n            abs_section.scale = (1, 1, 0.3)\n            components.append(abs_section)\n\n# Create raised edges\nfor i in range(4):\n    # Front edge\n    bpy.ops.mesh.primitive_cube_add(size=1, location=(-3.5 + i * 2.33, 4, 0.15))\n    edge = bpy.context.active_object\n    edge.name = f\"EdgeFront_{i}\"\n    edge.scale = (0.3, 0.1, 0.4)\n    components.append(edge)\n    \n    # Back edge\n    bpy.ops.mesh.primitive_cube_add(size=1, location=(-3.5 + i * 2.33, -4, 0.15))\n    edge = bpy.context.active_object\n    edge.name = f\"EdgeBack_{i}\"\n    edge.scale = (0.3, 0.1, 0.4)\n    components.append(edge)\n    \n    # Left edge\n    bpy.ops.mesh.primitive_cube_add(size=1, location=(-4, -3.5 + i * 2.33, 0.15))\n    edge = bpy.context.active_object\n    edge.name = f\"EdgeLeft_{i}\"\n    edge.scale = (0.1, 0.3, 0.4)\n    components.append(edge)\n    \n    # Right edge\n    bpy.ops.mesh.primitive_cube_add(size=1, location=(4, -3.5 + i * 2.33, 0.15))\n    edge = bpy.context.active_object\n    edge.name = f\"EdgeRight_{i}\"\n    edge.scale = (0.1, 0.3, 0.4)\n    components.append(edge)\n\n# Corner cylinders for rounded corners\ncorner_positions = [(-4, -4, 0.15), (4, -4, 0.15), (-4, 4, 0.15), (4, 4, 0.15)]\nfor i, pos in enumerate(corner_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.8, location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"Corner_{i}\"\n    components.append(corner)\n\n# Add some circular grip patterns\nfor i in range(-2, 3):\n    for j in range(-2, 3):\n        if i % 2 == 0 and j % 2 == 0:\n            bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.2, location=(i * 1.5, j * 1.5, 0.22))\n            grip = bpy.context.active_object\n            grip.name = f\"Grip_{i}_{j}\"\n            components.append(grip)\n\n# Select all components\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in components:\n    obj.select_set(True)\n\n# Set the first object as active\nbpy.context.view_layer.objects.active = components[0]\n\n# Join all objects\nbpy.ops.object.join()\n\n# Rename the final object\nfinal_object = bpy.context.active_object\nfinal_object.name = \"AbsFloor\"\n\n# Export as ASCII STL\noutput_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=output_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs fork",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Delete all default objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create fork handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2, location=(0, 0, 0))\nhandle = bpy.context.active_object\nhandle.name = \"Handle\"\n\n# Create fork head base\nbpy.ops.mesh.primitive_cube_add(size=0.6, location=(0, 0, 1.2))\nfork_head = bpy.context.active_object\nfork_head.name = \"ForkHead\"\nfork_head.scale = (1, 0.2, 0.1)\n\n# Create fork prongs\nprong_positions = [(-0.2, 0, 1.4), (-0.067, 0, 1.4), (0.067, 0, 1.4), (0.2, 0, 1.4)]\nprongs = []\n\nfor i, pos in enumerate(prong_positions):\n    bpy.ops.mesh.primitive_cube_add(size=0.04, location=pos)\n    prong = bpy.context.active_object\n    prong.name = f\"Prong_{i+1}\"\n    prong.scale = (1, 0.5, 8)\n    prongs.append(prong)\n\n# Select all fork parts\nbpy.ops.object.select_all(action='DESELECT')\nhandle.select_set(True)\nfork_head.select_set(True)\nfor prong in prongs:\n    prong.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = handle\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the final object\nfork = bpy.context.active_object\nfork.name = \"Fork\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs frame",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create abs frame components\n# Base frame\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.1))\nbase = bpy.context.active_object\nbase.name = \"abs_base\"\nbase.scale = (3, 2, 0.1)\n\n# Vertical supports\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-2.5, 0, 1))\nleft_support = bpy.context.active_object\nleft_support.name = \"left_support\"\nleft_support.scale = (0.2, 1.8, 1)\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(2.5, 0, 1))\nright_support = bpy.context.active_object\nright_support.name = \"right_support\"\nright_support.scale = (0.2, 1.8, 1)\n\n# Top frame\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1.9))\ntop_frame = bpy.context.active_object\ntop_frame.name = \"top_frame\"\ntop_frame.scale = (3, 2, 0.1)\n\n# Print bed\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.3))\nprint_bed = bpy.context.active_object\nprint_bed.name = \"print_bed\"\nprint_bed.scale = (2, 1.5, 0.05)\n\n# Extruder assembly (simplified)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1.5))\nextruder_body = bpy.context.active_object\nextruder_body.name = \"extruder_body\"\nextruder_body.scale = (0.3, 0.3, 0.2)\n\n# Extruder nozzle\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, 0, 1.2))\nnozzle = bpy.context.active_object\nnozzle.name = \"nozzle\"\nnozzle.scale = (0.05, 0.05, 0.2)\n\n# Guide rods\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(-2, -1.5, 1))\nrod1 = bpy.context.active_object\nrod1.name = \"guide_rod_1\"\nrod1.scale = (0.02, 0.02, 0.8)\n\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(2, -1.5, 1))\nrod2 = bpy.context.active_object\nrod2.name = \"guide_rod_2\"\nrod2.scale = (0.02, 0.02, 0.8)\n\n# Motors (simplified as cylinders)\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(-2.8, 0, 0.5))\nmotor1 = bpy.context.active_object\nmotor1.name = \"motor_1\"\nmotor1.scale = (0.25, 0.25, 0.3)\nmotor1.rotation_euler = (1.5708, 0, 0)\n\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(2.8, 0, 0.5))\nmotor2 = bpy.context.active_object\nmotor2.name = \"motor_2\"\nmotor2.scale = (0.25, 0.25, 0.3)\nmotor2.rotation_euler = (1.5708, 0, 0)\n\n# Corner brackets\ncorners = [(-2.5, -1.8, 0.2), (2.5, -1.8, 0.2), (-2.5, 1.8, 0.2), (2.5, 1.8, 0.2)]\nfor i, pos in enumerate(corners):\n    bpy.ops.mesh.primitive_cube_add(size=2, location=pos)\n    bracket = bpy.context.active_object\n    bracket.name = f\"corner_bracket_{i}\"\n    bracket.scale = (0.15, 0.15, 0.1)\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"abs_frame\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs gear",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create main gear body (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=0.5, location=(0, 0, 0))\nmain_body = bpy.context.active_object\nmain_body.name = \"gear_body\"\n\n# Create center hole\nbpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=0.6, location=(0, 0, 0))\ncenter_hole = bpy.context.active_object\ncenter_hole.name = \"center_hole\"\n\n# Boolean operation to create hole in main body\nmain_body.select_set(True)\nbpy.context.view_layer.objects.active = main_body\nbool_modifier = main_body.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nbool_modifier.operation = 'DIFFERENCE'\nbool_modifier.object = center_hole\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete the center hole object\nbpy.data.objects.remove(center_hole, do_unlink=True)\n\n# Create gear teeth using cylinders positioned around the circumference\nimport math\ngear_parts = [main_body]\nnum_teeth = 12\ntooth_radius = 0.15\ngear_radius = 2.3\n\nfor i in range(num_teeth):\n    angle = (2 * math.pi * i) / num_teeth\n    x = gear_radius * math.cos(angle)\n    y = gear_radius * math.sin(angle)\n    \n    bpy.ops.mesh.primitive_cylinder_add(radius=tooth_radius, depth=0.5, location=(x, y, 0))\n    tooth = bpy.context.active_object\n    tooth.name = f\"tooth_{i}\"\n    gear_parts.append(tooth)\n\n# Create mounting holes\nfor i in range(4):\n    angle = (math.pi * i) / 2\n    x = 1.2 * math.cos(angle)\n    y = 1.2 * math.sin(angle)\n    \n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.6, location=(x, y, 0))\n    hole = bpy.context.active_object\n    hole.name = f\"mount_hole_{i}\"\n    \n    # Boolean operation to subtract from main body\n    main_body.select_set(True)\n    bpy.context.view_layer.objects.active = main_body\n    bool_modifier = main_body.modifiers.new(name=f\"Boolean_{i}\", type='BOOLEAN')\n    bool_modifier.operation = 'DIFFERENCE'\n    bool_modifier.object = hole\n    bpy.ops.object.modifier_apply(modifier=f\"Boolean_{i}\")\n    \n    # Remove hole object\n    bpy.data.objects.remove(hole, do_unlink=True)\n\n# Select all gear parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in gear_parts:\n    part.select_set(True)\n\n# Join all parts\nbpy.context.view_layer.objects.active = gear_parts[0]\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs glass",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create main body (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=3, location=(0, 0, 1.5))\nbody = bpy.context.active_object\nbody.name = \"abs_body\"\n\n# Create top section (smaller cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.8, depth=1, location=(0, 0, 3.5))\ntop = bpy.context.active_object\ntop.name = \"abs_top\"\n\n# Create bottom section (larger cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2.2, depth=0.5, location=(0, 0, -0.25))\nbottom = bpy.context.active_object\nbottom.name = \"abs_bottom\"\n\n# Create muscle definition lines (flattened spheres)\nmuscle_positions = [\n    (0, 0, 2.8),\n    (0, 0, 2.2),\n    (0, 0, 1.6),\n    (0, 0, 1.0),\n    (0, 0, 0.4)\n]\n\nmuscle_objects = []\nfor i, pos in enumerate(muscle_positions):\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, location=pos)\n    muscle = bpy.context.active_object\n    muscle.name = f\"muscle_line_{i}\"\n    muscle.scale[2] = 0.1\n    muscle_objects.append(muscle)\n\n# Create side definition (cubes for obliques)\nbpy.ops.mesh.primitive_cube_add(size=0.3, location=(1.5, 0, 2))\nleft_oblique = bpy.context.active_object\nleft_oblique.name = \"left_oblique\"\nleft_oblique.scale = (0.5, 3, 2)\n\nbpy.ops.mesh.primitive_cube_add(size=0.3, location=(-1.5, 0, 2))\nright_oblique = bpy.context.active_object\nright_oblique.name = \"right_oblique\"\nright_oblique.scale = (0.5, 3, 2)\n\n# Create center line (flattened cube)\nbpy.ops.mesh.primitive_cube_add(size=0.1, location=(0, 0, 2))\ncenter_line = bpy.context.active_object\ncenter_line.name = \"center_line\"\ncenter_line.scale = (0.1, 1.5, 3)\n\n# Select all objects for grouping\nall_objects = [body, top, bottom, left_oblique, right_oblique, center_line] + muscle_objects\n\nfor obj in all_objects:\n    obj.select_set(True)\n\nbpy.context.view_layer.objects.active = body\n\n# Join all objects\nbpy.ops.object.join()\n\n# Export as ASCII STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=export_path, use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "abs handle",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create handle grip (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.15,\n    depth=1.2,\n    location=(0, 0, 0),\n    rotation=(1.5708, 0, 0)\n)\ngrip = bpy.context.active_object\ngrip.name = \"HandleGrip\"\n\n# Create handle base (wider cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.25,\n    depth=0.3,\n    location=(0, -0.75, 0),\n    rotation=(1.5708, 0, 0)\n)\nbase = bpy.context.active_object\nbase.name = \"HandleBase\"\n\n# Create top cap (sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=0.18,\n    location=(0, 0.75, 0)\n)\ntop_cap = bpy.context.active_object\ntop_cap.name = \"TopCap\"\n\n# Create mounting bracket (cube)\nbpy.ops.mesh.primitive_cube_add(\n    size=0.4,\n    location=(0, -0.9, 0)\n)\nbracket = bpy.context.active_object\nbracket.scale = (1.5, 0.3, 0.8)\nbracket.name = \"MountingBracket\"\n\n# Create textured grip sections (torus rings)\nfor i in range(3):\n    y_pos = -0.2 + (i * 0.3)\n    bpy.ops.mesh.primitive_torus_add(\n        major_radius=0.16,\n        minor_radius=0.02,\n        location=(0, y_pos, 0),\n        rotation=(1.5708, 0, 0)\n    )\n    ring = bpy.context.active_object\n    ring.name = f\"GripRing_{i+1}\"\n\n# Create end connector (cone)\nbpy.ops.mesh.primitive_cone_add(\n    radius1=0.2,\n    radius2=0.15,\n    depth=0.2,\n    location=(0, -0.6, 0),\n    rotation=(1.5708, 0, 0)\n)\nconnector = bpy.context.active_object\nconnector.name = \"EndConnector\"\n\n# Select all objects and join them\nbpy.ops.object.select_all(action='SELECT')\nbpy.context.view_layer.objects.active = grip\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"ABSHandle\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs hinge",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create hinge barrel (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.5, depth=3, location=(0, 0, 0))\nbarrel = bpy.context.active_object\nbarrel.name = \"hinge_barrel\"\n\n# Create hinge pin (smaller cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=3.2, location=(0, 0, 0))\npin = bpy.context.active_object\npin.name = \"hinge_pin\"\npin.rotation_euler = (1.5708, 0, 0)  # 90 degrees around X\n\n# Create first hinge leaf\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-1.5, 0, 0))\nleaf1 = bpy.context.active_object\nleaf1.name = \"hinge_leaf1\"\nleaf1.scale = (0.8, 1.5, 0.05)\n\n# Create second hinge leaf\nbpy.ops.mesh.primitive_cube_add(size=2, location=(1.5, 0, 0))\nleaf2 = bpy.context.active_object\nleaf2.name = \"hinge_leaf2\"\nleaf2.scale = (0.8, 1.5, 0.05)\n\n# Create mounting holes for first leaf\nfor i in range(4):\n    x_offset = -0.5 if i < 2 else 0.5\n    y_offset = -0.5 if i % 2 == 0 else 0.5\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.2, location=(-1.5 + x_offset, y_offset, 0))\n    hole = bpy.context.active_object\n    hole.name = f\"hole1_{i}\"\n\n# Create mounting holes for second leaf\nfor i in range(4):\n    x_offset = -0.5 if i < 2 else 0.5\n    y_offset = -0.5 if i % 2 == 0 else 0.5\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.2, location=(1.5 + x_offset, y_offset, 0))\n    hole = bpy.context.active_object\n    hole.name = f\"hole2_{i}\"\n\n# Create knuckles for barrel segmentation\nfor i in range(5):\n    z_pos = -1.2 + (i * 0.6)\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.52, depth=0.5, location=(0, 0, z_pos))\n    knuckle = bpy.context.active_object\n    knuckle.name = f\"knuckle_{i}\"\n    knuckle.rotation_euler = (1.5708, 0, 0)\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Rename the combined object\nbpy.context.active_object.name = \"hinge_assembly\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "abs hood",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create main hood body\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0))\nhood_body = bpy.context.active_object\nhood_body.name = \"hood_body\"\nhood_body.scale = (3, 2, 0.1)\n\n# Create hood curved top\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, 0.5))\nhood_top = bpy.context.active_object\nhood_top.name = \"hood_top\"\nhood_top.scale = (2.8, 1.8, 0.8)\nhood_top.rotation_euler = (1.57, 0, 0)\n\n# Create front lip\nbpy.ops.mesh.primitive_cube_add(location=(0, -2.2, -0.05))\nfront_lip = bpy.context.active_object\nfront_lip.name = \"front_lip\"\nfront_lip.scale = (2.8, 0.2, 0.08)\n\n# Create side vents (left)\nbpy.ops.mesh.primitive_cube_add(location=(-2.5, -1, 0.2))\nleft_vent = bpy.context.active_object\nleft_vent.name = \"left_vent\"\nleft_vent.scale = (0.3, 0.8, 0.05)\n\n# Create side vents (right)\nbpy.ops.mesh.primitive_cube_add(location=(2.5, -1, 0.2))\nright_vent = bpy.context.active_object\nright_vent.name = \"right_vent\"\nright_vent.scale = (0.3, 0.8, 0.05)\n\n# Create air intake (center)\nbpy.ops.mesh.primitive_cube_add(location=(0, -1.8, 0.15))\nair_intake = bpy.context.active_object\nair_intake.name = \"air_intake\"\nair_intake.scale = (1.2, 0.3, 0.1)\n\n# Create hood ornament base\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0.5, 0.2))\nornament_base = bpy.context.active_object\nornament_base.name = \"ornament_base\"\nornament_base.scale = (0.1, 0.1, 0.05)\n\n# Create hood hinges (left)\nbpy.ops.mesh.primitive_cylinder_add(location=(-2, 1.8, 0.1))\nleft_hinge = bpy.context.active_object\nleft_hinge.name = \"left_hinge\"\nleft_hinge.scale = (0.1, 0.1, 0.2)\nleft_hinge.rotation_euler = (0, 1.57, 0)\n\n# Create hood hinges (right)\nbpy.ops.mesh.primitive_cylinder_add(location=(2, 1.8, 0.1))\nright_hinge = bpy.context.active_object\nright_hinge.name = \"right_hinge\"\nright_hinge.scale = (0.1, 0.1, 0.2)\nright_hinge.rotation_euler = (0, 1.57, 0)\n\n# Select all hood parts\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all parts into one object\nbpy.context.view_layer.objects.active = hood_body\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"car_hood\"\n\n# Export as STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs jar",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create jar body (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.5, \n    depth=3.0, \n    location=(0, 0, 0)\n)\njar_body = bpy.context.active_object\njar_body.name = \"jar_body\"\n\n# Create jar neck (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.0, \n    depth=0.8, \n    location=(0, 0, 2.0)\n)\njar_neck = bpy.context.active_object\njar_neck.name = \"jar_neck\"\n\n# Create jar lid (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.1, \n    depth=0.3, \n    location=(0, 0, 2.6)\n)\njar_lid = bpy.context.active_object\njar_lid.name = \"jar_lid\"\n\n# Create lid knob (sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=0.3, \n    location=(0, 0, 2.9)\n)\nlid_knob = bpy.context.active_object\nlid_knob.name = \"lid_knob\"\nlid_knob.scale[2] = 0.5\n\n# Create jar bottom (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.5, \n    depth=0.2, \n    location=(0, 0, -1.6)\n)\njar_bottom = bpy.context.active_object\njar_bottom.name = \"jar_bottom\"\n\n# Select all jar parts\njar_parts = [jar_body, jar_neck, jar_lid, lid_knob, jar_bottom]\nbpy.ops.object.select_all(action='DESELECT')\nfor part in jar_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = jar_body\n\n# Join all parts\nbpy.ops.object.join()\n\n# Rename the combined object\nbpy.context.active_object.name = \"jar\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs key",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create key body (main part)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nkey_body = bpy.context.active_object\nkey_body.name = \"KeyBody\"\nkey_body.scale = (0.6, 0.1, 0.05)\n\n# Create key head (top part)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0.8, 0))\nkey_head = bpy.context.active_object\nkey_head.name = \"KeyHead\"\nkey_head.scale = (0.8, 0.3, 0.05)\n\n# Create key teeth (bottom notches)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-0.3, -0.5, 0))\nkey_tooth1 = bpy.context.active_object\nkey_tooth1.name = \"KeyTooth1\"\nkey_tooth1.scale = (0.1, 0.15, 0.03)\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-0.1, -0.6, 0))\nkey_tooth2 = bpy.context.active_object\nkey_tooth2.name = \"KeyTooth2\"\nkey_tooth2.scale = (0.08, 0.1, 0.03)\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0.2, -0.55, 0))\nkey_tooth3 = bpy.context.active_object\nkey_tooth3.name = \"KeyTooth3\"\nkey_tooth3.scale = (0.12, 0.12, 0.03)\n\n# Create key hole in head\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=0.2, location=(0, 0.8, 0))\nkey_hole = bpy.context.active_object\nkey_hole.name = \"KeyHole\"\n\n# Create key grip (handle details)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.1, location=(-0.4, 0.8, 0))\ngrip1 = bpy.context.active_object\ngrip1.name = \"Grip1\"\ngrip1.rotation_euler = (0, 1.5708, 0)\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.1, location=(0.4, 0.8, 0))\ngrip2 = bpy.context.active_object\ngrip2.name = \"Grip2\"\ngrip2.rotation_euler = (0, 1.5708, 0)\n\n# Select all key parts\nbpy.ops.object.select_all(action='DESELECT')\nkey_parts = [key_body, key_head, key_tooth1, key_tooth2, key_tooth3, key_hole, grip1, grip2]\n\nfor part in key_parts:\n    part.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = key_body\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Create collection for organization\ncollection = bpy.data.collections.new(\"Key\")\nbpy.context.scene.collection.children.link(collection)\ncollection.objects.link(key_body)\nbpy.context.scene.collection.objects.unlink(key_body)\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=False,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs knife",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create knife blade using scaled cube\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0))\nblade = bpy.context.active_object\nblade.name = \"Blade\"\nblade.scale = (0.1, 2.0, 0.05)\nbpy.ops.object.transform_apply(transform_type='SCALE')\n\n# Create knife handle using cylinder\nbpy.ops.mesh.primitive_cylinder_add(location=(0, -1.5, 0))\nhandle = bpy.context.active_object\nhandle.name = \"Handle\"\nhandle.scale = (0.15, 0.15, 1.0)\nhandle.rotation_euler = (1.5708, 0, 0)\nbpy.ops.object.transform_apply(transform_type='SCALE')\nbpy.ops.object.transform_apply(transform_type='ROTATION')\n\n# Create guard using scaled cube\nbpy.ops.mesh.primitive_cube_add(location=(0, -0.5, 0))\nguard = bpy.context.active_object\nguard.name = \"Guard\"\nguard.scale = (0.3, 0.1, 0.08)\nbpy.ops.object.transform_apply(transform_type='SCALE')\n\n# Create pommel using UV sphere\nbpy.ops.mesh.primitive_uv_sphere_add(location=(0, -2.5, 0))\npommel = bpy.context.active_object\npommel.name = \"Pommel\"\npommel.scale = (0.2, 0.2, 0.2)\nbpy.ops.object.transform_apply(transform_type='SCALE')\n\n# Select all knife parts\nbpy.ops.object.select_all(action='DESELECT')\nblade.select_set(True)\nhandle.select_set(True)\nguard.select_set(True)\npommel.select_set(True)\n\n# Set active object and join\nbpy.context.view_layer.objects.active = blade\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=False,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs knob",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create knob base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.0,\n    depth=0.3,\n    location=(0, 0, 0)\n)\nbase = bpy.context.active_object\nbase.name = \"knob_base\"\n\n# Create knob top (cylinder, smaller)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.8,\n    depth=0.2,\n    location=(0, 0, 0.25)\n)\ntop = bpy.context.active_object\ntop.name = \"knob_top\"\n\n# Create center grip (cylinder, even smaller)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.6,\n    depth=0.15,\n    location=(0, 0, 0.425)\n)\ngrip = bpy.context.active_object\ngrip.name = \"knob_grip\"\n\n# Add ridges around the grip using small cylinders\nridges = []\nfor i in range(8):\n    angle = i * 0.785398  # 45 degrees in radians\n    x = 0.65 * cos(angle) if 'cos' in dir(__builtins__) else 0.65 * (1 if i % 2 == 0 else -1 if i == 2 or i == 6 else 0)\n    y = 0.65 * sin(angle) if 'sin' in dir(__builtins__) else 0.65 * (0 if i % 2 == 0 else 1 if i == 1 or i == 3 else -1)\n    \n    # Simplified positioning\n    positions = [(0.65, 0, 0.425), (0.46, 0.46, 0.425), (0, 0.65, 0.425), (-0.46, 0.46, 0.425),\n                 (-0.65, 0, 0.425), (-0.46, -0.46, 0.425), (0, -0.65, 0.425), (0.46, -0.46, 0.425)]\n    \n    bpy.ops.mesh.primitive_cylinder_add(\n        radius=0.05,\n        depth=0.2,\n        location=positions[i]\n    )\n    ridge = bpy.context.active_object\n    ridge.name = f\"ridge_{i}\"\n    ridges.append(ridge)\n\n# Create indicator dot (sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=0.08,\n    location=(0, 0.5, 0.425)\n)\nindicator = bpy.context.active_object\nindicator.name = \"indicator\"\n\n# Select all knob parts\nknob_parts = [base, top, grip, indicator] + ridges\nfor obj in knob_parts:\n    obj.select_set(True)\n\n# Make base the active object\nbpy.context.view_layer.objects.active = base\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the final object\nfinal_knob = bpy.context.active_object\nfinal_knob.name = \"abs_knob\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs lamp",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create lamp base\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=0.3, location=(0, 0, 0.15))\nbase = bpy.context.active_object\nbase.name = \"lamp_base\"\n\n# Create lamp pole\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=4, location=(0, 0, 2.15))\npole = bpy.context.active_object\npole.name = \"lamp_pole\"\n\n# Create lamp head\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.8, location=(0, 0, 4.5))\nhead = bpy.context.active_object\nhead.name = \"lamp_head\"\n\n# Create lamp shade (cone)\nbpy.ops.mesh.primitive_cone_add(radius1=1.2, radius2=0.8, depth=1.5, location=(0, 0, 5.2))\nshade = bpy.context.active_object\nshade.name = \"lamp_shade\"\n\n# Create light bulb\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.3, location=(0, 0, 4.8))\nbulb = bpy.context.active_object\nbulb.name = \"light_bulb\"\n\n# Select all lamp parts\nlamp_parts = [base, pole, head, shade, bulb]\nbpy.ops.object.select_all(action='DESELECT')\nfor part in lamp_parts:\n    part.select_set(True)\n\n# Join all parts\nbpy.context.view_layer.objects.active = base\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs lock",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create lock body (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=2, location=(0, 0, 0))\nlock_body = bpy.context.active_object\nlock_body.name = \"LockBody\"\n\n# Create lock shackle (bent cylinder parts)\n# Left arm of shackle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=2, location=(-0.8, 0, 1.5))\nbpy.context.active_object.rotation_euler = (1.5708, 0, 0)\nleft_arm = bpy.context.active_object\nleft_arm.name = \"LeftArm\"\n\n# Right arm of shackle  \nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=2, location=(0.8, 0, 1.5))\nbpy.context.active_object.rotation_euler = (1.5708, 0, 0)\nright_arm = bpy.context.active_object\nright_arm.name = \"RightArm\"\n\n# Top of shackle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=1.6, location=(0, 1, 2.5))\nbpy.context.active_object.rotation_euler = (0, 1.5708, 0)\ntop_arm = bpy.context.active_object\ntop_arm.name = \"TopArm\"\n\n# Keyhole (small cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=0.5, location=(0, 1.6, 0))\nbpy.context.active_object.rotation_euler = (1.5708, 0, 0)\nkeyhole = bpy.context.active_object\nkeyhole.name = \"Keyhole\"\n\n# Lock face (flattened cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.6, depth=0.2, location=(0, 1.1, 0))\nbpy.context.active_object.rotation_euler = (1.5708, 0, 0)\nlock_face = bpy.context.active_object\nlock_face.name = \"LockFace\"\n\n# Create brand logo area (small cube)\nbpy.ops.mesh.primitive_cube_add(scale=(0.8, 0.1, 0.3), location=(0, 1.2, 0.5))\nbrand_area = bpy.context.active_object\nbrand_area.name = \"BrandArea\"\n\n# Select all lock parts\nlock_parts = [lock_body, left_arm, right_arm, top_arm, keyhole, lock_face, brand_area]\n\n# Deselect all first\nbpy.ops.object.select_all(action='DESELECT')\n\n# Select all lock parts\nfor part in lock_parts:\n    part.select_set(True)\n\n# Set the lock body as active object\nbpy.context.view_layer.objects.active = lock_body\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"AbsLock\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs mirror",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create mirror frame (cylinder for round mirror)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=0.1, location=(0, 0, 0))\nframe = bpy.context.active_object\nframe.name = \"MirrorFrame\"\n\n# Create mirror surface (cylinder, slightly smaller and thinner)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.0, depth=0.02, location=(0, 0, 0.05))\nmirror_surface = bpy.context.active_object\nmirror_surface.name = \"MirrorSurface\"\n\n# Create mirror stand base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=0.2, location=(0, 0, -0.5))\nbase = bpy.context.active_object\nbase.name = \"MirrorBase\"\n\n# Create mirror stand arm (cylinder, rotated)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=1.0, location=(0, 0, -0.1))\narm = bpy.context.active_object\narm.name = \"MirrorArm\"\narm.rotation_euler = (1.5708, 0, 0)  # 90 degrees in radians\n\n# Create adjustment joint (small sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.08, location=(0, 0.4, -0.1))\njoint = bpy.context.active_object\njoint.name = \"MirrorJoint\"\n\n# Create support bracket (cube)\nbpy.ops.mesh.primitive_cube_add(size=0.2, location=(0, 0.3, 0))\nbracket = bpy.context.active_object\nbracket.name = \"MirrorBracket\"\nbracket.scale = (0.5, 1.0, 0.3)\n\n# Select all mirror parts\nmirror_parts = [frame, mirror_surface, base, arm, joint, bracket]\nbpy.ops.object.select_all(action='DESELECT')\nfor part in mirror_parts:\n    part.select_set(True)\n\n# Set the frame as active object\nbpy.context.view_layer.objects.active = frame\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"Mirror\"\n\n# Export as ASCII STL\nfilepath = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=filepath, use_selection=True, ascii=True)\n```"
  },
  {
    "input": "abs motor",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False, confirm=False)\n\n# Create motor housing (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=3, location=(0, 0, 0))\nhousing = bpy.context.active_object\nhousing.name = \"Motor_Housing\"\n\n# Create motor shaft\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=4, location=(0, 0, 0))\nshaft = bpy.context.active_object\nshaft.name = \"Motor_Shaft\"\n\n# Create front end cap\nbpy.ops.mesh.primitive_cylinder_add(radius=1.6, depth=0.2, location=(0, 0, 1.6))\nfront_cap = bpy.context.active_object\nfront_cap.name = \"Front_Cap\"\n\n# Create rear end cap\nbpy.ops.mesh.primitive_cylinder_add(radius=1.6, depth=0.2, location=(0, 0, -1.6))\nrear_cap = bpy.context.active_object\nrear_cap.name = \"Rear_Cap\"\n\n# Create terminal box\nbpy.ops.mesh.primitive_cube_add(size=0.8, location=(1.8, 0, 0))\nterminal_box = bpy.context.active_object\nterminal_box.name = \"Terminal_Box\"\n\n# Create mounting feet (4 small cubes)\npositions = [(1.2, 1.2, -1.7), (-1.2, 1.2, -1.7), (1.2, -1.2, -1.7), (-1.2, -1.2, -1.7)]\nfor i, pos in enumerate(positions):\n    bpy.ops.mesh.primitive_cube_add(size=0.3, location=pos)\n    foot = bpy.context.active_object\n    foot.name = f\"Mounting_Foot_{i+1}\"\n\n# Create cooling fins (cylinders with holes)\nfor i in range(6):\n    angle = i * 60 * 3.14159 / 180\n    x = 1.7 * cos(angle) if 'cos' in dir() else 1.7 * (1 if i < 3 else -1) * 0.5\n    y = 1.7 * sin(angle) if 'sin' in dir() else 1.7 * (1 if i % 2 else -1) * 0.866\n    bpy.ops.mesh.primitive_cube_add(size=(0.1, 0.1, 2.8), location=(x, y, 0))\n    fin = bpy.context.active_object\n    fin.name = f\"Cooling_Fin_{i+1}\"\n\n# Create nameplate\nbpy.ops.mesh.primitive_cube_add(size=(1.2, 0.6, 0.05), location=(0, 1.55, 0))\nnameplate = bpy.context.active_object\nnameplate.name = \"Nameplate\"\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects\nbpy.context.view_layer.objects.active = housing\nbpy.ops.object.join()\n\n# Export as ASCII STL\noutput_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nif not bpy.path.abspath(\"//\"):\n    output_path = os.path.join(os.path.expanduser(\"~\"), \"duck.stl\")\n\nbpy.ops.export_mesh.stl(\n    filepath=output_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs mug",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create mug body (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, 0, 1))\nmug_body = bpy.context.active_object\nmug_body.name = \"MugBody\"\n\n# Create inner cavity (smaller cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.85, depth=1.8, location=(0, 0, 1.1))\ninner_cavity = bpy.context.active_object\ninner_cavity.name = \"InnerCavity\"\n\n# Boolean modifier to hollow out the mug\nmodifier = mug_body.modifiers.new(name=\"Hollow\", type='BOOLEAN')\nmodifier.object = inner_cavity\nmodifier.operation = 'DIFFERENCE'\n\n# Apply the modifier\nbpy.context.view_layer.objects.active = mug_body\nbpy.ops.object.modifier_apply(modifier=\"Hollow\")\n\n# Delete the inner cavity object\nbpy.ops.object.select_all(action='DESELECT')\ninner_cavity.select_set(True)\nbpy.ops.object.delete()\n\n# Create mug handle (torus)\nbpy.ops.mesh.primitive_torus_add(major_radius=0.6, minor_radius=0.1, location=(1.2, 0, 1))\nhandle = bpy.context.active_object\nhandle.name = \"MugHandle\"\nhandle.rotation_euler = (0, 1.5708, 0)  # Rotate 90 degrees around Y axis\n\n# Create mug bottom (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.9, depth=0.1, location=(0, 0, 0.05))\nbottom = bpy.context.active_object\nbottom.name = \"MugBottom\"\n\n# Select all mug parts\nbpy.ops.object.select_all(action='DESELECT')\nmug_body.select_set(True)\nhandle.select_set(True)\nbottom.select_set(True)\n\n# Set mug body as active object\nbpy.context.view_layer.objects.active = mug_body\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Create collection for the mug\ncollection = bpy.data.collections.new(\"Mug\")\nbpy.context.scene.collection.children.link(collection)\n\n# Move mug to collection\nmug_body.users_collection[0].objects.unlink(mug_body)\ncollection.objects.link(mug_body)\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=False,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs nail",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create nail head (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.3,\n    depth=0.1,\n    location=(0, 0, 0.95)\n)\nnail_head = bpy.context.active_object\nnail_head.name = \"NailHead\"\n\n# Create nail shaft (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.05,\n    depth=1.8,\n    location=(0, 0, 0)\n)\nnail_shaft = bpy.context.active_object\nnail_shaft.name = \"NailShaft\"\n\n# Create nail tip (cone)\nbpy.ops.mesh.primitive_cone_add(\n    radius1=0.05,\n    radius2=0.01,\n    depth=0.2,\n    location=(0, 0, -1.0)\n)\nnail_tip = bpy.context.active_object\nnail_tip.name = \"NailTip\"\n\n# Select all nail parts\nbpy.ops.object.select_all(action='DESELECT')\nnail_head.select_set(True)\nnail_shaft.select_set(True)\nnail_tip.select_set(True)\n\n# Set nail_head as active object\nbpy.context.view_layer.objects.active = nail_head\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the joined object\nnail_complete = bpy.context.active_object\nnail_complete.name = \"Nail\"\n\n# Apply all transforms\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs pan",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create pan base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=3, depth=0.3, location=(0, 0, 0))\npan_base = bpy.context.active_object\npan_base.name = \"pan_base\"\n\n# Create pan walls (cylinder with hole)\nbpy.ops.mesh.primitive_cylinder_add(radius=3.1, depth=0.8, location=(0, 0, 0.55))\npan_walls = bpy.context.active_object\npan_walls.name = \"pan_walls\"\n\n# Create inner cylinder to subtract (boolean)\nbpy.ops.mesh.primitive_cylinder_add(radius=2.9, depth=1, location=(0, 0, 0.6))\ninner_cylinder = bpy.context.active_object\ninner_cylinder.name = \"inner_cylinder\"\n\n# Apply boolean modifier to create hollow walls\nmodifier = pan_walls.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nmodifier.operation = 'DIFFERENCE'\nmodifier.object = inner_cylinder\nmodifier.solver = 'FAST'\n\n# Apply the modifier\nbpy.context.view_layer.objects.active = pan_walls\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete the inner cylinder helper\nbpy.data.objects.remove(inner_cylinder, do_unlink=True)\n\n# Create handle base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.4, location=(3.2, 0, 0.3))\nhandle_base = bpy.context.active_object\nhandle_base.name = \"handle_base\"\nbpy.ops.transform.rotate(value=1.5708, orient_axis='Y')\n\n# Create handle grip (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=2, location=(4.2, 0, 0.3))\nhandle_grip = bpy.context.active_object\nhandle_grip.name = \"handle_grip\"\nbpy.ops.transform.rotate(value=1.5708, orient_axis='Y')\n\n# Create handle end cap (sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.2, location=(5.2, 0, 0.3))\nhandle_end = bpy.context.active_object\nhandle_end.name = \"handle_end\"\n\n# Select all pan parts\npan_parts = [pan_base, pan_walls, handle_base, handle_grip, handle_end]\nfor obj in pan_parts:\n    obj.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = pan_base\n\n# Join all parts\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"abs_pan\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs panel",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create abs panel components\nabs_parts = []\n\n# Main panel body\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0), scale=(4, 6, 0.1))\nmain_panel = bpy.context.active_object\nmain_panel.name = \"MainPanel\"\nabs_parts.append(main_panel)\n\n# Top section with beveled edge\nbpy.ops.mesh.primitive_cube_add(location=(0, 2.5, 0.05), scale=(3.8, 0.5, 0.05))\ntop_section = bpy.context.active_object\ntop_section.name = \"TopSection\"\nabs_parts.append(top_section)\n\n# Bottom section\nbpy.ops.mesh.primitive_cube_add(location=(0, -2.5, 0.05), scale=(3.8, 0.5, 0.05))\nbottom_section = bpy.context.active_object\nbottom_section.name = \"BottomSection\"\nabs_parts.append(bottom_section)\n\n# Side reinforcement ribs\nfor i in range(-1, 2, 2):\n    bpy.ops.mesh.primitive_cube_add(location=(i * 3.5, 0, 0.05), scale=(0.3, 5.5, 0.08))\n    rib = bpy.context.active_object\n    rib.name = f\"SideRib_{i}\"\n    abs_parts.append(rib)\n\n# Central reinforcement bars\nfor i in range(-2, 3):\n    if i != 0:\n        bpy.ops.mesh.primitive_cube_add(location=(0, i * 1.2, 0.05), scale=(3.5, 0.15, 0.06))\n        bar = bpy.context.active_object\n        bar.name = f\"CentralBar_{i}\"\n        abs_parts.append(bar)\n\n# Corner mounting holes (using cylinders as negative space indicators)\ncorners = [(-3.5, -2.5, 0), (3.5, -2.5, 0), (-3.5, 2.5, 0), (3.5, 2.5, 0)]\nfor i, pos in enumerate(corners):\n    bpy.ops.mesh.primitive_cylinder_add(location=pos, scale=(0.2, 0.2, 0.2))\n    hole = bpy.context.active_object\n    hole.name = f\"MountHole_{i}\"\n    abs_parts.append(hole)\n\n# Central raised section\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0.1), scale=(2, 3, 0.05))\nraised_center = bpy.context.active_object\nraised_center.name = \"RaisedCenter\"\nabs_parts.append(raised_center)\n\n# Small cylindrical details\ndetail_positions = [(-1.5, -1, 0.12), (1.5, -1, 0.12), (-1.5, 1, 0.12), (1.5, 1, 0.12)]\nfor i, pos in enumerate(detail_positions):\n    bpy.ops.mesh.primitive_cylinder_add(location=pos, scale=(0.3, 0.3, 0.08))\n    detail = bpy.context.active_object\n    detail.name = f\"Detail_{i}\"\n    abs_parts.append(detail)\n\n# Select all parts\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in abs_parts:\n    obj.select_set(True)\n\n# Join all parts\nbpy.context.view_layer.objects.active = abs_parts[0]\nbpy.ops.object.join()\n\n# Export as STL\noutput_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=output_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs picture",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create torso (main body)\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0), scale=(2, 1, 3))\ntorso = bpy.context.active_object\ntorso.name = \"Torso\"\n\n# Create individual ab segments\nab_segments = []\nfor i in range(3):\n    for j in range(2):\n        x_pos = -0.4 + (j * 0.8)\n        z_pos = 0.8 - (i * 0.8)\n        bpy.ops.mesh.primitive_cube_add(location=(x_pos, 0.6, z_pos), scale=(0.3, 0.15, 0.3))\n        ab = bpy.context.active_object\n        ab.name = f\"Ab_{i}_{j}\"\n        ab_segments.append(ab)\n\n# Create chest muscles\nbpy.ops.mesh.primitive_cube_add(location=(-0.5, 0.5, 2), scale=(0.4, 0.2, 0.4))\nchest_left = bpy.context.active_object\nchest_left.name = \"Chest_Left\"\n\nbpy.ops.mesh.primitive_cube_add(location=(0.5, 0.5, 2), scale=(0.4, 0.2, 0.4))\nchest_right = bpy.context.active_object\nchest_right.name = \"Chest_Right\"\n\n# Create shoulders\nbpy.ops.mesh.primitive_uv_sphere_add(location=(-1.5, 0, 2.2), scale=(0.6, 0.6, 0.6))\nshoulder_left = bpy.context.active_object\nshoulder_left.name = \"Shoulder_Left\"\n\nbpy.ops.mesh.primitive_uv_sphere_add(location=(1.5, 0, 2.2), scale=(0.6, 0.6, 0.6))\nshoulder_right = bpy.context.active_object\nshoulder_right.name = \"Shoulder_Right\"\n\n# Create neck\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, 3.5), scale=(0.3, 0.3, 0.5))\nneck = bpy.context.active_object\nneck.name = \"Neck\"\n\n# Create obliques\nbpy.ops.mesh.primitive_cube_add(location=(-1.2, 0.3, 0), scale=(0.3, 0.2, 1))\noblique_left = bpy.context.active_object\noblique_left.name = \"Oblique_Left\"\n\nbpy.ops.mesh.primitive_cube_add(location=(1.2, 0.3, 0), scale=(0.3, 0.2, 1))\noblique_right = bpy.context.active_object\noblique_right.name = \"Oblique_Right\"\n\n# Select all objects\nall_objects = [torso, chest_left, chest_right, shoulder_left, shoulder_right, neck, oblique_left, oblique_right] + ab_segments\n\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set the torso as active object\nbpy.context.view_layer.objects.active = torso\n\n# Join all objects\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "abs pillow",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create pillow base - flattened cube\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0))\npillow_base = bpy.context.object\npillow_base.name = \"PillowBase\"\npillow_base.scale = (2, 1.5, 0.3)\n\n# Apply scale\nbpy.context.view_layer.objects.active = pillow_base\nbpy.ops.object.transform_apply(scale=True)\n\n# Add corner roundness with small spheres\ncorners = [\n    (1.8, 1.3, 0),\n    (-1.8, 1.3, 0),\n    (1.8, -1.3, 0),\n    (-1.8, -1.3, 0)\n]\n\ncorner_objects = []\nfor i, pos in enumerate(corners):\n    bpy.ops.mesh.primitive_uv_sphere_add(location=pos)\n    corner = bpy.context.object\n    corner.name = f\"Corner_{i}\"\n    corner.scale = (0.3, 0.3, 0.3)\n    corner_objects.append(corner)\n\n# Create pillow edges using cylinders\nedges = [\n    ((0, 1.3, 0), (0, 0, 1.57), (1.5, 0.3, 0.3)),  # front edge\n    ((0, -1.3, 0), (0, 0, 1.57), (1.5, 0.3, 0.3)), # back edge\n    ((1.8, 0, 0), (0, 0, 0), (1.0, 0.3, 0.3)),     # right edge\n    ((-1.8, 0, 0), (0, 0, 0), (1.0, 0.3, 0.3))     # left edge\n]\n\nedge_objects = []\nfor i, (pos, rot, scale) in enumerate(edges):\n    bpy.ops.mesh.primitive_cylinder_add(location=pos, rotation=rot)\n    edge = bpy.context.object\n    edge.name = f\"Edge_{i}\"\n    edge.scale = scale\n    edge_objects.append(edge)\n\n# Select all pillow parts\nbpy.ops.object.select_all(action='DESELECT')\npillow_base.select_set(True)\nfor obj in corner_objects + edge_objects:\n    obj.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = pillow_base\n\n# Join all parts\nbpy.ops.object.join()\n\n# Rename the final object\npillow = bpy.context.object\npillow.name = \"Pillow\"\n\n# Apply smooth shading\nbpy.ops.object.shade_smooth()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    ascii=True,\n    use_selection=False\n)\n```"
  },
  {
    "input": "abs pipe",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create main pipe cylinder\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=8, location=(0, 0, 0))\nmain_pipe = bpy.context.active_object\nmain_pipe.name = \"MainPipe\"\n\n# Create elbow joint - sphere\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.2, location=(0, 0, 4))\nelbow_joint = bpy.context.active_object\nelbow_joint.name = \"ElbowJoint\"\n\n# Create horizontal pipe section\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=6, location=(3, 0, 4))\nhorizontal_pipe = bpy.context.active_object\nhorizontal_pipe.name = \"HorizontalPipe\"\nhorizontal_pipe.rotation_euler = (0, 1.5708, 0)  # 90 degrees rotation\n\n# Create T-joint - sphere\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.2, location=(6, 0, 4))\nt_joint = bpy.context.active_object\nt_joint.name = \"TJoint\"\n\n# Create vertical branch pipe\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=4, location=(6, 0, 6))\nbranch_pipe = bpy.context.active_object\nbranch_pipe.name = \"BranchPipe\"\n\n# Create end cap - cone\nbpy.ops.mesh.primitive_cone_add(radius1=1, radius2=0, depth=2, location=(6, 0, 8))\nend_cap = bpy.context.active_object\nend_cap.name = \"EndCap\"\n\n# Create pipe coupling - torus-like structure using scaled cube\nbpy.ops.mesh.primitive_cube_add(size=2.5, location=(3, 0, 4))\ncoupling = bpy.context.active_object\ncoupling.name = \"Coupling\"\ncoupling.scale = (0.5, 0.5, 0.3)\n\n# Create pipe flange - cylinder\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=0.3, location=(0, 0, -4.15))\nflange = bpy.context.active_object\nflange.name = \"Flange\"\n\n# Create flange bolts using small cylinders\nbolt_positions = [(1.2, 0, -4.15), (-1.2, 0, -4.15), (0, 1.2, -4.15), (0, -1.2, -4.15)]\nbolts = []\nfor i, pos in enumerate(bolt_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.5, location=pos)\n    bolt = bpy.context.active_object\n    bolt.name = f\"Bolt_{i+1}\"\n    bolts.append(bolt)\n\n# Select all pipe objects\npipe_objects = [main_pipe, elbow_joint, horizontal_pipe, t_joint, branch_pipe, end_cap, coupling, flange] + bolts\n\n# Clear selection\nbpy.ops.object.select_all(action='DESELECT')\n\n# Select all pipe objects\nfor obj in pipe_objects:\n    obj.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = main_pipe\n\n# Create collection for grouping\ncollection = bpy.data.collections.new(\"ABSPipe\")\nbpy.context.scene.collection.children.link(collection)\n\n# Move objects to collection\nfor obj in pipe_objects:\n    bpy.context.scene.collection.objects.unlink(obj)\n    collection.objects.link(obj)\n\n# Join all objects\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs plate",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create abs plate base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nbase = bpy.context.active_object\nbase.name = \"abs_plate_base\"\nbase.scale = (4, 3, 0.1)\n\n# Create raised sections for abs definition\npositions = [\n    (-1.5, 1, 0.15), (-0.5, 1, 0.15), (0.5, 1, 0.15), (1.5, 1, 0.15),\n    (-1.5, 0, 0.15), (-0.5, 0, 0.15), (0.5, 0, 0.15), (1.5, 0, 0.15),\n    (-1, -1, 0.15), (0, -1, 0.15), (1, -1, 0.15)\n]\n\nabs_sections = []\nfor i, pos in enumerate(positions):\n    bpy.ops.mesh.primitive_cube_add(size=1, location=pos)\n    section = bpy.context.active_object\n    section.name = f\"abs_section_{i}\"\n    section.scale = (0.7, 0.7, 0.2)\n    abs_sections.append(section)\n\n# Create side support cylinders\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.4, location=(-3.5, 0, 0.1))\nleft_support = bpy.context.active_object\nleft_support.name = \"left_support\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.4, location=(3.5, 0, 0.1))\nright_support = bpy.context.active_object\nright_support.name = \"right_support\"\n\n# Create corner reinforcements using spheres\ncorners = [(-3.5, 2.5, 0.05), (3.5, 2.5, 0.05), (-3.5, -2.5, 0.05), (3.5, -2.5, 0.05)]\ncorner_reinforcements = []\nfor i, corner_pos in enumerate(corners):\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.3, location=corner_pos)\n    corner = bpy.context.active_object\n    corner.name = f\"corner_{i}\"\n    corner.scale = (1, 1, 0.3)\n    corner_reinforcements.append(corner)\n\n# Create center grip using cone\nbpy.ops.mesh.primitive_cone_add(radius1=0.4, radius2=0.2, depth=0.3, location=(0, 0, 0.25))\ncenter_grip = bpy.context.active_object\ncenter_grip.name = \"center_grip\"\n\n# Select all objects for grouping\nall_objects = [base] + abs_sections + [left_support, right_support] + corner_reinforcements + [center_grip]\n\n# Clear selection and select all parts\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set the base as active object\nbpy.context.view_layer.objects.active = base\n\n# Join all objects\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs pot",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create pot body (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.0,\n    depth=1.5,\n    location=(0, 0, 0.75)\n)\npot_body = bpy.context.active_object\npot_body.name = \"PotBody\"\n\n# Create pot rim (torus)\nbpy.ops.mesh.primitive_torus_add(\n    major_radius=1.1,\n    minor_radius=0.1,\n    location=(0, 0, 1.5)\n)\npot_rim = bpy.context.active_object\npot_rim.name = \"PotRim\"\n\n# Create pot handle 1\nbpy.ops.mesh.primitive_torus_add(\n    major_radius=0.3,\n    minor_radius=0.05,\n    location=(1.2, 0, 1.0)\n)\nhandle1 = bpy.context.active_object\nhandle1.name = \"Handle1\"\nhandle1.scale[0] = 0.5\n\n# Create pot handle 2\nbpy.ops.mesh.primitive_torus_add(\n    major_radius=0.3,\n    minor_radius=0.05,\n    location=(-1.2, 0, 1.0)\n)\nhandle2 = bpy.context.active_object\nhandle2.name = \"Handle2\"\nhandle2.scale[0] = 0.5\n\n# Create pot base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.8,\n    depth=0.2,\n    location=(0, 0, 0.1)\n)\npot_base = bpy.context.active_object\npot_base.name = \"PotBase\"\n\n# Select all pot parts\nbpy.ops.object.select_all(action='DESELECT')\nobjects_to_group = [pot_body, pot_rim, handle1, handle2, pot_base]\n\nfor obj in objects_to_group:\n    obj.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = pot_body\n\n# Join all objects\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs pump",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create pump body (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=3, location=(0, 0, 0))\npump_body = bpy.context.active_object\npump_body.name = \"PumpBody\"\n\n# Create pump base (flat cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=0.3, location=(0, 0, -1.65))\npump_base = bpy.context.active_object\npump_base.name = \"PumpBase\"\n\n# Create motor housing (cylinder on top)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=1.5, location=(0, 0, 2.25))\nmotor_housing = bpy.context.active_object\nmotor_housing.name = \"MotorHousing\"\n\n# Create inlet pipe (horizontal cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.4, depth=2, location=(-2.5, 0, 0))\nbpy.context.active_object.rotation_euler = (0, 1.5708, 0)\ninlet_pipe = bpy.context.active_object\ninlet_pipe.name = \"InletPipe\"\n\n# Create outlet pipe (horizontal cylinder, perpendicular to inlet)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.4, depth=2, location=(0, 2.5, 0.5))\nbpy.context.active_object.rotation_euler = (1.5708, 0, 0)\noutlet_pipe = bpy.context.active_object\noutlet_pipe.name = \"OutletPipe\"\n\n# Create inlet flange (torus-like using scaled cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.6, depth=0.2, location=(-3.4, 0, 0))\nbpy.context.active_object.rotation_euler = (0, 1.5708, 0)\ninlet_flange = bpy.context.active_object\ninlet_flange.name = \"InletFlange\"\n\n# Create outlet flange\nbpy.ops.mesh.primitive_cylinder_add(radius=0.6, depth=0.2, location=(0, 3.4, 0.5))\nbpy.context.active_object.rotation_euler = (1.5708, 0, 0)\noutlet_flange = bpy.context.active_object\noutlet_flange.name = \"OutletFlange\"\n\n# Create mounting feet (4 small cylinders)\nfeet_positions = [(-1.5, -1.5, -1.8), (1.5, -1.5, -1.8), (-1.5, 1.5, -1.8), (1.5, 1.5, -1.8)]\nfeet = []\nfor i, pos in enumerate(feet_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=0.3, location=pos)\n    foot = bpy.context.active_object\n    foot.name = f\"Foot_{i+1}\"\n    feet.append(foot)\n\n# Create control box (cube)\nbpy.ops.mesh.primitive_cube_add(size=1, location=(2, 0, 1))\nbpy.context.active_object.scale = (0.8, 1.2, 1.5)\ncontrol_box = bpy.context.active_object\ncontrol_box.name = \"ControlBox\"\n\n# Create pressure gauge (small cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=0.2, location=(1.8, 0, 1.8))\nbpy.context.active_object.rotation_euler = (0, 1.5708, 0)\npressure_gauge = bpy.context.active_object\npressure_gauge.name = \"PressureGauge\"\n\n# Select all objects for grouping\nbpy.ops.object.select_all(action='SELECT')\n\n# Create a collection for the pump\ncollection = bpy.data.collections.new(\"ABSPump\")\nbpy.context.scene.collection.children.link(collection)\n\n# Move all selected objects to the collection\nfor obj in bpy.context.selected_objects:\n    bpy.context.scene.collection.objects.unlink(obj)\n    collection.objects.link(obj)\n\n# Join all objects into one mesh\nbpy.ops.object.join()\npump_complete = bpy.context.active_object\npump_complete.name = \"ABSPump_Complete\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs purse",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create purse body (main compartment)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\npurse_body = bpy.context.active_object\npurse_body.name = \"purse_body\"\npurse_body.scale = (1.5, 0.8, 1.0)\n\n# Create purse flap (top cover)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1.2))\npurse_flap = bpy.context.active_object\npurse_flap.name = \"purse_flap\"\npurse_flap.scale = (1.6, 0.9, 0.2)\npurse_flap.rotation_euler = (0.3, 0, 0)\n\n# Create handle 1\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2, location=(-0.8, 0, 1.5))\nhandle1 = bpy.context.active_object\nhandle1.name = \"handle1\"\nhandle1.rotation_euler = (0, 1.57, 0)\nhandle1.scale = (1, 1, 0.8)\n\n# Create handle 2\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2, location=(0.8, 0, 1.5))\nhandle2 = bpy.context.active_object\nhandle2.name = \"handle2\"\nhandle2.rotation_euler = (0, 1.57, 0)\nhandle2.scale = (1, 1, 0.8)\n\n# Create handle connector 1\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.3, location=(-0.8, 0, 2.3))\nconnector1 = bpy.context.active_object\nconnector1.name = \"connector1\"\n\n# Create handle connector 2\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.3, location=(0.8, 0, 2.3))\nconnector2 = bpy.context.active_object\nconnector2.name = \"connector2\"\n\n# Create purse clasp\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.1, location=(0, -0.8, 1.3))\nclasp = bpy.context.active_object\nclasp.name = \"clasp\"\nclasp.rotation_euler = (1.57, 0, 0)\n\n# Create bottom base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, -1.1))\nbottom = bpy.context.active_object\nbottom.name = \"bottom\"\nbottom.scale = (1.4, 0.7, 0.1)\n\n# Create side accent 1\nbpy.ops.mesh.primitive_cylinder_add(radius=0.03, depth=1.8, location=(-1.4, 0, 0))\naccent1 = bpy.context.active_object\naccent1.name = \"accent1\"\n\n# Create side accent 2\nbpy.ops.mesh.primitive_cylinder_add(radius=0.03, depth=1.8, location=(1.4, 0, 0))\naccent2 = bpy.context.active_object\naccent2.name = \"accent2\"\n\n# Select all purse parts\nbpy.ops.object.select_all(action='DESELECT')\npurse_parts = [purse_body, purse_flap, handle1, handle2, connector1, connector2, clasp, bottom, accent1, accent2]\n\nfor part in purse_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = purse_body\n\n# Join all parts\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Purse\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs roof",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create roof structure\nroof_parts = []\n\n# Main roof base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nbase = bpy.context.active_object\nbase.name = \"roof_base\"\nbase.scale = (4, 6, 0.2)\nroof_parts.append(base)\n\n# Left roof slope\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-3, 0, 1))\nleft_slope = bpy.context.active_object\nleft_slope.name = \"left_slope\"\nleft_slope.scale = (1, 6, 0.1)\nleft_slope.rotation_euler = (0, 0.5, 0)\nroof_parts.append(left_slope)\n\n# Right roof slope\nbpy.ops.mesh.primitive_cube_add(size=2, location=(3, 0, 1))\nright_slope = bpy.context.active_object\nright_slope.name = \"right_slope\"\nright_slope.scale = (1, 6, 0.1)\nright_slope.rotation_euler = (0, -0.5, 0)\nroof_parts.append(right_slope)\n\n# Ridge beam\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=12, location=(0, 0, 1.8))\nridge = bpy.context.active_object\nridge.name = \"ridge_beam\"\nridge.rotation_euler = (1.5708, 0, 0)\nroof_parts.append(ridge)\n\n# Support beams\nfor i in range(-2, 3):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2, location=(0, i*2, 0.9))\n    beam = bpy.context.active_object\n    beam.name = f\"support_beam_{i}\"\n    beam.rotation_euler = (1.5708, 0, 0)\n    roof_parts.append(beam)\n\n# Roof tiles (using cylinders as tiles)\nfor x in range(-3, 4):\n    for y in range(-5, 6):\n        # Left side tiles\n        bpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=1.5, location=(x*0.8-1.5, y*0.8, 0.8))\n        tile_l = bpy.context.active_object\n        tile_l.name = f\"tile_l_{x}_{y}\"\n        tile_l.rotation_euler = (0, 0.5, 1.5708)\n        roof_parts.append(tile_l)\n        \n        # Right side tiles\n        bpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=1.5, location=(x*0.8+1.5, y*0.8, 0.8))\n        tile_r = bpy.context.active_object\n        tile_r.name = f\"tile_r_{x}_{y}\"\n        tile_r.rotation_euler = (0, -0.5, 1.5708)\n        roof_parts.append(tile_r)\n\n# Chimney\nbpy.ops.mesh.primitive_cube_add(size=2, location=(2, 3, 2))\nchimney = bpy.context.active_object\nchimney.name = \"chimney\"\nchimney.scale = (0.5, 0.5, 1.5)\nroof_parts.append(chimney)\n\n# Chimney cap\nbpy.ops.mesh.primitive_cube_add(size=2, location=(2, 3, 3.2))\ncap = bpy.context.active_object\ncap.name = \"chimney_cap\"\ncap.scale = (0.7, 0.7, 0.1)\nroof_parts.append(cap)\n\n# Select all roof parts\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in roof_parts:\n    obj.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = roof_parts[0]\n\n# Join all parts\nbpy.ops.object.join()\n\n# Export as STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "abs rug",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create rug base using scaled cube\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0))\nrug_base = bpy.context.active_object\nrug_base.name = \"Rug_Base\"\nrug_base.scale = (3, 2, 0.05)\n\n# Add fringe using cylinders around edges\nfringe_objects = []\n\n# Front fringe\nfor i in range(-6, 7, 2):\n    bpy.ops.mesh.primitive_cylinder_add(location=(i * 0.5, 2.1, 0))\n    fringe = bpy.context.active_object\n    fringe.scale = (0.05, 0.05, 0.3)\n    fringe_objects.append(fringe)\n\n# Back fringe\nfor i in range(-6, 7, 2):\n    bpy.ops.mesh.primitive_cylinder_add(location=(i * 0.5, -2.1, 0))\n    fringe = bpy.context.active_object\n    fringe.scale = (0.05, 0.05, 0.3)\n    fringe_objects.append(fringe)\n\n# Add decorative pattern using small cubes\npattern_objects = []\n\n# Central diamond pattern\nfor i in range(-2, 3):\n    for j in range(-1, 2):\n        if abs(i) + abs(j) <= 2:\n            bpy.ops.mesh.primitive_cube_add(location=(i * 0.8, j * 0.6, 0.06))\n            pattern = bpy.context.active_object\n            pattern.scale = (0.15, 0.15, 0.02)\n            pattern_objects.append(pattern)\n\n# Add border pattern using small cylinders\nborder_objects = []\n\n# Top and bottom borders\nfor i in range(-5, 6, 2):\n    bpy.ops.mesh.primitive_cylinder_add(location=(i * 0.5, 1.5, 0.06))\n    border = bpy.context.active_object\n    border.scale = (0.1, 0.1, 0.015)\n    border_objects.append(border)\n    \n    bpy.ops.mesh.primitive_cylinder_add(location=(i * 0.5, -1.5, 0.06))\n    border = bpy.context.active_object\n    border.scale = (0.1, 0.1, 0.015)\n    border_objects.append(border)\n\n# Left and right borders\nfor j in range(-2, 3, 2):\n    bpy.ops.mesh.primitive_cylinder_add(location=(2.7, j * 0.5, 0.06))\n    border = bpy.context.active_object\n    border.scale = (0.1, 0.1, 0.015)\n    border_objects.append(border)\n    \n    bpy.ops.mesh.primitive_cylinder_add(location=(-2.7, j * 0.5, 0.06))\n    border = bpy.context.active_object\n    border.scale = (0.1, 0.1, 0.015)\n    border_objects.append(border)\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Rename the joined object\nrug = bpy.context.active_object\nrug.name = \"Rug\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs screw",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create screw shaft\nbpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=4, location=(0, 0, 0))\nshaft = bpy.context.active_object\nshaft.name = \"Screw_Shaft\"\n\n# Create screw head\nbpy.ops.mesh.primitive_cylinder_add(radius=0.6, depth=0.4, location=(0, 0, 2.2))\nhead = bpy.context.active_object\nhead.name = \"Screw_Head\"\n\n# Create screw tip (cone)\nbpy.ops.mesh.primitive_cone_add(radius1=0.3, radius2=0.05, depth=0.5, location=(0, 0, -2.25))\ntip = bpy.context.active_object\ntip.name = \"Screw_Tip\"\n\n# Create slot in head (flattened cube)\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0, 2.2))\nslot = bpy.context.active_object\nslot.scale = (0.8, 0.1, 0.25)\nslot.name = \"Screw_Slot\"\n\n# Apply boolean difference to create slot\nhead_modifier = head.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nhead_modifier.operation = 'DIFFERENCE'\nhead_modifier.object = slot\n\n# Apply modifier\nbpy.context.view_layer.objects.active = head\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete the slot object\nbpy.ops.object.select_all(action='DESELECT')\nslot.select_set(True)\nbpy.ops.object.delete()\n\n# Create thread ridges using torus\nfor i in range(15):\n    z_pos = -1.8 + (i * 0.25)\n    bpy.ops.mesh.primitive_torus_add(major_radius=0.35, minor_radius=0.05, location=(0, 0, z_pos))\n    thread = bpy.context.active_object\n    thread.name = f\"Thread_{i}\"\n\n# Select all screw parts\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in bpy.context.scene.objects:\n    if obj.type == 'MESH':\n        obj.select_set(True)\n\n# Join all parts\nbpy.context.view_layer.objects.active = shaft\nbpy.ops.object.join()\n\n# Rename final object\nbpy.context.active_object.name = \"ABS_Screw\"\n\n# Export as STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "abs seat",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create seat base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.1))\nseat_base = bpy.context.active_object\nseat_base.name = \"SeatBase\"\nseat_base.scale = (2, 1.8, 0.2)\n\n# Create seat back\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -1.6, 1.2))\nseat_back = bpy.context.active_object\nseat_back.name = \"SeatBack\"\nseat_back.scale = (2, 0.2, 1.2)\nseat_back.rotation_euler = (0.2, 0, 0)\n\n# Create left armrest\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-1.8, -0.5, 0.8))\nleft_armrest = bpy.context.active_object\nleft_armrest.name = \"LeftArmrest\"\nleft_armrest.scale = (0.2, 1.2, 0.6)\n\n# Create right armrest\nbpy.ops.mesh.primitive_cube_add(size=2, location=(1.8, -0.5, 0.8))\nright_armrest = bpy.context.active_object\nright_armrest.name = \"RightArmrest\"\nright_armrest.scale = (0.2, 1.2, 0.6)\n\n# Create front left leg\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=1, location=(-1.5, 1.3, -0.5))\nfront_left_leg = bpy.context.active_object\nfront_left_leg.name = \"FrontLeftLeg\"\nfront_left_leg.scale = (1, 1, 1)\n\n# Create front right leg\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=1, location=(1.5, 1.3, -0.5))\nfront_right_leg = bpy.context.active_object\nfront_right_leg.name = \"FrontRightLeg\"\nfront_right_leg.scale = (1, 1, 1)\n\n# Create back left leg\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=1, location=(-1.5, -1.3, -0.5))\nback_left_leg = bpy.context.active_object\nback_left_leg.name = \"BackLeftLeg\"\nback_left_leg.scale = (1, 1, 1)\n\n# Create back right leg\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=1, location=(1.5, -1.3, -0.5))\nback_right_leg = bpy.context.active_object\nback_right_leg.name = \"BackRightLeg\"\nback_right_leg.scale = (1, 1, 1)\n\n# Select all seat parts\nseat_objects = [seat_base, seat_back, left_armrest, right_armrest, \n                front_left_leg, front_right_leg, back_left_leg, back_right_leg]\n\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in seat_objects:\n    obj.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = seat_base\n\n# Join all objects\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Chair\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", ascii=True, use_selection=True)\n```"
  },
  {
    "input": "abs shelf",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create shelf back panel\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 1))\nback_panel = bpy.context.active_object\nback_panel.name = \"BackPanel\"\nback_panel.scale = (2, 0.05, 1)\n\n# Create shelf bottom\nbpy.ops.mesh.primitive_cube_add(location=(0, 0.4, 0.1))\nbottom_shelf = bpy.context.active_object\nbottom_shelf.name = \"BottomShelf\"\nbottom_shelf.scale = (2, 0.4, 0.1)\n\n# Create shelf middle\nbpy.ops.mesh.primitive_cube_add(location=(0, 0.4, 1))\nmiddle_shelf = bpy.context.active_object\nmiddle_shelf.name = \"MiddleShelf\"\nmiddle_shelf.scale = (2, 0.4, 0.1)\n\n# Create shelf top\nbpy.ops.mesh.primitive_cube_add(location=(0, 0.4, 1.9))\ntop_shelf = bpy.context.active_object\ntop_shelf.name = \"TopShelf\"\ntop_shelf.scale = (2, 0.4, 0.1)\n\n# Create left side panel\nbpy.ops.mesh.primitive_cube_add(location=(-1.95, 0.2, 1))\nleft_side = bpy.context.active_object\nleft_side.name = \"LeftSide\"\nleft_side.scale = (0.05, 0.4, 1)\n\n# Create right side panel\nbpy.ops.mesh.primitive_cube_add(location=(1.95, 0.2, 1))\nright_side = bpy.context.active_object\nright_side.name = \"RightSide\"\nright_side.scale = (0.05, 0.4, 1)\n\n# Select all shelf parts\nshelf_parts = [back_panel, bottom_shelf, middle_shelf, top_shelf, left_side, right_side]\nbpy.ops.object.select_all(action='DESELECT')\nfor part in shelf_parts:\n    part.select_set(True)\n\n# Join all parts into one object\nbpy.context.view_layer.objects.active = back_panel\nbpy.ops.object.join()\n\n# Rename the joined object\nshelf = bpy.context.active_object\nshelf.name = \"Shelf\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs sofa",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create sofa parts\nsofa_parts = []\n\n# Main seat base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.3))\nseat = bpy.context.active_object\nseat.scale = (2.5, 1.2, 0.3)\nseat.name = \"seat_base\"\nsofa_parts.append(seat)\n\n# Backrest\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -1.1, 0.8))\nbackrest = bpy.context.active_object\nbackrest.scale = (2.5, 0.2, 0.8)\nbackrest.name = \"backrest\"\nsofa_parts.append(backrest)\n\n# Left armrest\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-2.3, -0.5, 0.7))\nleft_arm = bpy.context.active_object\nleft_arm.scale = (0.3, 0.8, 0.7)\nleft_arm.name = \"left_armrest\"\nsofa_parts.append(left_arm)\n\n# Right armrest\nbpy.ops.mesh.primitive_cube_add(size=2, location=(2.3, -0.5, 0.7))\nright_arm = bpy.context.active_object\nright_arm.scale = (0.3, 0.8, 0.7)\nright_arm.name = \"right_armrest\"\nsofa_parts.append(right_arm)\n\n# Left front leg\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.6, location=(-1.8, 0.8, 0))\nleft_front_leg = bpy.context.active_object\nleft_front_leg.name = \"left_front_leg\"\nsofa_parts.append(left_front_leg)\n\n# Right front leg\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.6, location=(1.8, 0.8, 0))\nright_front_leg = bpy.context.active_object\nright_front_leg.name = \"right_front_leg\"\nsofa_parts.append(right_front_leg)\n\n# Left back leg\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.6, location=(-1.8, -0.8, 0))\nleft_back_leg = bpy.context.active_object\nleft_back_leg.name = \"left_back_leg\"\nsofa_parts.append(left_back_leg)\n\n# Right back leg\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.6, location=(1.8, -0.8, 0))\nright_back_leg = bpy.context.active_object\nright_back_leg.name = \"right_back_leg\"\nsofa_parts.append(right_back_leg)\n\n# Seat cushions\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-1.2, 0.2, 0.75))\nleft_cushion = bpy.context.active_object\nleft_cushion.scale = (0.8, 0.8, 0.15)\nleft_cushion.name = \"left_cushion\"\nsofa_parts.append(left_cushion)\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(1.2, 0.2, 0.75))\nright_cushion = bpy.context.active_object\nright_cushion.scale = (0.8, 0.8, 0.15)\nright_cushion.name = \"right_cushion\"\nsofa_parts.append(right_cushion)\n\n# Back cushions\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-1.2, -0.9, 1.1))\nleft_back_cushion = bpy.context.active_object\nleft_back_cushion.scale = (0.8, 0.15, 0.4)\nleft_back_cushion.name = \"left_back_cushion\"\nsofa_parts.append(left_back_cushion)\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(1.2, -0.9, 1.1))\nright_back_cushion = bpy.context.active_object\nright_back_cushion.scale = (0.8, 0.15, 0.4)\nright_back_cushion.name = \"right_back_cushion\"\nsofa_parts.append(right_back_cushion)\n\n# Select all sofa parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in sofa_parts:\n    part.select_set(True)\n\n# Set the first object as active\nbpy.context.view_layer.objects.active = sofa_parts[0]\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Sofa\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs spoon",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create spoon bowl (scaled sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(location=(0, 0, 0), scale=(0.8, 0.6, 0.2))\nbowl = bpy.context.active_object\nbowl.name = \"SpoonBowl\"\n\n# Enter edit mode and delete bottom half of sphere\nbpy.context.view_layer.objects.active = bowl\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='DESELECT')\nbm = bmesh.from_mesh(bowl.data)\nbmesh.ops.bisect_plane(bm, geom=bm.verts[:] + bm.edges[:] + bm.faces[:], \n                       plane_co=(0, 0, 0), plane_no=(0, 0, 1), clear_inner=True)\nbmesh.to_mesh(bm, bowl.data)\nbm.free()\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Create spoon handle (scaled cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, -1.5, 0), scale=(0.15, 0.15, 1.2))\nhandle = bpy.context.active_object\nhandle.name = \"SpoonHandle\"\nhandle.rotation_euler = (1.5708, 0, 0)  # Rotate 90 degrees on X-axis\n\n# Create handle transition (scaled cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, -0.4, 0), scale=(0.2, 0.2, 0.3))\ntransition = bpy.context.active_object\ntransition.name = \"SpoonTransition\"\ntransition.rotation_euler = (1.5708, 0, 0)\n\n# Select all spoon parts\nbpy.ops.object.select_all(action='DESELECT')\nbowl.select_set(True)\nhandle.select_set(True)\ntransition.select_set(True)\n\n# Set bowl as active object for joining\nbpy.context.view_layer.objects.active = bowl\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the final object\nspoon = bpy.context.active_object\nspoon.name = \"Spoon\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_selection=True, ascii=True)\n```"
  },
  {
    "input": "abs spring",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\nfrom mathutils import Vector\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create spring coil using cylinders\nspring_parts = []\n\n# Main spring coil\nfor i in range(12):\n    angle = i * (2 * math.pi / 6)\n    x = math.cos(angle) * 0.8\n    y = math.sin(angle) * 0.8\n    z = i * 0.15\n    \n    bpy.ops.mesh.primitive_cylinder_add(\n        radius=0.08,\n        depth=0.2,\n        location=(x, y, z),\n        rotation=(0, math.pi/2, angle)\n    )\n    spring_parts.append(bpy.context.active_object)\n\n# Top and bottom caps\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.9,\n    depth=0.05,\n    location=(0, 0, 0)\n)\nspring_parts.append(bpy.context.active_object)\n\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.9,\n    depth=0.05,\n    location=(0, 0, 1.8)\n)\nspring_parts.append(bpy.context.active_object)\n\n# End coils (flat sections)\nfor i in range(3):\n    angle = i * (2 * math.pi / 3)\n    x = math.cos(angle) * 0.7\n    y = math.sin(angle) * 0.7\n    \n    bpy.ops.mesh.primitive_cylinder_add(\n        radius=0.08,\n        depth=0.15,\n        location=(x, y, 0.1),\n        rotation=(0, 0, angle)\n    )\n    spring_parts.append(bpy.context.active_object)\n    \n    bpy.ops.mesh.primitive_cylinder_add(\n        radius=0.08,\n        depth=0.15,\n        location=(x, y, 1.7),\n        rotation=(0, 0, angle)\n    )\n    spring_parts.append(bpy.context.active_object)\n\n# Select all spring parts\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in spring_parts:\n    obj.select_set(True)\n\n# Set the first object as active\nbpy.context.view_layer.objects.active = spring_parts[0]\n\n# Join all parts\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Spring\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs table",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create table top\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0.75))\ntable_top = bpy.context.active_object\ntable_top.name = \"TableTop\"\ntable_top.scale = (2, 1.5, 0.05)\n\n# Create table legs\nlegs = []\nleg_positions = [(-1.8, -1.3, 0.375), (1.8, -1.3, 0.375), (-1.8, 1.3, 0.375), (1.8, 1.3, 0.375)]\n\nfor i, pos in enumerate(leg_positions):\n    bpy.ops.mesh.primitive_cube_add(location=pos)\n    leg = bpy.context.active_object\n    leg.name = f\"TableLeg_{i+1}\"\n    leg.scale = (0.1, 0.1, 0.375)\n    legs.append(leg)\n\n# Select all table parts\nbpy.ops.object.select_all(action='DESELECT')\ntable_top.select_set(True)\nfor leg in legs:\n    leg.select_set(True)\n\n# Set table_top as active object\nbpy.context.view_layer.objects.active = table_top\n\n# Join all parts\nbpy.ops.object.join()\n\n# Create collection and add table to it\ncollection = bpy.data.collections.new(\"Table\")\nbpy.context.scene.collection.children.link(collection)\nbpy.context.scene.collection.objects.unlink(table_top)\ncollection.objects.link(table_top)\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=False,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs tire",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create tire parts\ntire_parts = []\n\n# Main tire body (torus-like using scaled cylinder)\nbpy.ops.mesh.primitive_cylinder_add(vertices=32, radius=2.0, depth=1.0, location=(0, 0, 0))\ntire_body = bpy.context.active_object\ntire_body.name = \"tire_body\"\ntire_parts.append(tire_body)\n\n# Inner hole (cylinder to subtract)\nbpy.ops.mesh.primitive_cylinder_add(vertices=32, radius=1.2, depth=1.2, location=(0, 0, 0))\ninner_hole = bpy.context.active_object\ninner_hole.name = \"inner_hole\"\n\n# Boolean modifier to create hole\nmodifier = tire_body.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nmodifier.operation = 'DIFFERENCE'\nmodifier.object = inner_hole\nbpy.context.view_layer.objects.active = tire_body\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete inner hole object\nbpy.data.objects.remove(inner_hole, do_unlink=True)\n\n# Rim (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(vertices=16, radius=1.1, depth=0.8, location=(0, 0, 0))\nrim = bpy.context.active_object\nrim.name = \"rim\"\ntire_parts.append(rim)\n\n# Rim center (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(vertices=12, radius=0.3, depth=0.9, location=(0, 0, 0))\nrim_center = bpy.context.active_object\nrim_center.name = \"rim_center\"\ntire_parts.append(rim_center)\n\n# Tire tread pattern (small cylinders around tire)\nfor i in range(16):\n    angle = i * 6.28318 / 16\n    x = 1.8 * bpy.mathutils.Matrix.Rotation(angle, 4, 'Z')[0][0]\n    y = 1.8 * bpy.mathutils.Matrix.Rotation(angle, 4, 'Z')[0][1]\n    \n    bpy.ops.mesh.primitive_cylinder_add(vertices=8, radius=0.08, depth=0.2, location=(x, y, 0))\n    tread = bpy.context.active_object\n    tread.name = f\"tread_{i}\"\n    \n    # Boolean subtract from tire body\n    modifier = tire_body.modifiers.new(name=f\"Tread_{i}\", type='BOOLEAN')\n    modifier.operation = 'DIFFERENCE'\n    modifier.object = tread\n    \n    bpy.data.objects.remove(tread, do_unlink=True)\n\n# Apply all boolean modifiers\nbpy.context.view_layer.objects.active = tire_body\nfor modifier in tire_body.modifiers:\n    bpy.ops.object.modifier_apply(modifier=modifier.name)\n\n# Rim spokes (cubes)\nfor i in range(5):\n    angle = i * 6.28318 / 5\n    x = 0.6 * bpy.mathutils.Matrix.Rotation(angle, 4, 'Z')[0][0]\n    y = 0.6 * bpy.mathutils.Matrix.Rotation(angle, 4, 'Z')[0][1]\n    \n    bpy.ops.mesh.primitive_cube_add(size=0.8, location=(x, y, 0))\n    spoke = bpy.context.active_object\n    spoke.name = f\"spoke_{i}\"\n    spoke.scale = (0.1, 0.8, 0.2)\n    spoke.rotation_euler[2] = angle\n    bpy.ops.object.transform_apply(location=False, rotation=True, scale=True)\n    tire_parts.append(spoke)\n\n# Select all tire parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in tire_parts:\n    part.select_set(True)\n\n# Join all parts\nbpy.context.view_layer.objects.active = tire_parts[0]\nbpy.ops.object.join()\n\n# Rename final object\ntire = bpy.context.active_object\ntire.name = \"tire\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs towel",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create towel parts\ntowel_parts = []\n\n# Main towel body (flattened cube)\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0))\ntowel_body = bpy.context.active_object\ntowel_body.name = \"TowelBody\"\ntowel_body.scale = (3, 2, 0.1)\ntowel_parts.append(towel_body)\n\n# Towel corner details (small cylinders for texture)\nfor i in range(4):\n    for j in range(6):\n        x_pos = -2.5 + i * 1.7\n        y_pos = -1.5 + j * 0.6\n        bpy.ops.mesh.primitive_cylinder_add(location=(x_pos, y_pos, 0.05))\n        corner_detail = bpy.context.active_object\n        corner_detail.name = f\"TowelDetail_{i}_{j}\"\n        corner_detail.scale = (0.05, 0.05, 0.02)\n        towel_parts.append(corner_detail)\n\n# Towel edges (thin cylinders)\n# Top and bottom edges\nfor i in range(2):\n    y_pos = -2 + i * 4\n    bpy.ops.mesh.primitive_cylinder_add(location=(0, y_pos, 0.08))\n    edge = bpy.context.active_object\n    edge.name = f\"TowelEdge_H_{i}\"\n    edge.scale = (3, 0.1, 0.05)\n    edge.rotation_euler = (1.5708, 0, 0)\n    towel_parts.append(edge)\n\n# Left and right edges\nfor i in range(2):\n    x_pos = -3 + i * 6\n    bpy.ops.mesh.primitive_cylinder_add(location=(x_pos, 0, 0.08))\n    edge = bpy.context.active_object\n    edge.name = f\"TowelEdge_V_{i}\"\n    edge.scale = (2, 0.1, 0.05)\n    edge.rotation_euler = (0, 1.5708, 0)\n    towel_parts.append(edge)\n\n# Towel hanging loop (torus)\nbpy.ops.mesh.primitive_torus_add(location=(0, 2.2, 0.2))\nhanging_loop = bpy.context.active_object\nhanging_loop.name = \"HangingLoop\"\nhanging_loop.scale = (0.3, 0.3, 0.1)\ntowel_parts.append(hanging_loop)\n\n# Select all towel parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in towel_parts:\n    part.select_set(True)\n\n# Set the main body as active object\nbpy.context.view_layer.objects.active = towel_body\n\n# Join all parts\nbpy.ops.object.join()\n\n# Create collection and add towel\ncollection = bpy.data.collections.new(\"Towel\")\nbpy.context.scene.collection.children.link(collection)\ncollection.objects.link(towel_body)\nbpy.context.scene.collection.objects.unlink(towel_body)\n\n# Export as ASCII STL\noutput_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=output_path,\n    use_selection=False,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs valve",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create valve body (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=3, location=(0, 0, 0))\nvalve_body = bpy.context.active_object\nvalve_body.name = \"valve_body\"\n\n# Create inlet pipe\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=4, location=(-3, 0, 0))\nbpy.context.active_object.rotation_euler = (0, 1.5708, 0)\ninlet_pipe = bpy.context.active_object\ninlet_pipe.name = \"inlet_pipe\"\n\n# Create outlet pipe\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=4, location=(3, 0, 0))\nbpy.context.active_object.rotation_euler = (0, 1.5708, 0)\noutlet_pipe = bpy.context.active_object\noutlet_pipe.name = \"outlet_pipe\"\n\n# Create valve disc (sphere flattened)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.2, location=(0, 0, 0))\nbpy.context.active_object.scale = (1, 1, 0.3)\nvalve_disc = bpy.context.active_object\nvalve_disc.name = \"valve_disc\"\n\n# Create valve stem (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=2.5, location=(0, 0, 2.5))\nvalve_stem = bpy.context.active_object\nvalve_stem.name = \"valve_stem\"\n\n# Create actuator housing (cube)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 4))\nactuator_housing = bpy.context.active_object\nactuator_housing.name = \"actuator_housing\"\n\n# Create connection flanges\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=0.3, location=(-1.8, 0, 0))\nbpy.context.active_object.rotation_euler = (0, 1.5708, 0)\nflange1 = bpy.context.active_object\nflange1.name = \"flange1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=0.3, location=(1.8, 0, 0))\nbpy.context.active_object.rotation_euler = (0, 1.5708, 0)\nflange2 = bpy.context.active_object\nflange2.name = \"flange2\"\n\n# Create mounting bolts\nfor i, pos in enumerate([(-1.8, 0.8, 0.8), (-1.8, -0.8, 0.8), (-1.8, 0.8, -0.8), (-1.8, -0.8, -0.8)]):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.6, location=pos)\n    bpy.context.active_object.rotation_euler = (0, 1.5708, 0)\n    bpy.context.active_object.name = f\"bolt1_{i}\"\n\nfor i, pos in enumerate([(1.8, 0.8, 0.8), (1.8, -0.8, 0.8), (1.8, 0.8, -0.8), (1.8, -0.8, -0.8)]):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.6, location=pos)\n    bpy.context.active_object.rotation_euler = (0, 1.5708, 0)\n    bpy.context.active_object.name = f\"bolt2_{i}\"\n\n# Select all valve parts\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects\nbpy.ops.object.join()\nvalve_assembly = bpy.context.active_object\nvalve_assembly.name = \"abs_valve\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs vase",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create vase base (flattened sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(location=(0, 0, 0.5))\nbase = bpy.context.active_object\nbase.name = \"VaseBase\"\nbase.scale = (1.2, 1.2, 0.3)\n\n# Create vase body (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, 2))\nbody = bpy.context.active_object\nbody.name = \"VaseBody\"\nbody.scale = (1, 1, 1.5)\n\n# Create vase neck (smaller cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, 4.2))\nneck = bpy.context.active_object\nneck.name = \"VaseNeck\"\nneck.scale = (0.6, 0.6, 0.7)\n\n# Create vase rim (torus for lip)\nbpy.ops.mesh.primitive_torus_add(location=(0, 0, 4.9))\nrim = bpy.context.active_object\nrim.name = \"VaseRim\"\nrim.scale = (0.6, 0.6, 0.2)\n\n# Select all vase parts\nbpy.ops.object.select_all(action='DESELECT')\nbase.select_set(True)\nbody.select_set(True)\nneck.select_set(True)\nrim.select_set(True)\n\n# Set the base as active object\nbpy.context.view_layer.objects.active = base\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the joined object\nvase = bpy.context.active_object\nvase.name = \"Vase\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs wall",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create abs wall components\n# Base wall structure\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 1))\nbase_wall = bpy.context.active_object\nbase_wall.name = \"base_wall\"\nbase_wall.scale = (3, 0.2, 2)\n\n# Horizontal ab divisions\nfor i in range(3):\n    y_pos = -0.3 + (i * 0.3)\n    bpy.ops.mesh.primitive_cube_add(location=(0, y_pos, 0.5 + i * 0.6))\n    ab_section = bpy.context.active_object\n    ab_section.name = f\"ab_section_{i}\"\n    ab_section.scale = (2.5, 0.25, 0.25)\n\n# Vertical center line\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 1))\ncenter_line = bpy.context.active_object\ncenter_line.name = \"center_line\"\ncenter_line.scale = (0.1, 0.3, 1.8)\n\n# Individual ab muscles (left side)\nab_positions = [\n    (-0.8, 0, 1.4), (-0.8, 0, 0.8), (-0.8, 0, 0.2),\n    (-1.2, 0, 1.4), (-1.2, 0, 0.8), (-1.2, 0, 0.2)\n]\n\nfor i, pos in enumerate(ab_positions):\n    bpy.ops.mesh.primitive_uv_sphere_add(location=pos)\n    ab_muscle = bpy.context.active_object\n    ab_muscle.name = f\"ab_muscle_left_{i}\"\n    ab_muscle.scale = (0.35, 0.15, 0.25)\n\n# Individual ab muscles (right side)\nfor i, pos in enumerate(ab_positions):\n    right_pos = (-pos[0], pos[1], pos[2])\n    bpy.ops.mesh.primitive_uv_sphere_add(location=right_pos)\n    ab_muscle = bpy.context.active_object\n    ab_muscle.name = f\"ab_muscle_right_{i}\"\n    ab_muscle.scale = (0.35, 0.15, 0.25)\n\n# Oblique muscles\nbpy.ops.mesh.primitive_cylinder_add(location=(-1.8, 0, 1))\nleft_oblique = bpy.context.active_object\nleft_oblique.name = \"left_oblique\"\nleft_oblique.scale = (0.3, 0.15, 1.5)\nleft_oblique.rotation_euler = (0, 0.3, 0)\n\nbpy.ops.mesh.primitive_cylinder_add(location=(1.8, 0, 1))\nright_oblique = bpy.context.active_object\nright_oblique.name = \"right_oblique\"\nright_oblique.scale = (0.3, 0.15, 1.5)\nright_oblique.rotation_euler = (0, -0.3, 0)\n\n# Apply transformations\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Group all objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.join()\nabs_wall = bpy.context.active_object\nabs_wall.name = \"abs_wall\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs wallet",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Clear existing collections\nfor collection in bpy.data.collections:\n    bpy.data.collections.remove(collection)\n\n# Create wallet body (main rectangular shape)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nwallet_body = bpy.context.active_object\nwallet_body.name = \"WalletBody\"\nwallet_body.scale = (2.0, 1.2, 0.1)\n\n# Create wallet fold/crease (thin rectangle)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.12))\nwallet_fold = bpy.context.active_object\nwallet_fold.name = \"WalletFold\"\nwallet_fold.scale = (2.0, 1.2, 0.02)\n\n# Create card slots (multiple thin rectangles)\ncard_slot_positions = [\n    (0.8, 0, 0.25),\n    (0.4, 0, 0.28),\n    (0, 0, 0.31),\n    (-0.4, 0, 0.34),\n    (-0.8, 0, 0.37)\n]\n\nfor i, pos in enumerate(card_slot_positions):\n    bpy.ops.mesh.primitive_cube_add(size=2, location=pos)\n    card_slot = bpy.context.active_object\n    card_slot.name = f\"CardSlot_{i+1}\"\n    card_slot.scale = (1.6, 1.0, 0.01)\n\n# Create wallet clasp/button (small cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.05, location=(1.8, 0, 0.15))\nwallet_clasp = bpy.context.active_object\nwallet_clasp.name = \"WalletClasp\"\n\n# Create wallet corner reinforcements (small cubes at corners)\ncorner_positions = [\n    (1.8, 1.0, 0.08),\n    (1.8, -1.0, 0.08),\n    (-1.8, 1.0, 0.08),\n    (-1.8, -1.0, 0.08)\n]\n\nfor i, pos in enumerate(corner_positions):\n    bpy.ops.mesh.primitive_cube_add(size=0.2, location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"Corner_{i+1}\"\n    corner.scale = (0.8, 0.8, 1.5)\n\n# Create wallet edges (thin cylinders for rounded edges)\nedge_positions = [\n    (0, 1.2, 0.05),\n    (0, -1.2, 0.05),\n    (2.0, 0, 0.05),\n    (-2.0, 0, 0.05)\n]\n\nedge_rotations = [\n    (0, 1.5708, 0),  # 90 degrees Y\n    (0, 1.5708, 0),  # 90 degrees Y\n    (1.5708, 0, 0),  # 90 degrees X\n    (1.5708, 0, 0)   # 90 degrees X\n]\n\nfor i, (pos, rot) in enumerate(zip(edge_positions, edge_rotations)):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=4.0, location=pos, rotation=rot)\n    edge = bpy.context.active_object\n    edge.name = f\"Edge_{i+1}\"\n    if i < 2:\n        edge.scale = (1, 1, 0.5)\n    else:\n        edge.scale = (1, 1, 0.3)\n\n# Create new collection for wallet\nwallet_collection = bpy.data.collections.new(\"Wallet\")\nbpy.context.scene.collection.children.link(wallet_collection)\n\n# Add all objects to the wallet collection\nfor obj in bpy.context.scene.objects:\n    if obj.type == 'MESH':\n        bpy.context.scene.collection.objects.unlink(obj)\n        wallet_collection.objects.link(obj)\n\n# Select all wallet objects\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in wallet_collection.objects:\n    obj.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = wallet_body\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Export as ASCII STL\noutput_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=output_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs wheel",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create main wheel (tire)\nbpy.ops.mesh.primitive_torus_add(\n    major_radius=2.0,\n    minor_radius=0.4,\n    location=(0, 0, 0)\n)\ntire = bpy.context.active_object\ntire.name = \"Tire\"\ntire.scale = (1, 1, 0.8)\n\n# Create wheel rim (outer cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.6,\n    depth=0.3,\n    location=(0, 0, 0)\n)\nrim_outer = bpy.context.active_object\nrim_outer.name = \"RimOuter\"\n\n# Create wheel rim inner depression\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.4,\n    depth=0.25,\n    location=(0, 0, 0)\n)\nrim_inner = bpy.context.active_object\nrim_inner.name = \"RimInner\"\n\n# Create center hub\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.6,\n    depth=0.4,\n    location=(0, 0, 0)\n)\nhub = bpy.context.active_object\nhub.name = \"Hub\"\n\n# Create wheel spokes\nspokes = []\nfor i in range(5):\n    angle = i * 1.256637  # 72 degrees in radians\n    x = 1.0 * cos(angle) if 'cos' in dir(__builtins__) else 1.0 * (1 if i == 0 else -0.309 if i == 1 else -0.809 if i == 2 else -0.809 if i == 3 else -0.309)\n    y = 1.0 * sin(angle) if 'sin' in dir(__builtins__) else 1.0 * (0 if i == 0 else 0.951 if i == 1 else 0.588 if i == 2 else -0.588 if i == 3 else -0.951)\n    \n    bpy.ops.mesh.primitive_cube_add(\n        size=0.8,\n        location=(x * 0.8, y * 0.8, 0)\n    )\n    spoke = bpy.context.active_object\n    spoke.name = f\"Spoke_{i}\"\n    spoke.scale = (0.15, 0.15, 0.3)\n    spoke.rotation_euler = (0, 0, angle)\n    spokes.append(spoke)\n\n# Create lug nuts\nlug_nuts = []\nfor i in range(5):\n    angle = i * 1.256637\n    x = 0.8 * (1 if i == 0 else -0.309 if i == 1 else -0.809 if i == 2 else -0.809 if i == 3 else -0.309)\n    y = 0.8 * (0 if i == 0 else 0.951 if i == 1 else 0.588 if i == 2 else -0.588 if i == 3 else -0.951)\n    \n    bpy.ops.mesh.primitive_cylinder_add(\n        radius=0.08,\n        depth=0.1,\n        location=(x * 0.5, y * 0.5, 0.2)\n    )\n    lug_nut = bpy.context.active_object\n    lug_nut.name = f\"LugNut_{i}\"\n    lug_nuts.append(lug_nut)\n\n# Create valve stem\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.03,\n    depth=0.2,\n    location=(1.8, 0, 0)\n)\nvalve_stem = bpy.context.active_object\nvalve_stem.name = \"ValveStem\"\n\n# Select all wheel parts\nall_parts = [tire, rim_outer, rim_inner, hub, valve_stem] + spokes + lug_nuts\n\nbpy.ops.object.select_all(action='DESELECT')\nfor part in all_parts:\n    part.select_set(True)\nbpy.context.view_layer.objects.active = tire\n\n# Join all parts\nbpy.ops.object.join()\nwheel = bpy.context.active_object\nwheel.name = \"ABSWheel\"\n\n# Export as ASCII STL\noutput_path = os.path.join(os.path.dirname(bpy.data.filepath) if bpy.data.filepath else \"/tmp\", \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=output_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs window",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create window frame (outer rectangle)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nframe_outer = bpy.context.active_object\nframe_outer.name = \"WindowFrameOuter\"\nframe_outer.scale = (2, 0.1, 1.5)\n\n# Create window frame inner cut (to make it hollow)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nframe_inner = bpy.context.active_object\nframe_inner.name = \"WindowFrameInner\"\nframe_inner.scale = (1.8, 0.15, 1.3)\n\n# Boolean difference to create hollow frame\nbool_modifier = frame_outer.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nbool_modifier.operation = 'DIFFERENCE'\nbool_modifier.object = frame_inner\nbpy.context.view_layer.objects.active = frame_outer\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete the inner frame object\nbpy.ops.object.select_all(action='DESELECT')\nframe_inner.select_set(True)\nbpy.ops.object.delete()\n\n# Create window sill (bottom ledge)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -0.15, -1.6))\nsill = bpy.context.active_object\nsill.name = \"WindowSill\"\nsill.scale = (2.2, 0.2, 0.1)\n\n# Create vertical window divider\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ndivider_vertical = bpy.context.active_object\ndivider_vertical.name = \"VerticalDivider\"\ndivider_vertical.scale = (0.05, 0.08, 1.3)\n\n# Create horizontal window divider\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ndivider_horizontal = bpy.context.active_object\ndivider_horizontal.name = \"HorizontalDivider\"\ndivider_horizontal.scale = (1.8, 0.08, 0.05)\n\n# Create glass panes (4 panes)\n# Top left pane\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-0.9, -0.02, 0.65))\nglass_tl = bpy.context.active_object\nglass_tl.name = \"GlassTopLeft\"\nglass_tl.scale = (0.85, 0.01, 0.6)\n\n# Top right pane\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0.9, -0.02, 0.65))\nglass_tr = bpy.context.active_object\nglass_tr.name = \"GlassTopRight\"\nglass_tr.scale = (0.85, 0.01, 0.6)\n\n# Bottom left pane\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-0.9, -0.02, -0.65))\nglass_bl = bpy.context.active_object\nglass_bl.name = \"GlassBottomLeft\"\nglass_bl.scale = (0.85, 0.01, 0.6)\n\n# Bottom right pane\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0.9, -0.02, -0.65))\nglass_br = bpy.context.active_object\nglass_br.name = \"GlassBottomRight\"\nglass_br.scale = (0.85, 0.01, 0.6)\n\n# Create window handles (cylinders)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.1, location=(1.5, -0.25, 0))\nhandle_right = bpy.context.active_object\nhandle_right.name = \"HandleRight\"\nhandle_right.rotation_euler = (1.5708, 0, 0)\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.1, location=(-1.5, -0.25, 0))\nhandle_left = bpy.context.active_object\nhandle_left.name = \"HandleLeft\"\nhandle_left.rotation_euler = (1.5708, 0, 0)\n\n# Select all objects to group them\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"Window\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\"),\n    ascii=True,\n    use_selection=True\n)\n```"
  },
  {
    "input": "abs wire",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create wire components\ncomponents = []\n\n# Main wire body - cylinder\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=10, location=(0, 0, 0))\nwire_body = bpy.context.active_object\nwire_body.name = \"wire_body\"\nwire_body.rotation_euler = (1.5708, 0, 0)  # Rotate 90 degrees on X-axis\ncomponents.append(wire_body)\n\n# Wire insulation segments - cylinders with slight variations\nfor i in range(5):\n    z_pos = -4 + i * 2\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.06, depth=1.8, location=(0, 0, z_pos))\n    insulation = bpy.context.active_object\n    insulation.name = f\"insulation_{i}\"\n    insulation.rotation_euler = (1.5708, 0, 0)\n    components.append(insulation)\n\n# Wire connectors at ends - smaller cylinders\nbpy.ops.mesh.primitive_cylinder_add(radius=0.03, depth=0.5, location=(0, 0, -5.25))\nconnector1 = bpy.context.active_object\nconnector1.name = \"connector_1\"\nconnector1.rotation_euler = (1.5708, 0, 0)\ncomponents.append(connector1)\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.03, depth=0.5, location=(0, 0, 4.75))\nconnector2 = bpy.context.active_object\nconnector2.name = \"connector_2\"\nconnector2.rotation_euler = (1.5708, 0, 0)\ncomponents.append(connector2)\n\n# End caps - spheres\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.04, location=(0, 0, -5.5))\ncap1 = bpy.context.active_object\ncap1.name = \"end_cap_1\"\ncomponents.append(cap1)\n\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.04, location=(0, 0, 5))\ncap2 = bpy.context.active_object\ncap2.name = \"end_cap_2\"\ncomponents.append(cap2)\n\n# Wire strain relief - cones\nbpy.ops.mesh.primitive_cone_add(radius1=0.06, radius2=0.03, depth=0.3, location=(0, 0, -4.9))\nstrain1 = bpy.context.active_object\nstrain1.name = \"strain_relief_1\"\nstrain1.rotation_euler = (1.5708, 0, 0)\ncomponents.append(strain1)\n\nbpy.ops.mesh.primitive_cone_add(radius1=0.06, radius2=0.03, depth=0.3, location=(0, 0, 4.6))\nstrain2 = bpy.context.active_object\nstrain2.name = \"strain_relief_2\"\nstrain2.rotation_euler = (-1.5708, 0, 0)\ncomponents.append(strain2)\n\n# Select all components\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in components:\n    obj.select_set(True)\n\n# Set the first object as active\nbpy.context.view_layer.objects.active = components[0]\n\n# Join all objects\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"abs_wire\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "accent chair",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create seat (cube)\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 1))\nseat = bpy.context.active_object\nseat.name = \"Seat\"\nseat.scale = (1.2, 1.0, 0.15)\n\n# Create backrest (cube)\nbpy.ops.mesh.primitive_cube_add(location=(0, -0.9, 1.8))\nbackrest = bpy.context.active_object\nbackrest.name = \"Backrest\"\nbackrest.scale = (1.2, 0.15, 0.8)\n\n# Create armrest left (cube)\nbpy.ops.mesh.primitive_cube_add(location=(-1.1, -0.3, 1.4))\narmrest_left = bpy.context.active_object\narmrest_left.name = \"Armrest_Left\"\narmrest_left.scale = (0.15, 0.6, 0.4)\n\n# Create armrest right (cube)\nbpy.ops.mesh.primitive_cube_add(location=(1.1, -0.3, 1.4))\narmrest_right = bpy.context.active_object\narmrest_right.name = \"Armrest_Right\"\narmrest_right.scale = (0.15, 0.6, 0.4)\n\n# Create front left leg (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(-0.8, 0.6, 0.4))\nleg_fl = bpy.context.active_object\nleg_fl.name = \"Leg_Front_Left\"\nleg_fl.scale = (0.08, 0.08, 0.4)\n\n# Create front right leg (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0.8, 0.6, 0.4))\nleg_fr = bpy.context.active_object\nleg_fr.name = \"Leg_Front_Right\"\nleg_fr.scale = (0.08, 0.08, 0.4)\n\n# Create back left leg (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(-0.8, -0.6, 0.4))\nleg_bl = bpy.context.active_object\nleg_bl.name = \"Leg_Back_Left\"\nleg_bl.scale = (0.08, 0.08, 0.4)\n\n# Create back right leg (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0.8, -0.6, 0.4))\nleg_br = bpy.context.active_object\nleg_br.name = \"Leg_Back_Right\"\nleg_br.scale = (0.08, 0.08, 0.4)\n\n# Select all chair parts\nchair_parts = [seat, backrest, armrest_left, armrest_right, leg_fl, leg_fr, leg_bl, leg_br]\nbpy.ops.object.select_all(action='DESELECT')\nfor part in chair_parts:\n    part.select_set(True)\n\n# Set active object and join all parts\nbpy.context.view_layer.objects.active = seat\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Accent_Chair\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "accordion",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create accordion body (main bellows section)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nbody = bpy.context.active_object\nbody.name = \"accordion_body\"\nbody.scale = (2, 1.5, 0.8)\n\n# Create left keyboard section\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-2.5, 0, 0))\nleft_keyboard = bpy.context.active_object\nleft_keyboard.name = \"left_keyboard\"\nleft_keyboard.scale = (0.4, 1.5, 0.8)\n\n# Create right keyboard section\nbpy.ops.mesh.primitive_cube_add(size=2, location=(2.5, 0, 0))\nright_keyboard = bpy.context.active_object\nright_keyboard.name = \"right_keyboard\"\nright_keyboard.scale = (0.4, 1.5, 0.8)\n\n# Create bellows segments\nbellows_parts = []\nfor i in range(7):\n    x_pos = -1.4 + (i * 0.47)\n    bpy.ops.mesh.primitive_cube_add(size=2, location=(x_pos, 0, 0))\n    bellows = bpy.context.active_object\n    bellows.name = f\"bellows_{i}\"\n    bellows.scale = (0.05, 1.6, 0.9)\n    bellows_parts.append(bellows)\n\n# Create keys on left keyboard\nleft_keys = []\nfor i in range(12):\n    y_pos = -1.2 + (i * 0.2)\n    bpy.ops.mesh.primitive_cube_add(size=2, location=(-2.7, y_pos, 0.4))\n    key = bpy.context.active_object\n    key.name = f\"left_key_{i}\"\n    key.scale = (0.15, 0.08, 0.2)\n    left_keys.append(key)\n\n# Create keys on right keyboard\nright_keys = []\nfor i in range(8):\n    for j in range(4):\n        y_pos = -0.6 + (i * 0.15)\n        z_pos = -0.3 + (j * 0.2)\n        bpy.ops.mesh.primitive_cube_add(size=2, location=(2.7, y_pos, z_pos))\n        key = bpy.context.active_object\n        key.name = f\"right_key_{i}_{j}\"\n        key.scale = (0.15, 0.06, 0.08)\n        right_keys.append(key)\n\n# Create straps\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(-2.5, 0, -1.2))\nleft_strap = bpy.context.active_object\nleft_strap.name = \"left_strap\"\nleft_strap.scale = (0.05, 0.05, 0.4)\nleft_strap.rotation_euler = (1.5708, 0, 0)\n\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(2.5, 0, -1.2))\nright_strap = bpy.context.active_object\nright_strap.name = \"right_strap\"\nright_strap.scale = (0.05, 0.05, 0.4)\nright_strap.rotation_euler = (1.5708, 0, 0)\n\n# Create corner reinforcements\ncorners = []\ncorner_positions = [(-2.1, 1.3, 0.6), (-2.1, -1.3, 0.6), (2.1, 1.3, 0.6), (2.1, -1.3, 0.6)]\nfor i, pos in enumerate(corner_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"corner_{i}\"\n    corner.scale = (0.08, 0.08, 0.15)\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects\nbpy.ops.object.join()\naccordion = bpy.context.active_object\naccordion.name = \"accordion\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acoustic guitar",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Guitar body (main hollow body)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1, location=(0, 0, 0))\nguitar_body = bpy.context.active_object\nguitar_body.name = \"guitar_body\"\nguitar_body.scale = (1.2, 0.8, 0.15)\n\n# Guitar neck\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 1.8, 0))\nguitar_neck = bpy.context.active_object\nguitar_neck.name = \"guitar_neck\"\nguitar_neck.scale = (0.15, 1.2, 0.05)\n\n# Guitar headstock\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 3.2, 0))\nguitar_headstock = bpy.context.active_object\nguitar_headstock.name = \"guitar_headstock\"\nguitar_headstock.scale = (0.2, 0.3, 0.08)\n\n# Guitar bridge\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -0.3, 0.16))\nguitar_bridge = bpy.context.active_object\nguitar_bridge.name = \"guitar_bridge\"\nguitar_bridge.scale = (0.3, 0.05, 0.02)\n\n# Sound hole\nbpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=0.4, location=(0, 0.2, 0))\nsound_hole = bpy.context.active_object\nsound_hole.name = \"sound_hole\"\n\n# Tuning pegs (6 pegs)\ntuning_pegs = []\nfor i in range(6):\n    x_pos = -0.125 + (i * 0.05)\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.02, depth=0.1, location=(x_pos, 3.2, 0.08))\n    peg = bpy.context.active_object\n    peg.name = f\"tuning_peg_{i+1}\"\n    tuning_pegs.append(peg)\n\n# Frets (12 frets along neck)\nfrets = []\nfor i in range(12):\n    y_pos = 1.2 + (i * 0.1)\n    bpy.ops.mesh.primitive_cube_add(size=2, location=(0, y_pos, 0.05))\n    fret = bpy.context.active_object\n    fret.name = f\"fret_{i+1}\"\n    fret.scale = (0.15, 0.005, 0.01)\n    frets.append(fret)\n\n# Strings (6 strings)\nstrings = []\nfor i in range(6):\n    x_pos = -0.075 + (i * 0.03)\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.001, depth=4.8, location=(x_pos, 1.6, 0.05))\n    string = bpy.context.active_object\n    string.name = f\"string_{i+1}\"\n    string.rotation_euler = (1.5708, 0, 0)  # 90 degrees in radians\n    strings.append(string)\n\n# Nut (at top of neck)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0.6, 0.05))\nnut = bpy.context.active_object\nnut.name = \"nut\"\nnut.scale = (0.15, 0.01, 0.01)\n\n# Select all guitar parts\nguitar_parts = [guitar_body, guitar_neck, guitar_headstock, guitar_bridge, sound_hole, nut] + tuning_pegs + frets + strings\n\nbpy.ops.object.select_all(action='DESELECT')\nfor part in guitar_parts:\n    part.select_set(True)\n\n# Make guitar_body the active object\nbpy.context.view_layer.objects.active = guitar_body\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"acoustic_guitar\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic bag",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create main bag body (cube scaled and modified)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1))\nbag_body = bpy.context.active_object\nbag_body.name = \"bag_body\"\nbag_body.scale = (1.5, 0.8, 1.2)\n\n# Create bag bottom (cube flattened)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.1))\nbag_bottom = bpy.context.active_object\nbag_bottom.name = \"bag_bottom\"\nbag_bottom.scale = (1.5, 0.8, 0.1)\n\n# Create bag handles (cylinders)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2, location=(-1.2, 0, 2.5))\nhandle1 = bpy.context.active_object\nhandle1.name = \"handle1\"\nhandle1.rotation_euler = (0, 1.57, 0)\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2, location=(1.2, 0, 2.5))\nhandle2 = bpy.context.active_object\nhandle2.name = \"handle2\"\nhandle2.rotation_euler = (0, 1.57, 0)\n\n# Create handle connectors (small cylinders)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.3, location=(-1.2, 0, 2.0))\nconnector1 = bpy.context.active_object\nconnector1.name = \"connector1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.3, location=(1.2, 0, 2.0))\nconnector2 = bpy.context.active_object\nconnector2.name = \"connector2\"\n\n# Create bag closure/zipper area (flattened cube)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 2.3))\nclosure = bpy.context.active_object\nclosure.name = \"closure\"\nclosure.scale = (1.4, 0.7, 0.05)\n\n# Create corner reinforcements (small spheres)\ncorners = [\n    (-1.3, -0.6, 0.2),\n    (1.3, -0.6, 0.2),\n    (-1.3, 0.6, 0.2),\n    (1.3, 0.6, 0.2)\n]\n\ncorner_objects = []\nfor i, pos in enumerate(corners):\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.1, location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"corner_{i}\"\n    corner_objects.append(corner)\n\n# Select all objects for grouping\nall_objects = [bag_body, bag_bottom, handle1, handle2, connector1, connector2, closure] + corner_objects\n\n# Deselect all first\nbpy.ops.object.select_all(action='DESELECT')\n\n# Select all bag parts\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = bag_body\n\n# Join all objects\nbpy.ops.object.join()\n\n# Export as ASCII STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic basket",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create basket base\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=0.2, location=(0, 0, 0))\nbase = bpy.context.active_object\nbase.name = \"basket_base\"\n\n# Create basket walls using multiple cylinders\nwall_height = 1.5\nnum_rings = 8\nfor i in range(num_rings):\n    z_pos = 0.1 + (i * wall_height / num_rings)\n    radius = 2 + (i * 0.05)\n    \n    bpy.ops.mesh.primitive_torus_add(\n        major_radius=radius,\n        minor_radius=0.08,\n        location=(0, 0, z_pos)\n    )\n    ring = bpy.context.active_object\n    ring.name = f\"basket_ring_{i}\"\n\n# Create vertical supports\nnum_supports = 12\nfor i in range(num_supports):\n    angle = (i / num_supports) * 6.28318\n    x_pos = 2.2 * mathutils.Vector((1, 0, 0)).x * bpy.mathutils.Matrix.Rotation(angle, 3, 'Z')[0][0]\n    y_pos = 2.2 * mathutils.Vector((1, 0, 0)).y * bpy.mathutils.Matrix.Rotation(angle, 3, 'Z')[1][0]\n    \n    x_pos = 2.2 * (1 if i == 0 else (-1 if i == num_supports//2 else (2.2 * ((i/num_supports * 2) - 1) if i < num_supports//2 else (2.2 * (1 - ((i-num_supports//2)/(num_supports//2) * 2))))))\n    y_pos = 2.2 * (0 if i == 0 or i == num_supports//2 else (2.2 * (1 - abs((i - num_supports//4) / (num_supports//4))) if abs(i - num_supports//4) <= num_supports//4 else -2.2 * (1 - abs((i - 3*num_supports//4) / (num_supports//4)))))\n    \n    import math\n    x_pos = 2.2 * math.cos(angle)\n    y_pos = 2.2 * math.sin(angle)\n    \n    bpy.ops.mesh.primitive_cylinder_add(\n        radius=0.05,\n        depth=wall_height,\n        location=(x_pos, y_pos, wall_height/2 + 0.1)\n    )\n    support = bpy.context.active_object\n    support.name = f\"basket_support_{i}\"\n\n# Create basket handles\nbpy.ops.mesh.primitive_torus_add(\n    major_radius=0.8,\n    minor_radius=0.12,\n    location=(2.5, 0, wall_height/2 + 0.1)\n)\nhandle1 = bpy.context.active_object\nhandle1.name = \"basket_handle_1\"\nhandle1.rotation_euler = (0, 1.5708, 0)\n\nbpy.ops.mesh.primitive_torus_add(\n    major_radius=0.8,\n    minor_radius=0.12,\n    location=(-2.5, 0, wall_height/2 + 0.1)\n)\nhandle2 = bpy.context.active_object\nhandle2.name = \"basket_handle_2\"\nhandle2.rotation_euler = (0, 1.5708, 0)\n\n# Create basket rim\nbpy.ops.mesh.primitive_torus_add(\n    major_radius=2.4,\n    minor_radius=0.15,\n    location=(0, 0, wall_height + 0.1)\n)\nrim = bpy.context.active_object\nrim.name = \"basket_rim\"\n\n# Select all basket objects\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in bpy.context.scene.objects:\n    if obj.type == 'MESH' and 'basket' in obj.name:\n        obj.select_set(True)\n\n# Join all objects\nbpy.context.view_layer.objects.active = base\nbpy.ops.object.join()\n\n# Rename final object\nbpy.context.active_object.name = \"acrylic_basket\"\n\n# Export as STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic beam",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create acrylic beam components\nbeam_parts = []\n\n# Main beam body (rectangular)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nmain_beam = bpy.context.active_object\nmain_beam.name = \"BeamBody\"\nmain_beam.scale = (4, 0.5, 0.3)\nbeam_parts.append(main_beam)\n\n# Support cylinders at ends\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.8, location=(-7.5, 0, 0))\nsupport1 = bpy.context.active_object\nsupport1.name = \"Support1\"\nsupport1.rotation_euler[1] = 1.5708  # 90 degrees\nbeam_parts.append(support1)\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.8, location=(7.5, 0, 0))\nsupport2 = bpy.context.active_object\nsupport2.name = \"Support2\"\nsupport2.rotation_euler[1] = 1.5708  # 90 degrees\nbeam_parts.append(support2)\n\n# Mounting holes (small cylinders)\nfor i, x_pos in enumerate([-6, -3, 0, 3, 6]):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=0.7, location=(x_pos, 0, 0))\n    hole = bpy.context.active_object\n    hole.name = f\"MountingHole{i+1}\"\n    hole.rotation_euler[1] = 1.5708\n    beam_parts.append(hole)\n\n# End caps (small cubes)\nbpy.ops.mesh.primitive_cube_add(size=1, location=(-8, 0, 0))\nend_cap1 = bpy.context.active_object\nend_cap1.name = \"EndCap1\"\nend_cap1.scale = (0.3, 0.6, 0.4)\nbeam_parts.append(end_cap1)\n\nbpy.ops.mesh.primitive_cube_add(size=1, location=(8, 0, 0))\nend_cap2 = bpy.context.active_object\nend_cap2.name = \"EndCap2\"\nend_cap2.scale = (0.3, 0.6, 0.4)\nbeam_parts.append(end_cap2)\n\n# Reinforcement spheres\nfor x_pos in [-4.5, -1.5, 1.5, 4.5]:\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.25, location=(x_pos, 0, 0.4))\n    sphere = bpy.context.active_object\n    sphere.name = f\"Reinforcement_sphere\"\n    sphere.scale = (1, 0.8, 0.6)\n    beam_parts.append(sphere)\n\n# Select all beam parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in beam_parts:\n    part.select_set(True)\n\n# Join all parts into one object\nbpy.context.view_layer.objects.active = beam_parts[0]\nbpy.ops.object.join()\n\n# Rename the final object\nfinal_beam = bpy.context.active_object\nfinal_beam.name = \"AcrylicBeam\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic bed",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bed frame base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.1))\nbed_base = bpy.context.active_object\nbed_base.name = \"bed_base\"\nbed_base.scale = (2, 1.5, 0.05)\n\n# Create mattress\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.3))\nmattress = bpy.context.active_object\nmattress.name = \"mattress\"\nmattress.scale = (1.9, 1.4, 0.1)\n\n# Create headboard\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -1.4, 0.8))\nheadboard = bpy.context.active_object\nheadboard.name = \"headboard\"\nheadboard.scale = (2, 0.1, 0.4)\n\n# Create bed legs (4 corners)\nleg_positions = [\n    (1.8, 1.3, -0.2),\n    (-1.8, 1.3, -0.2),\n    (1.8, -1.3, -0.2),\n    (-1.8, -1.3, -0.2)\n]\n\nlegs = []\nfor i, pos in enumerate(leg_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.4, location=pos)\n    leg = bpy.context.active_object\n    leg.name = f\"bed_leg_{i+1}\"\n    legs.append(leg)\n\n# Create pillows\npillow_positions = [\n    (0.6, -1, 0.5),\n    (-0.6, -1, 0.5)\n]\n\npillows = []\nfor i, pos in enumerate(pillow_positions):\n    bpy.ops.mesh.primitive_cube_add(size=1, location=pos)\n    pillow = bpy.context.active_object\n    pillow.name = f\"pillow_{i+1}\"\n    pillow.scale = (0.4, 0.3, 0.1)\n    pillows.append(pillow)\n\n# Select all bed objects\nbed_objects = [bed_base, mattress, headboard] + legs + pillows\nfor obj in bed_objects:\n    obj.select_set(True)\n\nbpy.context.view_layer.objects.active = bed_base\n\n# Group objects together\nbpy.ops.object.join()\nbed_model = bpy.context.active_object\nbed_model.name = \"acrylic_bed\"\n\n# Export as ASCII STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=export_path, use_selection=True, ascii=True)\n```"
  },
  {
    "input": "acrylic bin",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create acrylic bin components\nbin_parts = []\n\n# Main bin body (outer cube)\nbpy.ops.mesh.primitive_cube_add(size=4, location=(0, 0, 1))\nouter_cube = bpy.context.active_object\nouter_cube.name = \"BinOuter\"\nouter_cube.scale = (1, 0.8, 0.6)\nbin_parts.append(outer_cube)\n\n# Inner cavity (smaller cube to subtract effect)\nbpy.ops.mesh.primitive_cube_add(size=3.6, location=(0, 0, 1.1))\ninner_cube = bpy.context.active_object\ninner_cube.name = \"BinInner\"\ninner_cube.scale = (0.95, 0.75, 0.55)\n\n# Apply boolean modifier to create hollow bin\nbool_mod = outer_cube.modifiers.new(name=\"Hollow\", type='BOOLEAN')\nbool_mod.operation = 'DIFFERENCE'\nbool_mod.object = inner_cube\nbpy.context.view_layer.objects.active = outer_cube\nbpy.ops.object.modifier_apply(modifier=\"Hollow\")\n\n# Delete inner cube helper\nbpy.data.objects.remove(inner_cube, do_unlink=True)\n\n# Bottom base\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0, -0.8))\nbottom = bpy.context.active_object\nbottom.name = \"BinBottom\"\nbottom.scale = (4, 3.2, 0.2)\nbin_parts.append(bottom)\n\n# Front lip/edge\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, -1.7, 1.5))\nfront_lip = bpy.context.active_object\nfront_lip.name = \"BinLip\"\nfront_lip.scale = (4, 0.1, 0.3)\nbin_parts.append(front_lip)\n\n# Side handles (cylinders)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=0.8, location=(2.2, 0, 1))\nhandle1 = bpy.context.active_object\nhandle1.name = \"Handle1\"\nhandle1.rotation_euler = (0, 1.5708, 0)\nbin_parts.append(handle1)\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=0.8, location=(-2.2, 0, 1))\nhandle2 = bpy.context.active_object\nhandle2.name = \"Handle2\"\nhandle2.rotation_euler = (0, 1.5708, 0)\nbin_parts.append(handle2)\n\n# Select all bin parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in bin_parts:\n    part.select_set(True)\n\n# Join all parts\nbpy.context.view_layer.objects.active = bin_parts[0]\nbpy.ops.object.join()\n\n# Create collection/group\ncollection = bpy.data.collections.new(\"AcrylicBin\")\nbpy.context.scene.collection.children.link(collection)\ncollection.objects.link(bpy.context.active_object)\n\n# Export as STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    ascii=True,\n    use_selection=False\n)\n```"
  },
  {
    "input": "acrylic blanket",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create blanket using subdivided plane\nbpy.ops.mesh.primitive_plane_add(size=8, location=(0, 0, 0))\nblanket = bpy.context.active_object\nblanket.name = \"Blanket_Base\"\n\n# Add subdivision and displacement for fabric texture\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.subdivide(number_cuts=20)\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Add slight randomization to vertices for organic look\nmodifier = blanket.modifiers.new(name=\"Displace\", type='DISPLACE')\nmodifier.strength = 0.1\n\n# Create blanket edges with extruded thickness\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='SELECT')\nbpy.ops.mesh.extrude_region_move(MESH_OT_extrude_region={\"use_normal_flip\":False, \"mirror\":False}, TRANSFORM_OT_translate={\"value\":(0, 0, 0.1)})\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Add some folds using cubes\nfold_objects = []\n\n# Fold 1\nbpy.ops.mesh.primitive_cube_add(size=1, location=(2, 1, 0.15))\nfold1 = bpy.context.active_object\nfold1.name = \"Fold_1\"\nfold1.scale = (3, 0.5, 0.3)\nfold1.rotation_euler = (0.3, 0, 0.2)\nfold_objects.append(fold1)\n\n# Fold 2\nbpy.ops.mesh.primitive_cube_add(size=1, location=(-1.5, -2, 0.2))\nfold2 = bpy.context.active_object\nfold2.name = \"Fold_2\"\nfold2.scale = (2.5, 0.8, 0.25)\nfold2.rotation_euler = (-0.2, 0, -0.3)\nfold_objects.append(fold2)\n\n# Fold 3\nbpy.ops.mesh.primitive_cube_add(size=1, location=(1, -1.5, 0.18))\nfold3 = bpy.context.active_object\nfold3.name = \"Fold_3\"\nfold3.scale = (1.8, 1.2, 0.2)\nfold3.rotation_euler = (0.15, 0, 0.1)\nfold_objects.append(fold3)\n\n# Add corner details using spheres for rounded edges\ncorner_objects = []\n\ncorners = [(3.5, 3.5, 0.1), (-3.5, 3.5, 0.1), (3.5, -3.5, 0.1), (-3.5, -3.5, 0.1)]\nfor i, pos in enumerate(corners):\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.3, location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"Corner_{i+1}\"\n    corner.scale = (1, 1, 0.5)\n    corner_objects.append(corner)\n\n# Create some texture bumps using small spheres\ntexture_objects = []\nimport random\nrandom.seed(42)\n\nfor i in range(15):\n    x = random.uniform(-3, 3)\n    y = random.uniform(-3, 3)\n    z = random.uniform(0.05, 0.15)\n    \n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.15, location=(x, y, z))\n    texture_bump = bpy.context.active_object\n    texture_bump.name = f\"Texture_Bump_{i+1}\"\n    texture_bump.scale = (random.uniform(0.8, 1.2), random.uniform(0.8, 1.2), 0.3)\n    texture_objects.append(texture_bump)\n\n# Select all objects for grouping\nall_objects = [blanket] + fold_objects + corner_objects + texture_objects\n\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set the blanket as active object\nbpy.context.view_layer.objects.active = blanket\n\n# Join all objects\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic bolt",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bolt head (hexagonal approximation using cylinder)\nbpy.ops.mesh.primitive_cylinder_add(vertices=6, radius=0.8, depth=0.4, location=(0, 0, 0.2))\nbolt_head = bpy.context.active_object\nbolt_head.name = \"BoltHead\"\n\n# Create bolt shaft\nbpy.ops.mesh.primitive_cylinder_add(vertices=16, radius=0.4, depth=3.0, location=(0, 0, -1.3))\nbolt_shaft = bpy.context.active_object\nbolt_shaft.name = \"BoltShaft\"\n\n# Create thread ridges using scaled cylinders\nthread_parts = []\nfor i in range(8):\n    z_pos = -0.5 - (i * 0.3)\n    bpy.ops.mesh.primitive_cylinder_add(vertices=16, radius=0.42, depth=0.15, location=(0, 0, z_pos))\n    thread = bpy.context.active_object\n    thread.name = f\"Thread_{i}\"\n    thread_parts.append(thread)\n\n# Create bolt tip (cone)\nbpy.ops.mesh.primitive_cone_add(vertices=16, radius1=0.4, radius2=0.1, depth=0.4, location=(0, 0, -2.9))\nbolt_tip = bpy.context.active_object\nbolt_tip.name = \"BoltTip\"\n\n# Select all bolt parts\nall_parts = [bolt_head, bolt_shaft, bolt_tip] + thread_parts\nfor obj in all_parts:\n    obj.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = bolt_head\n\n# Join all parts\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"AcrylicBolt\"\n\n# Export as STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic bottle",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bottle body (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=4, location=(0, 0, 0))\nbottle_body = bpy.context.active_object\nbottle_body.name = \"bottle_body\"\n\n# Create bottle neck (smaller cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.4, depth=1.5, location=(0, 0, 2.75))\nbottle_neck = bpy.context.active_object\nbottle_neck.name = \"bottle_neck\"\n\n# Create bottle cap (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.45, depth=0.6, location=(0, 0, 3.8))\nbottle_cap = bpy.context.active_object\nbottle_cap.name = \"bottle_cap\"\n\n# Create bottle bottom (slightly flattened sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.2, location=(0, 0, -2))\nbottle_bottom = bpy.context.active_object\nbottle_bottom.scale[2] = 0.3\nbottle_bottom.name = \"bottle_bottom\"\n\n# Create shoulder transition (scaled sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.2, location=(0, 0, 1.8))\nbottle_shoulder = bpy.context.active_object\nbottle_shoulder.scale[2] = 0.4\nbottle_shoulder.name = \"bottle_shoulder\"\n\n# Create cap threads (torus)\nbpy.ops.mesh.primitive_torus_add(major_radius=0.42, minor_radius=0.05, location=(0, 0, 3.2))\ncap_threads = bpy.context.active_object\ncap_threads.name = \"cap_threads\"\n\n# Select all bottle parts\nbottle_parts = [bottle_body, bottle_neck, bottle_cap, bottle_bottom, bottle_shoulder, cap_threads]\n\n# Deselect all first\nbpy.ops.object.select_all(action='DESELECT')\n\n# Select all bottle parts\nfor part in bottle_parts:\n    part.select_set(True)\n\n# Set the body as active object\nbpy.context.view_layer.objects.active = bottle_body\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"acrylic_bottle\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic bowl",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create outer bowl using UV sphere\nbpy.ops.mesh.primitive_uv_sphere_add(radius=2, location=(0, 0, 0))\nouter_bowl = bpy.context.active_object\nouter_bowl.name = \"outer_bowl\"\n\n# Scale and modify outer sphere to create bowl shape\nouter_bowl.scale = (1, 1, 0.6)\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='DESELECT')\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Select top half of sphere and delete to create bowl opening\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='SELECT')\nbpy.ops.mesh.bisect(plane_co=(0, 0, 0.8), plane_no=(0, 0, 1), clear_inner=True)\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Create inner cavity using scaled sphere\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.8, location=(0, 0, 0.1))\ninner_cavity = bpy.context.active_object\ninner_cavity.name = \"inner_cavity\"\ninner_cavity.scale = (1, 1, 0.55)\n\n# Modify inner sphere similar to outer\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='SELECT')\nbpy.ops.mesh.bisect(plane_co=(0, 0, 0.7), plane_no=(0, 0, 1), clear_inner=True)\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Create bowl rim using torus\nbpy.ops.mesh.primitive_torus_add(major_radius=2, minor_radius=0.1, location=(0, 0, 0.8))\nrim = bpy.context.active_object\nrim.name = \"bowl_rim\"\n\n# Create bowl base using cylinder\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=0.2, location=(0, 0, -0.9))\nbase = bpy.context.active_object\nbase.name = \"bowl_base\"\n\n# Select all bowl parts\nbpy.ops.object.select_all(action='DESELECT')\nouter_bowl.select_set(True)\nrim.select_set(True)\nbase.select_set(True)\nbpy.context.view_layer.objects.active = outer_bowl\n\n# Join outer parts\nbpy.ops.object.join()\n\n# Boolean difference to subtract inner cavity\nbpy.ops.object.modifier_add(type='BOOLEAN')\nbpy.context.object.modifiers[\"Boolean\"].operation = 'DIFFERENCE'\nbpy.context.object.modifiers[\"Boolean\"].object = inner_cavity\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete inner cavity object\nbpy.ops.object.select_all(action='DESELECT')\ninner_cavity.select_set(True)\nbpy.ops.object.delete()\n\n# Select final bowl object\nbpy.ops.object.select_all(action='DESELECT')\nouter_bowl.select_set(True)\nbpy.context.view_layer.objects.active = outer_bowl\n\n# Apply transforms\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Export as ASCII STL\nexport_path = bpy.path.abspath(\"//duck.stl\")\nif not os.path.dirname(export_path):\n    export_path = os.path.join(os.path.expanduser(\"~\"), \"duck.stl\")\n\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic box",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create outer box\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nouter_box = bpy.context.active_object\nouter_box.name = \"outer_box\"\n\n# Create inner box (to subtract for hollow effect)\nbpy.ops.mesh.primitive_cube_add(size=1.8, location=(0, 0, 0.1))\ninner_box = bpy.context.active_object\ninner_box.name = \"inner_box\"\n\n# Create bottom plate\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, -0.9))\nbottom_plate = bpy.context.active_object\nbottom_plate.scale = (1, 1, 0.1)\nbottom_plate.name = \"bottom_plate\"\n\n# Create front panel\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -0.9, 0))\nfront_panel = bpy.context.active_object\nfront_panel.scale = (1, 0.1, 1)\nfront_panel.name = \"front_panel\"\n\n# Create back panel\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0.9, 0))\nback_panel = bpy.context.active_object\nback_panel.scale = (1, 0.1, 1)\nback_panel.name = \"back_panel\"\n\n# Create left panel\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-0.9, 0, 0))\nleft_panel = bpy.context.active_object\nleft_panel.scale = (0.1, 1, 1)\nleft_panel.name = \"left_panel\"\n\n# Create right panel\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0.9, 0, 0))\nright_panel = bpy.context.active_object\nright_panel.scale = (0.1, 1, 1)\nright_panel.name = \"right_panel\"\n\n# Select all box parts\nbox_parts = [bottom_plate, front_panel, back_panel, left_panel, right_panel]\n\n# Select all parts for joining\nbpy.ops.object.select_all(action='DESELECT')\nfor part in box_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = bottom_plate\n\n# Join all parts\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"acrylic_box\"\n\n# Create collection for organization\ncollection = bpy.data.collections.new(\"AcrylicBox\")\nbpy.context.scene.collection.children.link(collection)\n\n# Move object to collection\nacrylic_box = bpy.context.active_object\nbpy.context.scene.collection.objects.unlink(acrylic_box)\ncollection.objects.link(acrylic_box)\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=False,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic bulb",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bulb body (main sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(location=(0, 0, 0), scale=(1, 1, 1.2))\nbulb_body = bpy.context.active_object\nbulb_body.name = \"Bulb_Body\"\n\n# Create bulb neck (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, -1.5), scale=(0.4, 0.4, 0.5))\nbulb_neck = bpy.context.active_object\nbulb_neck.name = \"Bulb_Neck\"\n\n# Create screw threads (multiple small cylinders)\nthread_objects = []\nfor i in range(5):\n    z_pos = -1.8 - (i * 0.1)\n    bpy.ops.mesh.primitive_cylinder_add(location=(0, 0, z_pos), scale=(0.45, 0.45, 0.05))\n    thread = bpy.context.active_object\n    thread.name = f\"Thread_{i}\"\n    thread_objects.append(thread)\n\n# Create base contact (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, -2.5), scale=(0.35, 0.35, 0.2))\nbulb_base = bpy.context.active_object\nbulb_base.name = \"Bulb_Base\"\n\n# Create filament support (thin cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, -0.5), scale=(0.02, 0.02, 0.8))\nfilament_support = bpy.context.active_object\nfilament_support.name = \"Filament_Support\"\n\n# Create filament coil (torus)\nbpy.ops.mesh.primitive_torus_add(location=(0, 0, 0), scale=(0.3, 0.3, 0.3))\nbpy.context.active_object.rotation_euler = (1.5708, 0, 0)\nfilament_coil = bpy.context.active_object\nfilament_coil.name = \"Filament_Coil\"\n\n# Select all objects for grouping\nall_objects = [bulb_body, bulb_neck, bulb_base, filament_support, filament_coil] + thread_objects\n\n# Clear selection and select all bulb parts\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = bulb_body\n\n# Join all objects\nbpy.ops.object.join()\n\n# Ensure the joined object is selected\njoined_bulb = bpy.context.active_object\njoined_bulb.name = \"Acrylic_Bulb\"\n\n# Export as ASCII STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic cabinet",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cabinet frame (main body)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1))\ncabinet_body = bpy.context.active_object\ncabinet_body.name = \"Cabinet_Body\"\ncabinet_body.scale = (1.5, 0.8, 2)\n\n# Create cabinet back panel\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -0.75, 1))\nback_panel = bpy.context.active_object\nback_panel.name = \"Back_Panel\"\nback_panel.scale = (1.45, 0.05, 1.95)\n\n# Create cabinet shelves\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.5))\nshelf1 = bpy.context.active_object\nshelf1.name = \"Shelf_1\"\nshelf1.scale = (1.4, 0.75, 0.05)\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1.5))\nshelf2 = bpy.context.active_object\nshelf2.name = \"Shelf_2\"\nshelf2.scale = (1.4, 0.75, 0.05)\n\n# Create cabinet sides\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-1.4, 0, 1))\nleft_side = bpy.context.active_object\nleft_side.name = \"Left_Side\"\nleft_side.scale = (0.05, 0.75, 1.95)\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(1.4, 0, 1))\nright_side = bpy.context.active_object\nright_side.name = \"Right_Side\"\nright_side.scale = (0.05, 0.75, 1.95)\n\n# Create cabinet top\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 2.9))\ntop_panel = bpy.context.active_object\ntop_panel.name = \"Top_Panel\"\ntop_panel.scale = (1.5, 0.8, 0.05)\n\n# Create cabinet door frames\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0.8, 0.75))\ndoor_frame1 = bpy.context.active_object\ndoor_frame1.name = \"Door_Frame_1\"\ndoor_frame1.scale = (1.3, 0.02, 0.4)\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0.8, 1.75))\ndoor_frame2 = bpy.context.active_object\ndoor_frame2.name = \"Door_Frame_2\"\ndoor_frame2.scale = (1.3, 0.02, 0.4)\n\n# Create door handles (cylinders)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.03, depth=0.1, location=(1, 0.85, 0.75))\nhandle1 = bpy.context.active_object\nhandle1.name = \"Handle_1\"\nhandle1.rotation_euler = (0, 1.5708, 0)\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.03, depth=0.1, location=(1, 0.85, 1.75))\nhandle2 = bpy.context.active_object\nhandle2.name = \"Handle_2\"\nhandle2.rotation_euler = (0, 1.5708, 0)\n\n# Create cabinet legs (cylinders)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.3, location=(-1.2, -0.6, -0.15))\nleg1 = bpy.context.active_object\nleg1.name = \"Leg_1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.3, location=(1.2, -0.6, -0.15))\nleg2 = bpy.context.active_object\nleg2.name = \"Leg_2\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.3, location=(-1.2, 0.6, -0.15))\nleg3 = bpy.context.active_object\nleg3.name = \"Leg_3\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.3, location=(1.2, 0.6, -0.15))\nleg4 = bpy.context.active_object\nleg4.name = \"Leg_4\"\n\n# Select all cabinet parts\ncabinet_parts = [cabinet_body, back_panel, shelf1, shelf2, left_side, right_side, \n                top_panel, door_frame1, door_frame2, handle1, handle2, leg1, leg2, leg3, leg4]\n\nbpy.ops.object.select_all(action='DESELECT')\nfor part in cabinet_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = cabinet_body\n\n# Join all parts\nbpy.ops.object.join()\n\n# Export as STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=export_path, use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "acrylic cable",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cable body (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2.0, location=(0, 0, 0))\ncable_body = bpy.context.active_object\ncable_body.name = \"Cable_Body\"\n\n# Create cable end 1 (slightly tapered cylinder)\nbpy.ops.mesh.primitive_cone_add(radius1=0.05, radius2=0.04, depth=0.2, location=(-1.1, 0, 0))\ncable_end1 = bpy.context.active_object\ncable_end1.name = \"Cable_End1\"\n\n# Create cable end 2 (slightly tapered cylinder)\nbpy.ops.mesh.primitive_cone_add(radius1=0.05, radius2=0.04, depth=0.2, location=(1.1, 0, 0))\ncable_end2 = bpy.context.active_object\ncable_end2.name = \"Cable_End2\"\n\n# Create connector 1 (cube for connector housing)\nbpy.ops.mesh.primitive_cube_add(size=0.3, location=(-1.25, 0, 0))\nconnector1 = bpy.context.active_object\nconnector1.name = \"Connector1\"\nconnector1.scale = (0.8, 1.2, 0.6)\n\n# Create connector 2 (cube for connector housing)\nbpy.ops.mesh.primitive_cube_add(size=0.3, location=(1.25, 0, 0))\nconnector2 = bpy.context.active_object\nconnector2.name = \"Connector2\"\nconnector2.scale = (0.8, 1.2, 0.6)\n\n# Create connector pins 1\nbpy.ops.mesh.primitive_cylinder_add(radius=0.01, depth=0.1, location=(-1.35, -0.05, 0.05))\npin1_1 = bpy.context.active_object\npin1_1.name = \"Pin1_1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.01, depth=0.1, location=(-1.35, 0.05, 0.05))\npin1_2 = bpy.context.active_object\npin1_2.name = \"Pin1_2\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.01, depth=0.1, location=(-1.35, -0.05, -0.05))\npin1_3 = bpy.context.active_object\npin1_3.name = \"Pin1_3\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.01, depth=0.1, location=(-1.35, 0.05, -0.05))\npin1_4 = bpy.context.active_object\npin1_4.name = \"Pin1_4\"\n\n# Create connector pins 2\nbpy.ops.mesh.primitive_cylinder_add(radius=0.01, depth=0.1, location=(1.35, -0.05, 0.05))\npin2_1 = bpy.context.active_object\npin2_1.name = \"Pin2_1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.01, depth=0.1, location=(1.35, 0.05, 0.05))\npin2_2 = bpy.context.active_object\npin2_2.name = \"Pin2_2\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.01, depth=0.1, location=(1.35, -0.05, -0.05))\npin2_3 = bpy.context.active_object\npin2_3.name = \"Pin2_3\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.01, depth=0.1, location=(1.35, 0.05, -0.05))\npin2_4 = bpy.context.active_object\npin2_4.name = \"Pin2_4\"\n\n# Select all cable parts\ncable_parts = [cable_body, cable_end1, cable_end2, connector1, connector2, \n               pin1_1, pin1_2, pin1_3, pin1_4, pin2_1, pin2_2, pin2_3, pin2_4]\n\nbpy.ops.object.select_all(action='DESELECT')\nfor part in cable_parts:\n    part.select_set(True)\n\ncable_body.select_set(True)\nbpy.context.view_layer.objects.active = cable_body\n\n# Join all parts\nbpy.ops.object.join()\n\n# Export as ASCII STL\nfilepath = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=filepath, use_selection=True, ascii=True)\n```"
  },
  {
    "input": "acrylic carpet",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create carpet base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncarpet_base = bpy.context.active_object\ncarpet_base.name = \"CarpetBase\"\ncarpet_base.scale = (4, 3, 0.1)\n\n# Create carpet fibers using cylinders\nfiber_positions = []\nfor x in range(-15, 16, 2):\n    for y in range(-12, 13, 2):\n        fiber_positions.append((x * 0.2, y * 0.2, 0.15))\n\nfibers = []\nfor i, pos in enumerate(fiber_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.02, depth=0.3, location=pos)\n    fiber = bpy.context.active_object\n    fiber.name = f\"Fiber_{i}\"\n    fiber.rotation_euler = (0.1 * (i % 3 - 1), 0.1 * ((i + 1) % 3 - 1), 0)\n    fibers.append(fiber)\n\n# Create some tufted areas using spheres\nfor i in range(20):\n    x = (i % 5 - 2) * 1.5\n    y = (i // 5 - 2) * 1.0\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.15, location=(x, y, 0.2))\n    tuft = bpy.context.active_object\n    tuft.name = f\"Tuft_{i}\"\n    tuft.scale = (1, 1, 0.3)\n\n# Add some textural elements using cones\nfor i in range(10):\n    x = (i % 5 - 2) * 1.2 + 0.6\n    y = (i // 5 - 1) * 1.5 + 0.5\n    bpy.ops.mesh.primitive_cone_add(radius1=0.08, depth=0.2, location=(x, y, 0.25))\n    texture_element = bpy.context.active_object\n    texture_element.name = f\"TextureElement_{i}\"\n    texture_element.rotation_euler = (0, 0, i * 0.6)\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"AcrylicCarpet\"\n\n# Export as ASCII STL\noutput_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nif not bpy.path.abspath(\"//\"):\n    output_path = os.path.join(os.path.expanduser(\"~\"), \"duck.stl\")\n\nbpy.ops.export_mesh.stl(\n    filepath=output_path,\n    use_selection=True,\n    ascii=True\n)\n\nprint(f\"Model exported to: {output_path}\")\n```"
  },
  {
    "input": "acrylic chain",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create chain links\nchain_links = []\nlink_count = 8\nspacing = 3.0\n\nfor i in range(link_count):\n    # Create outer cylinder for link\n    bpy.ops.mesh.primitive_cylinder_add(\n        radius=1.0,\n        depth=0.3,\n        location=(i * spacing, 0, 0)\n    )\n    outer_cylinder = bpy.context.active_object\n    outer_cylinder.name = f\"link_outer_{i}\"\n    \n    # Create inner cylinder to subtract (simulate hole)\n    bpy.ops.mesh.primitive_cylinder_add(\n        radius=0.7,\n        depth=0.4,\n        location=(i * spacing, 0, 0)\n    )\n    inner_cylinder = bpy.context.active_object\n    inner_cylinder.name = f\"link_inner_{i}\"\n    \n    # Apply boolean difference\n    bool_modifier = outer_cylinder.modifiers.new(name=\"Boolean\", type='BOOLEAN')\n    bool_modifier.operation = 'DIFFERENCE'\n    bool_modifier.object = inner_cylinder\n    \n    # Apply modifier\n    bpy.context.view_layer.objects.active = outer_cylinder\n    bpy.ops.object.modifier_apply(modifier=\"Boolean\")\n    \n    # Delete inner cylinder\n    bpy.ops.object.select_all(action='DESELECT')\n    inner_cylinder.select_set(True)\n    bpy.ops.object.delete()\n    \n    # Rotate alternating links\n    if i % 2 == 1:\n        outer_cylinder.rotation_euler = (1.5708, 0, 0)  # 90 degrees in radians\n    \n    chain_links.append(outer_cylinder)\n\n# Create connecting spheres between links\nconnectors = []\nfor i in range(link_count - 1):\n    bpy.ops.mesh.primitive_uv_sphere_add(\n        radius=0.2,\n        location=(i * spacing + spacing/2, 0, 0)\n    )\n    connector = bpy.context.active_object\n    connector.name = f\"connector_{i}\"\n    connectors.append(connector)\n\n# Create end caps using cones\nbpy.ops.mesh.primitive_cone_add(\n    radius1=0.5,\n    radius2=0.2,\n    depth=0.8,\n    location=(-1.0, 0, 0)\n)\nend_cap1 = bpy.context.active_object\nend_cap1.name = \"end_cap_1\"\nend_cap1.rotation_euler = (0, 1.5708, 0)\n\nbpy.ops.mesh.primitive_cone_add(\n    radius1=0.5,\n    radius2=0.2,\n    depth=0.8,\n    location=((link_count-1) * spacing + 1.0, 0, 0)\n)\nend_cap2 = bpy.context.active_object\nend_cap2.name = \"end_cap_2\"\nend_cap2.rotation_euler = (0, -1.5708, 0)\n\n# Select all chain objects\nbpy.ops.object.select_all(action='DESELECT')\nfor link in chain_links:\n    link.select_set(True)\nfor connector in connectors:\n    connector.select_set(True)\nend_cap1.select_set(True)\nend_cap2.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = chain_links[0]\n\n# Join all objects\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Acrylic_Chain\"\n\n# Export as STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic chair",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create seat\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 1))\nseat = bpy.context.active_object\nseat.name = \"Seat\"\nseat.scale = (1.2, 1.2, 0.1)\n\n# Create backrest\nbpy.ops.mesh.primitive_cube_add(location=(0, -1.1, 1.8))\nbackrest = bpy.context.active_object\nbackrest.name = \"Backrest\"\nbackrest.scale = (1.2, 0.1, 0.8)\n\n# Create front left leg\nbpy.ops.mesh.primitive_cylinder_add(location=(-1, 1, 0.45))\nfront_left_leg = bpy.context.active_object\nfront_left_leg.name = \"Front_Left_Leg\"\nfront_left_leg.scale = (0.05, 0.05, 0.45)\n\n# Create front right leg\nbpy.ops.mesh.primitive_cylinder_add(location=(1, 1, 0.45))\nfront_right_leg = bpy.context.active_object\nfront_right_leg.name = \"Front_Right_Leg\"\nfront_right_leg.scale = (0.05, 0.05, 0.45)\n\n# Create back left leg\nbpy.ops.mesh.primitive_cylinder_add(location=(-1, -1, 0.45))\nback_left_leg = bpy.context.active_object\nback_left_leg.name = \"Back_Left_Leg\"\nback_left_leg.scale = (0.05, 0.05, 0.45)\n\n# Create back right leg\nbpy.ops.mesh.primitive_cylinder_add(location=(1, -1, 0.45))\nback_right_leg = bpy.context.active_object\nback_right_leg.name = \"Back_Right_Leg\"\nback_right_leg.scale = (0.05, 0.05, 0.45)\n\n# Create armrest left\nbpy.ops.mesh.primitive_cube_add(location=(-1.3, 0, 1.3))\narmrest_left = bpy.context.active_object\narmrest_left.name = \"Armrest_Left\"\narmrest_left.scale = (0.1, 0.8, 0.05)\n\n# Create armrest right\nbpy.ops.mesh.primitive_cube_add(location=(1.3, 0, 1.3))\narmrest_right = bpy.context.active_object\narmrest_right.name = \"Armrest_Right\"\narmrest_right.scale = (0.1, 0.8, 0.05)\n\n# Create armrest supports left\nbpy.ops.mesh.primitive_cylinder_add(location=(-1.3, 0.6, 1.15))\narmrest_support_left_front = bpy.context.active_object\narmrest_support_left_front.name = \"Armrest_Support_Left_Front\"\narmrest_support_left_front.scale = (0.03, 0.03, 0.15)\n\nbpy.ops.mesh.primitive_cylinder_add(location=(-1.3, -0.6, 1.15))\narmrest_support_left_back = bpy.context.active_object\narmrest_support_left_back.name = \"Armrest_Support_Left_Back\"\narmrest_support_left_back.scale = (0.03, 0.03, 0.15)\n\n# Create armrest supports right\nbpy.ops.mesh.primitive_cylinder_add(location=(1.3, 0.6, 1.15))\narmrest_support_right_front = bpy.context.active_object\narmrest_support_right_front.name = \"Armrest_Support_Right_Front\"\narmrest_support_right_front.scale = (0.03, 0.03, 0.15)\n\nbpy.ops.mesh.primitive_cylinder_add(location=(1.3, -0.6, 1.15))\narmrest_support_right_back = bpy.context.active_object\narmrest_support_right_back.name = \"Armrest_Support_Right_Back\"\narmrest_support_right_back.scale = (0.03, 0.03, 0.15)\n\n# Select all chair parts\nchair_parts = [\n    seat, backrest, front_left_leg, front_right_leg, \n    back_left_leg, back_right_leg, armrest_left, armrest_right,\n    armrest_support_left_front, armrest_support_left_back,\n    armrest_support_right_front, armrest_support_right_back\n]\n\n# Deselect all objects first\nbpy.ops.object.select_all(action='DESELECT')\n\n# Select all chair parts\nfor part in chair_parts:\n    part.select_set(True)\n\n# Set active object to seat for joining\nbpy.context.view_layer.objects.active = seat\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Acrylic_Chair\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic clock",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create clock base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=3, depth=0.2, location=(0, 0, 0))\nclock_base = bpy.context.active_object\nclock_base.name = \"ClockBase\"\n\n# Create clock face (cylinder, slightly smaller and thinner)\nbpy.ops.mesh.primitive_cylinder_add(radius=2.8, depth=0.05, location=(0, 0, 0.125))\nclock_face = bpy.context.active_object\nclock_face.name = \"ClockFace\"\n\n# Create center pivot (small cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.1, location=(0, 0, 0.2))\ncenter_pivot = bpy.context.active_object\ncenter_pivot.name = \"CenterPivot\"\n\n# Create hour hand (scaled cube)\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, -0.8, 0.25))\nbpy.context.active_object.scale = (0.05, 1.6, 0.02)\nhour_hand = bpy.context.active_object\nhour_hand.name = \"HourHand\"\n\n# Create minute hand (scaled cube)\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, -1.2, 0.27))\nbpy.context.active_object.scale = (0.03, 2.4, 0.02)\nminute_hand = bpy.context.active_object\nminute_hand.name = \"MinuteHand\"\n\n# Create hour markers (12 small cylinders)\nfor i in range(12):\n    angle = i * 30  # 360/12 = 30 degrees\n    x = 2.3 * bpy.context.scene.unit_settings.scale_length * 1.0\n    import math\n    x_pos = 2.3 * math.cos(math.radians(angle - 90))\n    y_pos = 2.3 * math.sin(math.radians(angle - 90))\n    \n    bpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(x_pos, y_pos, 0.175))\n    marker = bpy.context.active_object\n    marker.name = f\"HourMarker_{i+1}\"\n\n# Create clock stand base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=0.3, location=(0, 0, -0.25))\nstand_base = bpy.context.active_object\nstand_base.name = \"StandBase\"\n\n# Create clock support arm (cube)\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0, -2))\nbpy.context.active_object.scale = (0.2, 0.2, 3.5)\nsupport_arm = bpy.context.active_object\nsupport_arm.name = \"SupportArm\"\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Group objects\nbpy.ops.object.join()\nclock_group = bpy.context.active_object\nclock_group.name = \"AcrylicClock\"\n\n# Export as ASCII STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=export_path, use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "acrylic column",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create acrylic column base\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=0.3, location=(0, 0, 0.15))\nbase = bpy.context.active_object\nbase.name = \"Column_Base\"\n\n# Create main column shaft\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=8, location=(0, 0, 4.15))\nshaft = bpy.context.active_object\nshaft.name = \"Column_Shaft\"\n\n# Create column capital (top)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=0.5, location=(0, 0, 8.4))\ncapital = bpy.context.active_object\ncapital.name = \"Column_Capital\"\n\n# Create decorative top element\nbpy.ops.mesh.primitive_cylinder_add(radius=0.6, depth=0.2, location=(0, 0, 8.75))\ntop_element = bpy.context.active_object\ntop_element.name = \"Column_Top\"\n\n# Select all column parts\nbpy.ops.object.select_all(action='DESELECT')\nbase.select_set(True)\nshaft.select_set(True)\ncapital.select_set(True)\ntop_element.select_set(True)\n\n# Set active object for grouping\nbpy.context.view_layer.objects.active = base\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Acrylic_Column\"\n\n# Export as ASCII STL\nfilepath = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=filepath,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic container",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create outer container (cube)\nbpy.ops.mesh.primitive_cube_add(size=4, location=(0, 0, 2))\nouter_container = bpy.context.active_object\nouter_container.name = \"OuterContainer\"\n\n# Create inner cavity (cube) - slightly smaller\nbpy.ops.mesh.primitive_cube_add(size=3.6, location=(0, 0, 2.2))\ninner_cavity = bpy.context.active_object\ninner_cavity.name = \"InnerCavity\"\n\n# Create bottom base (cube) - thin\nbpy.ops.mesh.primitive_cube_add(size=4, location=(0, 0, 0.1))\nbpy.context.active_object.scale[2] = 0.05\nbottom_base = bpy.context.active_object\nbottom_base.name = \"BottomBase\"\n\n# Create lid (cube) - thin\nbpy.ops.mesh.primitive_cube_add(size=4.2, location=(0, 0, 4.2))\nbpy.context.active_object.scale[2] = 0.05\nlid = bpy.context.active_object\nlid.name = \"Lid\"\n\n# Create handle (cylinder) - small\nbpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=0.8, location=(2.5, 0, 4.2))\nbpy.context.active_object.rotation_euler[1] = 1.5708  # 90 degrees\nhandle = bpy.context.active_object\nhandle.name = \"Handle\"\n\n# Boolean operation to create hollow container\n# Select outer container first, then inner cavity\nbpy.context.view_layer.objects.active = outer_container\nouter_container.select_set(True)\ninner_cavity.select_set(True)\n\n# Add boolean modifier\nbool_modifier = outer_container.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nbool_modifier.operation = 'DIFFERENCE'\nbool_modifier.object = inner_cavity\n\n# Apply boolean modifier\nbpy.context.view_layer.objects.active = outer_container\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Hide/delete the inner cavity object\ninner_cavity.select_set(True)\nbpy.ops.object.delete()\n\n# Select all container parts\ncontainer_parts = [outer_container, bottom_base, lid, handle]\nfor part in container_parts:\n    part.select_set(True)\n\n# Join all parts together\nbpy.context.view_layer.objects.active = outer_container\nbpy.ops.object.join()\n\n# Rename the final object\nfinal_container = bpy.context.active_object\nfinal_container.name = \"AcrylicContainer\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic cup",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create outer cylinder for cup body\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, 0, 1))\nouter_cylinder = bpy.context.active_object\nouter_cylinder.name = \"Cup_Outer\"\n\n# Create inner cylinder for hollowing\nbpy.ops.mesh.primitive_cylinder_add(radius=0.9, depth=2.2, location=(0, 0, 1.1))\ninner_cylinder = bpy.context.active_object\ninner_cylinder.name = \"Cup_Inner\"\n\n# Create bottom of cup\nbpy.ops.mesh.primitive_cylinder_add(radius=0.9, depth=0.1, location=(0, 0, 0.05))\nbottom = bpy.context.active_object\nbottom.name = \"Cup_Bottom\"\n\n# Create handle using torus\nbpy.ops.mesh.primitive_torus_add(major_radius=0.4, minor_radius=0.05, location=(1.2, 0, 1))\nhandle = bpy.context.active_object\nhandle.name = \"Cup_Handle\"\nhandle.rotation_euler = (0, 1.5708, 0)\n\n# Boolean operation to hollow out the cup\nbpy.context.view_layer.objects.active = outer_cylinder\nouter_cylinder.select_set(True)\ninner_cylinder.select_set(True)\n\n# Add boolean modifier\nbool_modifier = outer_cylinder.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nbool_modifier.operation = 'DIFFERENCE'\nbool_modifier.object = inner_cylinder\n\n# Apply modifier\nbpy.context.view_layer.objects.active = outer_cylinder\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete inner cylinder\nbpy.ops.object.select_all(action='DESELECT')\ninner_cylinder.select_set(True)\nbpy.ops.object.delete()\n\n# Select all cup parts\nbpy.ops.object.select_all(action='DESELECT')\nouter_cylinder.select_set(True)\nbottom.select_set(True)\nhandle.select_set(True)\n\n# Join all parts\nbpy.context.view_layer.objects.active = outer_cylinder\nbpy.ops.object.join()\n\n# Rename final object\nbpy.context.active_object.name = \"Acrylic_Cup\"\n\n# Select the cup for export\nbpy.ops.object.select_all(action='DESELECT')\nbpy.context.active_object.select_set(True)\n\n# Export as STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_selection=True, ascii=True)\n```"
  },
  {
    "input": "acrylic curtain",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create curtain rod\nbpy.ops.mesh.primitive_cylinder_add(radius=0.02, depth=3.0, location=(0, 0, 2.5))\nrod = bpy.context.active_object\nrod.name = \"CurtainRod\"\n\n# Create curtain panels using scaled cubes\ncurtain_parts = []\n\n# Main curtain panel 1\nbpy.ops.mesh.primitive_cube_add(size=1, location=(-0.7, 0, 1.5))\npanel1 = bpy.context.active_object\npanel1.name = \"CurtainPanel1\"\npanel1.scale = (0.02, 0.05, 2.0)\ncurtain_parts.append(panel1)\n\n# Main curtain panel 2\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0.7, 0, 1.5))\npanel2 = bpy.context.active_object\npanel2.name = \"CurtainPanel2\"\npanel2.scale = (0.02, 0.05, 2.0)\ncurtain_parts.append(panel2)\n\n# Create hanging rings using torus primitives (UV spheres scaled to rings)\nfor i in range(6):\n    x_pos = -1.25 + (i * 0.5)\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.05, location=(x_pos, 0, 2.45))\n    ring = bpy.context.active_object\n    ring.name = f\"Ring{i+1}\"\n    ring.scale = (1.0, 1.0, 0.2)\n    curtain_parts.append(ring)\n\n# Create curtain fabric using multiple thin cubes for draping effect\nfor i in range(8):\n    x_pos = -1.4 + (i * 0.4)\n    y_offset = 0.02 * (i % 2 - 0.5)  # Slight alternating offset for draping\n    \n    bpy.ops.mesh.primitive_cube_add(size=1, location=(x_pos, y_offset, 1.25))\n    fabric = bpy.context.active_object\n    fabric.name = f\"FabricStrip{i+1}\"\n    fabric.scale = (0.15, 0.01, 1.5)\n    curtain_parts.append(fabric)\n\n# Create curtain tiebacks using cylinders\nbpy.ops.mesh.primitive_cylinder_add(radius=0.02, depth=0.5, location=(-1.2, 0.2, 1.0))\ntieback1 = bpy.context.active_object\ntieback1.name = \"Tieback1\"\ntieback1.rotation_euler = (0, 1.57, 0)\ncurtain_parts.append(tieback1)\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.02, depth=0.5, location=(1.2, 0.2, 1.0))\ntieback2 = bpy.context.active_object\ntieback2.name = \"Tieback2\"\ntieback2.rotation_euler = (0, 1.57, 0)\ncurtain_parts.append(tieback2)\n\n# Create wall mounts using cones\nbpy.ops.mesh.primitive_cone_add(radius1=0.08, radius2=0.04, depth=0.1, location=(-1.5, -0.05, 2.5))\nmount1 = bpy.context.active_object\nmount1.name = \"WallMount1\"\nmount1.rotation_euler = (0, 1.57, 0)\ncurtain_parts.append(mount1)\n\nbpy.ops.mesh.primitive_cone_add(radius1=0.08, radius2=0.04, depth=0.1, location=(1.5, -0.05, 2.5))\nmount2 = bpy.context.active_object\nmount2.name = \"WallMount2\"\nmount2.rotation_euler = (0, 1.57, 0)\ncurtain_parts.append(mount2)\n\n# Add rod to curtain parts\ncurtain_parts.append(rod)\n\n# Select all curtain parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in curtain_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = curtain_parts[0]\n\n# Join all parts\nbpy.ops.object.join()\n\n# Rename the final object\nfinal_object = bpy.context.active_object\nfinal_object.name = \"AcrylicCurtain\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic cushion",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cushion base (flattened cube)\nbpy.ops.mesh.primitive_cube_add(size=4, location=(0, 0, 0))\ncushion_base = bpy.context.active_object\ncushion_base.name = \"CushionBase\"\ncushion_base.scale = (1.2, 1.2, 0.3)\n\n# Create cushion top (flattened sphere for soft appearance)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=2.2, location=(0, 0, 0.8))\ncushion_top = bpy.context.active_object\ncushion_top.name = \"CushionTop\"\ncushion_top.scale = (1.0, 1.0, 0.4)\n\n# Create button indent (small flattened sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.3, location=(0, 0, 1.2))\nbutton_indent = bpy.context.active_object\nbutton_indent.name = \"ButtonIndent\"\nbutton_indent.scale = (1.0, 1.0, 0.2)\n\n# Create corner roundings (small spheres at corners)\ncorner_positions = [\n    (1.8, 1.8, 0.3),\n    (-1.8, 1.8, 0.3),\n    (1.8, -1.8, 0.3),\n    (-1.8, -1.8, 0.3)\n]\n\ncorner_objects = []\nfor i, pos in enumerate(corner_positions):\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.4, location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"Corner_{i}\"\n    corner.scale = (1.0, 1.0, 0.8)\n    corner_objects.append(corner)\n\n# Create piping around edges (cylinders)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=4.8, location=(2.4, 0, 0.3), rotation=(0, 1.5708, 0))\npipe1 = bpy.context.active_object\npipe1.name = \"Pipe1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=4.8, location=(-2.4, 0, 0.3), rotation=(0, 1.5708, 0))\npipe2 = bpy.context.active_object\npipe2.name = \"Pipe2\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=4.8, location=(0, 2.4, 0.3))\npipe3 = bpy.context.active_object\npipe3.name = \"Pipe3\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=4.8, location=(0, -2.4, 0.3))\npipe4 = bpy.context.active_object\npipe4.name = \"Pipe4\"\n\n# Apply transforms\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Group all objects\nall_objects = [cushion_base, cushion_top, button_indent] + corner_objects + [pipe1, pipe2, pipe3, pipe4]\n\n# Join all objects\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in all_objects:\n    obj.select_set(True)\nbpy.context.view_layer.objects.active = cushion_base\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=False,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic desk",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create desk top (main surface)\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 1.5))\ndesk_top = bpy.context.active_object\ndesk_top.name = \"DeskTop\"\ndesk_top.scale = (3, 1.5, 0.05)\n\n# Create desk legs (4 cylindrical legs)\nleg_positions = [(-2.8, -1.3, 0.75), (2.8, -1.3, 0.75), (-2.8, 1.3, 0.75), (2.8, 1.3, 0.75)]\nlegs = []\n\nfor i, pos in enumerate(leg_positions):\n    bpy.ops.mesh.primitive_cylinder_add(location=pos)\n    leg = bpy.context.active_object\n    leg.name = f\"DeskLeg_{i+1}\"\n    leg.scale = (0.08, 0.08, 0.75)\n    legs.append(leg)\n\n# Create desk drawer front\nbpy.ops.mesh.primitive_cube_add(location=(0, -1.35, 1.2))\ndrawer_front = bpy.context.active_object\ndrawer_front.name = \"DrawerFront\"\ndrawer_front.scale = (2.5, 0.05, 0.25)\n\n# Create drawer handle\nbpy.ops.mesh.primitive_cylinder_add(location=(0, -1.45, 1.2), rotation=(1.5708, 0, 0))\ndrawer_handle = bpy.context.active_object\ndrawer_handle.name = \"DrawerHandle\"\ndrawer_handle.scale = (0.03, 0.15, 0.03)\n\n# Create desk side panels\nbpy.ops.mesh.primitive_cube_add(location=(-2.85, 0, 1.0))\nleft_panel = bpy.context.active_object\nleft_panel.name = \"LeftPanel\"\nleft_panel.scale = (0.05, 1.4, 0.45)\n\nbpy.ops.mesh.primitive_cube_add(location=(2.85, 0, 1.0))\nright_panel = bpy.context.active_object\nright_panel.name = \"RightPanel\"\nright_panel.scale = (0.05, 1.4, 0.45)\n\n# Create back panel\nbpy.ops.mesh.primitive_cube_add(location=(0, 1.4, 1.0))\nback_panel = bpy.context.active_object\nback_panel.name = \"BackPanel\"\nback_panel.scale = (2.9, 0.05, 0.45)\n\n# Select all objects to group them\nall_objects = [desk_top] + legs + [drawer_front, drawer_handle, left_panel, right_panel, back_panel]\n\n# Deselect all first\nbpy.ops.object.select_all(action='DESELECT')\n\n# Select all desk parts\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = desk_top\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"AcrylicDesk\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic door",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create door frame (main structure)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1))\ndoor_frame = bpy.context.active_object\ndoor_frame.name = \"DoorFrame\"\ndoor_frame.scale = (1.5, 0.1, 2)\n\n# Create acrylic panel (slightly inset)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0.05, 1))\nacrylic_panel = bpy.context.active_object\nacrylic_panel.name = \"AcrylicPanel\"\nacrylic_panel.scale = (1.3, 0.05, 1.8)\n\n# Create door handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.3, location=(1.2, 0.2, 1))\nhandle = bpy.context.active_object\nhandle.name = \"Handle\"\nhandle.rotation_euler = (0, 1.5708, 0)\n\n# Create handle knob\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.08, location=(1.35, 0.2, 1))\nhandle_knob = bpy.context.active_object\nhandle_knob.name = \"HandleKnob\"\n\n# Create hinges\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.2, location=(-1.4, 0.15, 1.5))\nhinge1 = bpy.context.active_object\nhinge1.name = \"Hinge1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.2, location=(-1.4, 0.15, 0.5))\nhinge2 = bpy.context.active_object\nhinge2.name = \"Hinge2\"\n\n# Create door threshold\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, -0.1))\nthreshold = bpy.context.active_object\nthreshold.name = \"Threshold\"\nthreshold.scale = (1.6, 0.2, 0.1)\n\n# Select all door parts\ndoor_parts = [door_frame, acrylic_panel, handle, handle_knob, hinge1, hinge2, threshold]\nbpy.ops.object.select_all(action='DESELECT')\nfor part in door_parts:\n    part.select_set(True)\n\n# Join all parts into one object\nbpy.context.view_layer.objects.active = door_frame\nbpy.ops.object.join()\n\n# Export as ASCII STL\noutput_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=output_path, use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "acrylic engine",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Engine Block\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nengine_block = bpy.context.active_object\nengine_block.name = \"EngineBlock\"\nengine_block.scale = (2, 1.5, 1)\n\n# Cylinders (4 cylinders)\ncylinders = []\ncylinder_positions = [(-0.75, 0, 0.7), (-0.25, 0, 0.7), (0.25, 0, 0.7), (0.75, 0, 0.7)]\nfor i, pos in enumerate(cylinder_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.8, location=pos)\n    cylinder = bpy.context.active_object\n    cylinder.name = f\"Cylinder_{i+1}\"\n    cylinders.append(cylinder)\n\n# Pistons\npistons = []\nfor i, pos in enumerate(cylinder_positions):\n    piston_pos = (pos[0], pos[1], pos[2] + 0.5)\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=0.3, location=piston_pos)\n    piston = bpy.context.active_object\n    piston.name = f\"Piston_{i+1}\"\n    pistons.append(piston)\n\n# Crankshaft\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=4.5, location=(0, 0, -0.3))\ncrankshaft = bpy.context.active_object\ncrankshaft.name = \"Crankshaft\"\ncrankshaft.rotation_euler = (0, 1.5708, 0)\n\n# Oil Pan\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0, -0.8))\noil_pan = bpy.context.active_object\noil_pan.name = \"OilPan\"\noil_pan.scale = (2.2, 1.7, 0.4)\n\n# Intake Manifold\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 1.2, 0.3))\nintake_manifold = bpy.context.active_object\nintake_manifold.name = \"IntakeManifold\"\nintake_manifold.scale = (1.8, 0.3, 0.6)\n\n# Exhaust Manifold\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, -1.2, 0.3))\nexhaust_manifold = bpy.context.active_object\nexhaust_manifold.name = \"ExhaustManifold\"\nexhaust_manifold.scale = (1.8, 0.3, 0.6)\n\n# Valve Cover\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0, 1.2))\nvalve_cover = bpy.context.active_object\nvalve_cover.name = \"ValveCover\"\nvalve_cover.scale = (1.9, 1.4, 0.2)\n\n# Spark Plugs\nspark_plugs = []\nspark_plug_positions = [(-0.75, 0, 1.5), (-0.25, 0, 1.5), (0.25, 0, 1.5), (0.75, 0, 1.5)]\nfor i, pos in enumerate(spark_plug_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.4, location=pos)\n    spark_plug = bpy.context.active_object\n    spark_plug.name = f\"SparkPlug_{i+1}\"\n    spark_plugs.append(spark_plug)\n\n# Air Filter\nbpy.ops.mesh.primitive_cylinder_add(radius=0.4, depth=0.3, location=(0, 1.8, 0.3))\nair_filter = bpy.context.active_object\nair_filter.name = \"AirFilter\"\n\n# Flywheel\nbpy.ops.mesh.primitive_cylinder_add(radius=0.6, depth=0.1, location=(2.5, 0, -0.3))\nflywheel = bpy.context.active_object\nflywheel.name = \"Flywheel\"\nflywheel.rotation_euler = (0, 1.5708, 0)\n\n# Alternator\nbpy.ops.mesh.primitive_cylinder_add(radius=0.25, depth=0.4, location=(1.5, 1, 0.5))\nalternator = bpy.context.active_object\nalternator.name = \"Alternator\"\n\n# Water Pump\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.2, location=(-1.5, 0.8, 0.2))\nwater_pump = bpy.context.active_object\nwater_pump.name = \"WaterPump\"\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Create a collection for grouping\ncollection = bpy.data.collections.new(\"EngineAssembly\")\nbpy.context.scene.collection.children.link(collection)\n\n# Move all selected objects to the collection\nfor obj in bpy.context.selected_objects:\n    bpy.context.scene.collection.objects.unlink(obj)\n    collection.objects.link(obj)\n\n# Join all objects into one mesh\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True,\n    use_mesh_modifiers=True\n)\n```"
  },
  {
    "input": "acrylic filter",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create acrylic filter components\n# Main filter housing (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=0.3, location=(0, 0, 0))\nhousing = bpy.context.active_object\nhousing.name = \"Filter_Housing\"\n\n# Filter rim (torus-like effect using scaled cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2.2, depth=0.1, location=(0, 0, 0.2))\nrim = bpy.context.active_object\nrim.name = \"Filter_Rim\"\n\n# Filter threads (multiple small cylinders)\nthread_positions = [0.15, 0.1, 0.05, 0, -0.05, -0.1, -0.15]\nthreads = []\nfor i, z_pos in enumerate(thread_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=2.1, depth=0.02, location=(0, 0, z_pos))\n    thread = bpy.context.active_object\n    thread.name = f\"Filter_Thread_{i}\"\n    threads.append(thread)\n\n# Filter glass (thin cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.9, depth=0.05, location=(0, 0, 0))\nglass = bpy.context.active_object\nglass.name = \"Filter_Glass\"\n\n# Center mounting point (small cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.4, location=(0, 0, 0))\ncenter_mount = bpy.context.active_object\ncenter_mount.name = \"Center_Mount\"\n\n# Select all filter components\nbpy.ops.object.select_all(action='DESELECT')\nhousing.select_set(True)\nrim.select_set(True)\nglass.select_set(True)\ncenter_mount.select_set(True)\nfor thread in threads:\n    thread.select_set(True)\n\n# Set active object and join all parts\nbpy.context.view_layer.objects.active = housing\nbpy.ops.object.join()\n\n# Rename the joined object\nhousing.name = \"Acrylic_Filter\"\n\n# Export as ASCII STL\nexport_path = os.path.join(os.path.expanduser(\"~\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic floor",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create acrylic floor base\nbpy.ops.mesh.primitive_cube_add(size=2, enter_editmode=False, align='WORLD', location=(0, 0, 0))\nfloor_base = bpy.context.active_object\nfloor_base.name = \"Floor_Base\"\nfloor_base.scale = (5, 5, 0.1)\n\n# Create floor tiles pattern using cubes\ntile_positions = [\n    (-4, -4, 0.05), (-2, -4, 0.05), (0, -4, 0.05), (2, -4, 0.05), (4, -4, 0.05),\n    (-4, -2, 0.05), (-2, -2, 0.05), (0, -2, 0.05), (2, -2, 0.05), (4, -2, 0.05),\n    (-4, 0, 0.05), (-2, 0, 0.05), (0, 0, 0.05), (2, 0, 0.05), (4, 0, 0.05),\n    (-4, 2, 0.05), (-2, 2, 0.05), (0, 2, 0.05), (2, 2, 0.05), (4, 2, 0.05),\n    (-4, 4, 0.05), (-2, 4, 0.05), (0, 4, 0.05), (2, 4, 0.05), (4, 4, 0.05)\n]\n\ntiles = []\nfor i, pos in enumerate(tile_positions):\n    bpy.ops.mesh.primitive_cube_add(size=1.8, location=pos)\n    tile = bpy.context.active_object\n    tile.name = f\"Floor_Tile_{i}\"\n    tile.scale = (1, 1, 0.02)\n    tiles.append(tile)\n\n# Create floor edges using cylinders\nedge_positions = [\n    (-5, 0, 0.15, (0, 1.5708, 0)),  # Left edge\n    (5, 0, 0.15, (0, 1.5708, 0)),   # Right edge\n    (0, -5, 0.15, (1.5708, 0, 0)),  # Front edge\n    (0, 5, 0.15, (1.5708, 0, 0))    # Back edge\n]\n\nedges = []\nfor i, (x, y, z, rot) in enumerate(edge_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=10, location=(x, y, z), rotation=rot)\n    edge = bpy.context.active_object\n    edge.name = f\"Floor_Edge_{i}\"\n    edges.append(edge)\n\n# Create corner accents using spheres\ncorner_positions = [(-5, -5, 0.2), (5, -5, 0.2), (-5, 5, 0.2), (5, 5, 0.2)]\ncorners = []\nfor i, pos in enumerate(corner_positions):\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.15, location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"Floor_Corner_{i}\"\n    corners.append(corner)\n\n# Create center decorative element using cone\nbpy.ops.mesh.primitive_cone_add(radius1=0.3, radius2=0.1, depth=0.4, location=(0, 0, 0.4))\ncenter_cone = bpy.context.active_object\ncenter_cone.name = \"Floor_Center\"\n\n# Select all objects for grouping\nall_objects = [floor_base] + tiles + edges + corners + [center_cone]\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = floor_base\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Rename final object\nfloor_base.name = \"Acrylic_Floor\"\n\n# Export as ASCII STL\nexport_path = os.path.join(os.path.dirname(bpy.data.filepath) if bpy.data.filepath else \"/tmp\", \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=export_path, use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "acrylic fork",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create fork handle (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=2.0, location=(0, 0, 0))\nhandle = bpy.context.active_object\nhandle.name = \"Fork_Handle\"\n\n# Create fork head base (cube)\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0, 1.2))\nfork_head = bpy.context.active_object\nfork_head.name = \"Fork_Head\"\nfork_head.scale = (0.6, 0.15, 0.3)\n\n# Create fork prongs (cylinders)\nprong_positions = [(-0.2, 0, 1.6), (-0.067, 0, 1.6), (0.067, 0, 1.6), (0.2, 0, 1.6)]\nprongs = []\n\nfor i, pos in enumerate(prong_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.025, depth=0.8, location=pos)\n    prong = bpy.context.active_object\n    prong.name = f\"Fork_Prong_{i+1}\"\n    prongs.append(prong)\n\n# Select all fork parts\nbpy.ops.object.select_all(action='DESELECT')\nhandle.select_set(True)\nfork_head.select_set(True)\nfor prong in prongs:\n    prong.select_set(True)\n\n# Set active object and join all parts\nbpy.context.view_layer.objects.active = handle\nbpy.ops.object.join()\n\n# Rename the combined object\ncombined_fork = bpy.context.active_object\ncombined_fork.name = \"Acrylic_Fork\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic frame",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create acrylic frame components\nframe_parts = []\n\n# Main frame (outer rectangle)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nouter_frame = bpy.context.active_object\nouter_frame.name = \"outer_frame\"\nouter_frame.scale = (3, 2, 0.1)\nframe_parts.append(outer_frame)\n\n# Inner cutout (to create frame opening)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ninner_cutout = bpy.context.active_object\ninner_cutout.name = \"inner_cutout\"\ninner_cutout.scale = (2.5, 1.5, 0.15)\n\n# Apply boolean difference to create frame opening\nbool_modifier = outer_frame.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nbool_modifier.operation = 'DIFFERENCE'\nbool_modifier.object = inner_cutout\nbpy.context.view_layer.objects.active = outer_frame\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete the cutout object\nbpy.data.objects.remove(inner_cutout, do_unlink=True)\n\n# Create frame stand (back support)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -2, 0.5))\nstand = bpy.context.active_object\nstand.name = \"stand\"\nstand.scale = (0.1, 0.5, 1)\nstand.rotation_euler = (0.3, 0, 0)\nframe_parts.append(stand)\n\n# Create frame base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -1.5, -0.8))\nbase = bpy.context.active_object\nbase.name = \"base\"\nbase.scale = (1.5, 0.8, 0.1)\nframe_parts.append(base)\n\n# Create corner decorations using cylinders\ncorner_positions = [\n    (2.8, 1.8, 0),\n    (-2.8, 1.8, 0),\n    (2.8, -1.8, 0),\n    (-2.8, -1.8, 0)\n]\n\nfor i, pos in enumerate(corner_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.3, location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"corner_{i}\"\n    frame_parts.append(corner)\n\n# Select all frame parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in frame_parts:\n    part.select_set(True)\n\n# Set the first part as active\nbpy.context.view_layer.objects.active = frame_parts[0]\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Create collection and add the frame\ncollection = bpy.data.collections.new(\"Acrylic_Frame\")\nbpy.context.scene.collection.children.link(collection)\nacrylic_frame = bpy.context.active_object\nacrylic_frame.name = \"Acrylic_Frame\"\n\n# Move to collection\nbpy.context.scene.collection.objects.unlink(acrylic_frame)\ncollection.objects.link(acrylic_frame)\n\n# Export as ASCII STL\nfilepath = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=filepath,\n    use_selection=False,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic gear",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\nfrom mathutils import Vector\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create gear base cylinder\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=0.3, location=(0, 0, 0))\ngear_base = bpy.context.active_object\ngear_base.name = \"gear_base\"\n\n# Create center hole\nbpy.ops.mesh.primitive_cylinder_add(radius=0.4, depth=0.4, location=(0, 0, 0))\ncenter_hole = bpy.context.active_object\ncenter_hole.name = \"center_hole\"\n\n# Boolean difference to create hole\nmodifier = gear_base.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nmodifier.operation = 'DIFFERENCE'\nmodifier.object = center_hole\nbpy.context.view_layer.objects.active = gear_base\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete the hole object\nbpy.data.objects.remove(center_hole, do_unlink=True)\n\n# Create gear teeth\nnum_teeth = 20\ntooth_objects = []\n\nfor i in range(num_teeth):\n    angle = (2 * math.pi * i) / num_teeth\n    x = math.cos(angle) * 2.2\n    y = math.sin(angle) * 2.2\n    \n    # Create tooth using scaled cube\n    bpy.ops.mesh.primitive_cube_add(size=0.3, location=(x, y, 0))\n    tooth = bpy.context.active_object\n    tooth.name = f\"tooth_{i}\"\n    \n    # Scale tooth to be more tooth-like\n    tooth.scale[0] = 0.8\n    tooth.scale[1] = 0.3\n    tooth.scale[2] = 1.0\n    \n    # Rotate tooth to face outward\n    tooth.rotation_euler[2] = angle\n    \n    # Apply transforms\n    bpy.ops.object.transform_apply(location=False, rotation=True, scale=True)\n    \n    tooth_objects.append(tooth)\n\n# Join all teeth to gear base\nbpy.ops.object.select_all(action='DESELECT')\ngear_base.select_set(True)\nfor tooth in tooth_objects:\n    tooth.select_set(True)\n\nbpy.context.view_layer.objects.active = gear_base\nbpy.ops.object.join()\n\n# Add some decorative elements\n# Small cylinders as reinforcement\nfor i in range(8):\n    angle = (2 * math.pi * i) / 8\n    x = math.cos(angle) * 1.0\n    y = math.sin(angle) * 1.0\n    \n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.25, location=(x, y, 0))\n    reinforce = bpy.context.active_object\n    reinforce.name = f\"reinforce_{i}\"\n\n# Select all objects and join them\nbpy.ops.object.select_all(action='SELECT')\nbpy.context.view_layer.objects.active = gear_base\nbpy.ops.object.join()\n\n# Final gear object\nfinal_gear = bpy.context.active_object\nfinal_gear.name = \"acrylic_gear\"\n\n# Create collection and add gear to it\ncollection = bpy.data.collections.new(\"Gear_Collection\")\nbpy.context.scene.collection.children.link(collection)\nbpy.context.scene.collection.objects.unlink(final_gear)\ncollection.objects.link(final_gear)\n\n# Select the gear for export\nbpy.ops.object.select_all(action='DESELECT')\nfinal_gear.select_set(True)\nbpy.context.view_layer.objects.active = final_gear\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    check_existing=False,\n    ascii=True,\n    use_selection=True\n)\n```"
  },
  {
    "input": "acrylic glass",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create acrylic glass model using primitives\n# Main glass body (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(vertices=32, radius=1.5, depth=3, location=(0, 0, 1.5))\nglass_body = bpy.context.active_object\nglass_body.name = \"Glass_Body\"\n\n# Glass base (cylinder, flattened)\nbpy.ops.mesh.primitive_cylinder_add(vertices=32, radius=1.6, depth=0.2, location=(0, 0, 0.1))\nglass_base = bpy.context.active_object\nglass_base.name = \"Glass_Base\"\n\n# Glass rim (torus-like effect using scaled cylinder)\nbpy.ops.mesh.primitive_cylinder_add(vertices=32, radius=1.55, depth=0.15, location=(0, 0, 3.075))\nglass_rim = bpy.context.active_object\nglass_rim.name = \"Glass_Rim\"\n\n# Inner hollow space (cylinder for boolean difference effect)\nbpy.ops.mesh.primitive_cylinder_add(vertices=32, radius=1.35, depth=2.8, location=(0, 0, 1.6))\ninner_space = bpy.context.active_object\ninner_space.name = \"Inner_Space\"\n\n# Handle (torus)\nbpy.ops.mesh.primitive_torus_add(major_radius=0.8, minor_radius=0.1, location=(2.2, 0, 2))\nhandle = bpy.context.active_object\nhandle.name = \"Handle\"\n\n# Select all glass parts\nglass_parts = [glass_body, glass_base, glass_rim, inner_space, handle]\n\n# Deselect all first\nbpy.ops.object.select_all(action='DESELECT')\n\n# Select all glass parts\nfor part in glass_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = glass_body\n\n# Join all parts\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Acrylic_Glass\"\n\n# Apply boolean modifier to create hollow interior\nglass_obj = bpy.context.active_object\n\n# Add solidify modifier to create wall thickness\nsolidify_mod = glass_obj.modifiers.new(name=\"Solidify\", type='SOLIDIFY')\nsolidify_mod.thickness = 0.05\nsolidify_mod.offset = -1\n\n# Apply modifiers\nbpy.context.view_layer.objects.active = glass_obj\nbpy.ops.object.modifier_apply(modifier=\"Solidify\")\n\n# Export as STL\nexport_path = os.path.join(os.path.dirname(bpy.data.filepath) if bpy.data.filepath else os.path.expanduser(\"~\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=export_path, use_selection=True, ascii=True)\n\nprint(f\"Acrylic glass model exported to: {export_path}\")\n```"
  },
  {
    "input": "acrylic handle",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create handle shaft (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.5, depth=8, location=(0, 0, 0))\nhandle_shaft = bpy.context.active_object\nhandle_shaft.name = \"HandleShaft\"\n\n# Create handle grip section (slightly larger cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.6, depth=3, location=(0, 0, -1))\nhandle_grip = bpy.context.active_object\nhandle_grip.name = \"HandleGrip\"\n\n# Create handle end cap (sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.6, location=(0, 0, -4.5))\nend_cap = bpy.context.active_object\nend_cap.name = \"EndCap\"\n\n# Create handle top (cone for tapered end)\nbpy.ops.mesh.primitive_cone_add(radius1=0.5, radius2=0.3, depth=1, location=(0, 0, 4.5))\nhandle_top = bpy.context.active_object\nhandle_top.name = \"HandleTop\"\n\n# Create mounting ring (torus)\nbpy.ops.mesh.primitive_torus_add(major_radius=0.8, minor_radius=0.15, location=(0, 0, 3))\nmounting_ring = bpy.context.active_object\nmounting_ring.name = \"MountingRing\"\n\n# Create decorative bands (small cylinders)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.55, depth=0.2, location=(0, 0, 1))\nband1 = bpy.context.active_object\nband1.name = \"DecorativeBand1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.55, depth=0.2, location=(0, 0, -0.5))\nband2 = bpy.context.active_object\nband2.name = \"DecorativeBand2\"\n\n# Select all handle parts\nbpy.ops.object.select_all(action='DESELECT')\nhandle_parts = [handle_shaft, handle_grip, end_cap, handle_top, mounting_ring, band1, band2]\n\nfor part in handle_parts:\n    part.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = handle_shaft\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the combined object\ncombined_handle = bpy.context.active_object\ncombined_handle.name = \"AcrylicHandle\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    ascii=True,\n    use_selection=False\n)\n```"
  },
  {
    "input": "acrylic hinge",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create hinge parts\ndef create_hinge():\n    parts = []\n    \n    # Base plate 1\n    bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\n    base1 = bpy.context.active_object\n    base1.name = \"Base1\"\n    base1.scale = (2, 0.8, 0.1)\n    parts.append(base1)\n    \n    # Base plate 2\n    bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\n    base2 = bpy.context.active_object\n    base2.name = \"Base2\"\n    base2.scale = (2, 0.8, 0.1)\n    base2.location = (0, 0, 2.5)\n    parts.append(base2)\n    \n    # Hinge knuckle 1 (left)\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=1.2, location=(-1.5, 0, 0.4))\n    knuckle1 = bpy.context.active_object\n    knuckle1.name = \"Knuckle1\"\n    knuckle1.rotation_euler = (1.5708, 0, 0)\n    parts.append(knuckle1)\n    \n    # Hinge knuckle 2 (center)\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=1.2, location=(0, 0, 0.4))\n    knuckle2 = bpy.context.active_object\n    knuckle2.name = \"Knuckle2\"\n    knuckle2.rotation_euler = (1.5708, 0, 0)\n    parts.append(knuckle2)\n    \n    # Hinge knuckle 3 (right)\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=1.2, location=(1.5, 0, 0.4))\n    knuckle3 = bpy.context.active_object\n    knuckle3.name = \"Knuckle3\"\n    knuckle3.rotation_euler = (1.5708, 0, 0)\n    parts.append(knuckle3)\n    \n    # Hinge knuckle 4 (left, upper)\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=1.2, location=(-1.5, 0, 2.1))\n    knuckle4 = bpy.context.active_object\n    knuckle4.name = \"Knuckle4\"\n    knuckle4.rotation_euler = (1.5708, 0, 0)\n    parts.append(knuckle4)\n    \n    # Hinge knuckle 5 (right, upper)\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=1.2, location=(1.5, 0, 2.1))\n    knuckle5 = bpy.context.active_object\n    knuckle5.name = \"Knuckle5\"\n    knuckle5.rotation_euler = (1.5708, 0, 0)\n    parts.append(knuckle5)\n    \n    # Hinge pin\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=6, location=(0, 0, 1.25))\n    pin = bpy.context.active_object\n    pin.name = \"Pin\"\n    pin.rotation_euler = (0, 1.5708, 0)\n    parts.append(pin)\n    \n    # Screw holes (decorative cylinders)\n    positions = [(-1.5, 0.4, 0), (1.5, 0.4, 0), (-1.5, -0.4, 0), (1.5, -0.4, 0)]\n    for i, pos in enumerate(positions):\n        bpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.3, location=pos)\n        hole = bpy.context.active_object\n        hole.name = f\"Screw{i+1}\"\n        parts.append(hole)\n    \n    # Upper screw holes\n    positions = [(-1.5, 0.4, 2.5), (1.5, 0.4, 2.5), (-1.5, -0.4, 2.5), (1.5, -0.4, 2.5)]\n    for i, pos in enumerate(positions):\n        bpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.3, location=pos)\n        hole = bpy.context.active_object\n        hole.name = f\"ScrewUpper{i+1}\"\n        parts.append(hole)\n    \n    return parts\n\n# Create the hinge\nhinge_parts = create_hinge()\n\n# Group all parts together\nbpy.ops.object.select_all(action='DESELECT')\nfor part in hinge_parts:\n    part.select_set(True)\n\nbpy.context.view_layer.objects.active = hinge_parts[0]\nbpy.ops.object.join()\n\n# Export as STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "acrylic hood",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create acrylic hood components\nparts = []\n\n# Base platform\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nbase = bpy.context.active_object\nbase.name = \"Hood_Base\"\nbase.scale = (3, 2, 0.1)\nparts.append(base)\n\n# Main hood body (curved top)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1, location=(0, 0, 1.5))\nhood_body = bpy.context.active_object\nhood_body.name = \"Hood_Body\"\nhood_body.scale = (2.8, 1.8, 1.2)\n\n# Cut the sphere in half by removing bottom vertices\nbpy.context.view_layer.objects.active = hood_body\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='DESELECT')\nbpy.ops.mesh.select_all(action='SELECT')\nbpy.ops.mesh.bisect(plane_co=(0, 0, 0.3), plane_no=(0, 0, 1), clear_inner=True)\nbpy.ops.object.mode_set(mode='OBJECT')\nparts.append(hood_body)\n\n# Front panel (transparent acrylic)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -1.7, 0.8))\nfront_panel = bpy.context.active_object\nfront_panel.name = \"Front_Panel\"\nfront_panel.scale = (2.7, 0.05, 0.7)\nparts.append(front_panel)\n\n# Side panels\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-2.7, 0, 0.8))\nleft_panel = bpy.context.active_object\nleft_panel.name = \"Left_Panel\"\nleft_panel.scale = (0.05, 1.7, 0.7)\nparts.append(left_panel)\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(2.7, 0, 0.8))\nright_panel = bpy.context.active_object\nright_panel.name = \"Right_Panel\"\nright_panel.scale = (0.05, 1.7, 0.7)\nparts.append(right_panel)\n\n# Ventilation grilles (cylinders)\nfor i in range(3):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.3, location=((-1 + i), 1.8, 1.2))\n    vent = bpy.context.active_object\n    vent.name = f\"Vent_{i}\"\n    vent.rotation_euler = (1.5708, 0, 0)  # 90 degrees in radians\n    parts.append(vent)\n\n# Support legs\nfor i, pos in enumerate([(-2.5, -1.5, -0.5), (2.5, -1.5, -0.5), (-2.5, 1.5, -0.5), (2.5, 1.5, -0.5)]):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=1, location=pos)\n    leg = bpy.context.active_object\n    leg.name = f\"Support_Leg_{i}\"\n    parts.append(leg)\n\n# Control panel (small cube)\nbpy.ops.mesh.primitive_cube_add(size=0.5, location=(2.2, -1.7, 1.2))\ncontrol_panel = bpy.context.active_object\ncontrol_panel.name = \"Control_Panel\"\ncontrol_panel.scale = (0.3, 0.1, 0.2)\nparts.append(control_panel)\n\n# Light fixture (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=0.1, location=(0, 0, 2.4))\nlight = bpy.context.active_object\nlight.name = \"Light_Fixture\"\nparts.append(light)\n\n# Select all parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in parts:\n    part.select_set(True)\n\n# Set the last object as active\nbpy.context.view_layer.objects.active = parts[-1]\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the joined object\njoined_object = bpy.context.active_object\njoined_object.name = \"Acrylic_Hood\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic jar",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create jar body (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.0, depth=2.0, location=(0, 0, 1))\njar_body = bpy.context.active_object\njar_body.name = \"JarBody\"\n\n# Create jar opening (cylinder for boolean difference)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.9, depth=2.2, location=(0, 0, 1.1))\njar_hollow = bpy.context.active_object\njar_hollow.name = \"JarHollow\"\n\n# Boolean modifier to hollow out the jar\nmodifier = jar_body.modifiers.new(name=\"Hollow\", type='BOOLEAN')\nmodifier.operation = 'DIFFERENCE'\nmodifier.object = jar_hollow\n\n# Apply the boolean modifier\nbpy.context.view_layer.objects.active = jar_body\nbpy.ops.object.modifier_apply(modifier=\"Hollow\")\n\n# Delete the hollow cylinder\nbpy.data.objects.remove(jar_hollow, do_unlink=True)\n\n# Create jar lid (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.05, depth=0.2, location=(0, 0, 2.2))\njar_lid = bpy.context.active_object\njar_lid.name = \"JarLid\"\n\n# Create lid knob (sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.2, location=(0, 0, 2.4))\nlid_knob = bpy.context.active_object\nlid_knob.name = \"LidKnob\"\n\n# Create jar base (cylinder, slightly larger)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.02, depth=0.1, location=(0, 0, -0.05))\njar_base = bpy.context.active_object\njar_base.name = \"JarBase\"\n\n# Select all jar parts\njar_parts = [jar_body, jar_lid, lid_knob, jar_base]\nfor obj in jar_parts:\n    obj.select_set(True)\n\n# Join all parts into one object\nbpy.context.view_layer.objects.active = jar_body\nbpy.ops.object.join()\n\n# Rename the final object\njar_body.name = \"AcrylicJar\"\n\n# Export as ASCII STL\nexport_path = bpy.path.abspath(\"//duck.stl\")\nif not export_path.startswith(\"//\"):\n    export_path = os.path.join(os.path.expanduser(\"~\"), \"duck.stl\")\n\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=False,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic key",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create key blade (main flat part)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nkey_blade = bpy.context.active_object\nkey_blade.name = \"KeyBlade\"\nkey_blade.scale = (2, 0.1, 0.8)\n\n# Create key head (round part with hole)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=0.2, location=(-4, 0, 0))\nkey_head = bpy.context.active_object\nkey_head.name = \"KeyHead\"\n\n# Create keyhole in head\nbpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=0.3, location=(-4, 0, 0))\nkeyhole = bpy.context.active_object\nkeyhole.name = \"KeyHole\"\n\n# Boolean operation to cut hole\nmodifier = key_head.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nmodifier.operation = 'DIFFERENCE'\nmodifier.object = keyhole\nbpy.context.view_layer.objects.active = key_head\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete the keyhole object\nbpy.ops.object.select_all(action='DESELECT')\nkeyhole.select_set(True)\nbpy.ops.object.delete()\n\n# Create key teeth\nteeth_positions = [(1.5, 0, -0.4), (2.5, 0, -0.4), (3.5, 0, -0.4)]\nteeth_objects = []\n\nfor i, pos in enumerate(teeth_positions):\n    bpy.ops.mesh.primitive_cube_add(size=1, location=pos)\n    tooth = bpy.context.active_object\n    tooth.name = f\"KeyTooth_{i+1}\"\n    tooth.scale = (0.3, 0.1, 0.3 + i*0.1)\n    teeth_objects.append(tooth)\n\n# Create key tip\nbpy.ops.mesh.primitive_cone_add(radius1=0.1, depth=0.5, location=(4.5, 0, 0))\nkey_tip = bpy.context.active_object\nkey_tip.name = \"KeyTip\"\nkey_tip.rotation_euler = (0, 1.5708, 0)  # Rotate 90 degrees\n\n# Select all key parts\nbpy.ops.object.select_all(action='DESELECT')\nkey_parts = [key_blade, key_head, key_tip] + teeth_objects\n\nfor part in key_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = key_blade\n\n# Join all parts\nbpy.ops.object.join()\n\n# Rename the combined object\nbpy.context.active_object.name = \"AcrylicKey\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic knife",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create knife blade using scaled cube\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0))\nblade = bpy.context.active_object\nblade.name = \"Blade\"\nblade.scale = (0.05, 1.5, 0.3)\n\n# Create knife handle using cylinder\nbpy.ops.mesh.primitive_cylinder_add(location=(0, -2, 0), rotation=(1.5708, 0, 0))\nhandle = bpy.context.active_object\nhandle.name = \"Handle\"\nhandle.scale = (0.15, 0.8, 0.15)\n\n# Create guard between blade and handle using scaled cube\nbpy.ops.mesh.primitive_cube_add(location=(0, -0.8, 0))\nguard = bpy.context.active_object\nguard.name = \"Guard\"\nguard.scale = (0.2, 0.08, 0.35)\n\n# Create pommel at end of handle using sphere\nbpy.ops.mesh.primitive_uv_sphere_add(location=(0, -2.8, 0))\npommel = bpy.context.active_object\npommel.name = \"Pommel\"\npommel.scale = (0.18, 0.18, 0.18)\n\n# Select all knife parts\nbpy.ops.object.select_all(action='DESELECT')\nblade.select_set(True)\nhandle.select_set(True)\nguard.select_set(True)\npommel.select_set(True)\n\n# Set active object and join all parts\nbpy.context.view_layer.objects.active = blade\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"AcrylicKnife\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic knob",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create knob base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=0.8, location=(0, 0, 0))\nknob_base = bpy.context.active_object\nknob_base.name = \"KnobBase\"\n\n# Create knob top (cylinder, smaller)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=0.3, location=(0, 0, 0.55))\nknob_top = bpy.context.active_object\nknob_top.name = \"KnobTop\"\n\n# Create indicator line (cube, scaled to be thin)\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 1.0, 0.7))\nindicator = bpy.context.active_object\nindicator.name = \"Indicator\"\nindicator.scale = (0.1, 0.4, 0.1)\n\n# Create center shaft hole using cylinder (to be subtracted conceptually)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=1.2, location=(0, 0, 0))\nshaft_hole = bpy.context.active_object\nshaft_hole.name = \"ShaftHole\"\n\n# Create grip ridges using multiple small cylinders\nridge_objects = []\nfor i in range(8):\n    angle = i * 0.785398  # 45 degrees in radians\n    x = 1.4 * bpy.mathutils.Matrix.Rotation(angle, 3, 'Z')[0][0]\n    y = 1.4 * bpy.mathutils.Matrix.Rotation(angle, 3, 'Z')[0][1]\n    \n    bpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.4, location=(x, y, 0.4))\n    ridge = bpy.context.active_object\n    ridge.name = f\"Ridge_{i}\"\n    ridge_objects.append(ridge)\n\n# Select all objects for grouping\nbpy.ops.object.select_all(action='DESELECT')\nobjects_to_group = [knob_base, knob_top, indicator, shaft_hole] + ridge_objects\n\nfor obj in objects_to_group:\n    obj.select_set(True)\n\nknob_base.select_set(True)\nbpy.context.view_layer.objects.active = knob_base\n\n# Join all objects\nbpy.ops.object.join()\n\n# Export as STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nif not bpy.path.abspath(\"//\"):\n    export_path = os.path.expanduser(\"~/duck.stl\")\n\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=True,\n    ascii=True\n)\n\nprint(f\"Knob exported to: {export_path}\")\n```"
  },
  {
    "input": "acrylic lamp",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create lamp base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=0.3, location=(0, 0, 0.15))\nbase = bpy.context.active_object\nbase.name = \"lamp_base\"\n\n# Create lamp stem (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=3, location=(0, 0, 1.8))\nstem = bpy.context.active_object\nstem.name = \"lamp_stem\"\n\n# Create lamp shade holder (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.2, location=(0, 0, 3.4))\nholder = bpy.context.active_object\nholder.name = \"lamp_holder\"\n\n# Create acrylic shade (UV sphere, flattened)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, location=(0, 0, 4.2))\nshade = bpy.context.active_object\nshade.name = \"lamp_shade\"\nshade.scale[2] = 0.6  # Flatten the sphere\n\n# Create light bulb (smaller sphere inside)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.4, location=(0, 0, 4.0))\nbulb = bpy.context.active_object\nbulb.name = \"light_bulb\"\n\n# Create power cord (cylinder, rotated)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2, location=(1.2, 0, 0.15))\ncord = bpy.context.active_object\ncord.name = \"power_cord\"\ncord.rotation_euler[1] = 1.57  # Rotate 90 degrees\n\n# Select all lamp parts\nlamp_objects = [base, stem, holder, shade, bulb, cord]\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in lamp_objects:\n    obj.select_set(True)\n\n# Group objects by joining them\nbpy.context.view_layer.objects.active = base\nbpy.ops.object.join()\n\n# Export as ASCII STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=export_path, use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "acrylic lock",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create lock body (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=2.5, location=(0, 0, 0))\nlock_body = bpy.context.active_object\nlock_body.name = \"LockBody\"\n\n# Create shackle (U-shaped part using cylinders)\n# Left vertical part\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=1.8, rotation=(1.5708, 0, 0), location=(-0.7, 1.2, 0.6))\nshackle_left = bpy.context.active_object\nshackle_left.name = \"ShackleLeft\"\n\n# Right vertical part\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=1.8, rotation=(1.5708, 0, 0), location=(0.7, 1.2, 0.6))\nshackle_right = bpy.context.active_object\nshackle_right.name = \"ShackleRight\"\n\n# Top horizontal part\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=1.4, rotation=(0, 1.5708, 0), location=(0, 2.1, 0.6))\nshackle_top = bpy.context.active_object\nshackle_top.name = \"ShackleTop\"\n\n# Create keyhole using cylinder (will be a hole)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.3, rotation=(1.5708, 0, 0), location=(0, -1.3, 0))\nkeyhole = bpy.context.active_object\nkeyhole.name = \"Keyhole\"\n\n# Create lock mechanism details\n# Internal cylinder\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=1.5, location=(0, 0, 0))\ninner_cylinder = bpy.context.active_object\ninner_cylinder.name = \"InnerMechanism\"\n\n# Pin chambers (small cylinders)\nfor i in range(5):\n    x_pos = -0.6 + (i * 0.3)\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.8, location=(x_pos, 0, 1.5))\n    pin = bpy.context.active_object\n    pin.name = f\"Pin_{i+1}\"\n\n# Bottom plate\nbpy.ops.mesh.primitive_cube_add(scale=(1.3, 1.3, 0.1), location=(0, 0, -1.3))\nbottom_plate = bpy.context.active_object\nbottom_plate.name = \"BottomPlate\"\n\n# Select all objects for grouping\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"AcrylicLock\"\n\n# Export as ASCII STL\noutput_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=output_path, use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "acrylic mirror",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create acrylic mirror components\n# Main mirror surface (flattened cube)\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0))\nmirror_surface = bpy.context.active_object\nmirror_surface.name = \"Mirror_Surface\"\nmirror_surface.scale = (2, 2, 0.05)\n\n# Mirror frame (scaled cube around the mirror)\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, -0.1))\nmirror_frame = bpy.context.active_object\nmirror_frame.name = \"Mirror_Frame\"\nmirror_frame.scale = (2.2, 2.2, 0.1)\n\n# Stand base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, -0.5))\nstand_base = bpy.context.active_object\nstand_base.name = \"Stand_Base\"\nstand_base.scale = (1.5, 1.5, 0.3)\n\n# Stand arm (cylinder rotated)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, -1.5, 0.5))\nstand_arm = bpy.context.active_object\nstand_arm.name = \"Stand_Arm\"\nstand_arm.scale = (0.1, 0.1, 1)\nstand_arm.rotation_euler = (1.5708, 0, 0)\n\n# Adjustment joint (small sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(location=(0, -1.5, 0))\nadjustment_joint = bpy.context.active_object\nadjustment_joint.name = \"Adjustment_Joint\"\nadjustment_joint.scale = (0.2, 0.2, 0.2)\n\n# Select all created objects\nobjects_to_group = [mirror_surface, mirror_frame, stand_base, stand_arm, adjustment_joint]\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in objects_to_group:\n    obj.select_set(True)\n\n# Join all objects into one\nbpy.context.view_layer.objects.active = mirror_surface\nbpy.ops.object.join()\n\n# Apply transforms\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic motor",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create motor base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=1, location=(0, 0, 0))\nmotor_base = bpy.context.active_object\nmotor_base.name = \"motor_base\"\n\n# Create motor body (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=3, location=(0, 0, 2))\nmotor_body = bpy.context.active_object\nmotor_body.name = \"motor_body\"\n\n# Create motor top cap (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.6, depth=0.2, location=(0, 0, 3.6))\nmotor_cap = bpy.context.active_object\nmotor_cap.name = \"motor_cap\"\n\n# Create motor shaft (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=2, location=(0, 0, 4.6))\nmotor_shaft = bpy.context.active_object\nmotor_shaft.name = \"motor_shaft\"\n\n# Create cooling fins (scaled cubes)\nfins = []\nfor i in range(6):\n    angle = i * 60\n    x = 1.8 * bpy.data.objects['motor_body'].matrix_world.to_translation().x\n    y = 1.8 * bpy.data.objects['motor_body'].matrix_world.to_translation().y\n    bpy.ops.mesh.primitive_cube_add(size=0.1, location=(x + 1.8, y, 2))\n    fin = bpy.context.active_object\n    fin.name = f\"cooling_fin_{i}\"\n    fin.rotation_euler = (0, 0, bpy.data.scenes['Scene'].frame_current * angle * 3.14159 / 180)\n    fin.scale = (0.2, 2, 0.05)\n    fins.append(fin)\n\n# Create mounting bolts (cylinders)\nbolt_positions = [(1.7, 0, 0.5), (-1.7, 0, 0.5), (0, 1.7, 0.5), (0, -1.7, 0.5)]\nbolts = []\nfor i, pos in enumerate(bolt_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.3, location=pos)\n    bolt = bpy.context.active_object\n    bolt.name = f\"mounting_bolt_{i}\"\n    bolts.append(bolt)\n\n# Create wire terminals (cubes)\nbpy.ops.mesh.primitive_cube_add(size=0.3, location=(1.2, 1.2, 3))\nterminal1 = bpy.context.active_object\nterminal1.name = \"terminal_1\"\nterminal1.scale = (0.5, 0.3, 0.8)\n\nbpy.ops.mesh.primitive_cube_add(size=0.3, location=(-1.2, 1.2, 3))\nterminal2 = bpy.context.active_object\nterminal2.name = \"terminal_2\"\nterminal2.scale = (0.5, 0.3, 0.8)\n\n# Create ventilation holes (using scaled spheres as negative space representation)\nvent_holes = []\nfor i in range(8):\n    angle = i * 45 * 3.14159 / 180\n    x = 1.2 * bpy.data.scenes['Scene'].frame_current * angle\n    y = 1.2 * bpy.data.scenes['Scene'].frame_current * angle\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.15, location=(x, y, 2.5))\n    hole = bpy.context.active_object\n    hole.name = f\"vent_hole_{i}\"\n    vent_holes.append(hole)\n\n# Select all motor parts\nmotor_parts = [motor_base, motor_body, motor_cap, motor_shaft, terminal1, terminal2] + fins + bolts + vent_holes\n\nbpy.ops.object.select_all(action='DESELECT')\nfor part in motor_parts:\n    part.select_set(True)\n\n# Set the motor_base as active object for joining\nbpy.context.view_layer.objects.active = motor_base\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the final object\nmotor_base.name = \"acrylic_motor\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic mug",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\n\n# Delete all default objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create mug body (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=3, location=(0, 0, 1.5))\nmug_body = bpy.context.active_object\nmug_body.name = \"MugBody\"\n\n# Create inner cavity (cylinder to subtract)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.3, depth=2.8, location=(0, 0, 1.6))\ninner_cavity = bpy.context.active_object\ninner_cavity.name = \"InnerCavity\"\n\n# Create handle using torus\nbpy.ops.mesh.primitive_torus_add(major_radius=1, minor_radius=0.2, location=(2, 0, 1.5))\nhandle = bpy.context.active_object\nhandle.name = \"Handle\"\nhandle.rotation_euler = (0, 1.5708, 0)\n\n# Create bottom (cylinder for base)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.4, depth=0.2, location=(0, 0, 0.1))\nbottom = bpy.context.active_object\nbottom.name = \"Bottom\"\n\n# Boolean operation to create hollow mug\nbpy.context.view_layer.objects.active = mug_body\nmug_body.select_set(True)\ninner_cavity.select_set(True)\n\n# Add boolean modifier\nbool_modifier = mug_body.modifiers.new(type=\"BOOLEAN\", name=\"hollow\")\nbool_modifier.object = inner_cavity\nbool_modifier.operation = 'DIFFERENCE'\n\n# Apply boolean modifier\nbpy.context.view_layer.objects.active = mug_body\nbpy.ops.object.modifier_apply(modifier=\"hollow\")\n\n# Delete the inner cavity object\nbpy.data.objects.remove(inner_cavity, do_unlink=True)\n\n# Select all mug parts\nbpy.ops.object.select_all(action='DESELECT')\nmug_body.select_set(True)\nhandle.select_set(True)\nbottom.select_set(True)\n\n# Join all parts\nbpy.context.view_layer.objects.active = mug_body\nbpy.ops.object.join()\n\n# Create collection for organization\ncollection = bpy.data.collections.new(\"AcrylicMug\")\nbpy.context.scene.collection.children.link(collection)\ncollection.objects.link(mug_body)\nbpy.context.scene.collection.objects.unlink(mug_body)\n\n# Select the final object for export\nbpy.ops.object.select_all(action='DESELECT')\nmug_body.select_set(True)\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic nail",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create nail base (fingernail bed)\nbpy.ops.mesh.primitive_cylinder_add(vertices=16, radius=0.6, depth=0.1, location=(0, 0, 0))\nnail_base = bpy.context.active_object\nnail_base.name = \"NailBase\"\nnail_base.scale = (1, 1.5, 0.3)\n\n# Create nail extension (acrylic part)\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0.8, 0.05))\nnail_extension = bpy.context.active_object\nnail_extension.name = \"NailExtension\"\nnail_extension.scale = (0.6, 0.8, 0.08)\n\n# Create nail tip (rounded end)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.3, location=(0, 1.5, 0.05))\nnail_tip = bpy.context.active_object\nnail_tip.name = \"NailTip\"\nnail_tip.scale = (0.6, 0.4, 0.08)\n\n# Create cuticle area\nbpy.ops.mesh.primitive_cylinder_add(vertices=16, radius=0.4, depth=0.05, location=(0, -0.6, 0.02))\ncuticle = bpy.context.active_object\ncuticle.name = \"Cuticle\"\ncuticle.scale = (1, 0.8, 0.5)\n\n# Create finger tip base\nbpy.ops.mesh.primitive_cylinder_add(vertices=16, radius=0.5, depth=0.8, location=(0, -1.2, -0.2))\nfinger_base = bpy.context.active_object\nfinger_base.name = \"FingerBase\"\nfinger_base.scale = (1.1, 1.1, 1)\n\n# Select all nail parts\nnail_parts = [nail_base, nail_extension, nail_tip, cuticle, finger_base]\nbpy.ops.object.select_all(action='DESELECT')\nfor part in nail_parts:\n    part.select_set(True)\n\n# Join all parts\nbpy.context.view_layer.objects.active = nail_base\nbpy.ops.object.join()\n\n# Export as STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nif not bpy.path.abspath(\"//\"):\n    export_path = os.path.join(os.path.expanduser(\"~\"), \"duck.stl\")\n\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic paint",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create paint tube body (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=4.0, location=(0, 0, 0))\ntube_body = bpy.context.active_object\ntube_body.name = \"TubeBody\"\n\n# Create paint tube cap (cylinder, smaller)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.85, depth=0.3, location=(0, 0, 2.15))\ntube_cap = bpy.context.active_object\ntube_cap.name = \"TubeCap\"\n\n# Create nozzle (cone)\nbpy.ops.mesh.primitive_cone_add(radius1=0.3, radius2=0.15, depth=0.8, location=(0, 0, 2.7))\nnozzle = bpy.context.active_object\nnozzle.name = \"Nozzle\"\n\n# Create nozzle tip (small cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=0.2, location=(0, 0, 3.2))\nnozzle_tip = bpy.context.active_object\nnozzle_tip.name = \"NozzleTip\"\n\n# Create label area (cube, flattened)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, -0.5))\nlabel = bpy.context.active_object\nlabel.name = \"Label\"\nlabel.scale = (0.9, 1.8, 0.1)\n\n# Create bottom cap (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.85, depth=0.2, location=(0, 0, -2.1))\nbottom_cap = bpy.context.active_object\nbottom_cap.name = \"BottomCap\"\n\n# Select all objects for grouping\nobjects = [tube_body, tube_cap, nozzle, nozzle_tip, label, bottom_cap]\nbpy.ops.object.select_all(action='DESELECT')\n\nfor obj in objects:\n    obj.select_set(True)\n\n# Join all objects into one\nbpy.context.view_layer.objects.active = tube_body\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"AcrylicPaint\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic pan",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create pan base (flattened cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=0.3, location=(0, 0, 0))\npan_base = bpy.context.active_object\npan_base.name = \"Pan_Base\"\n\n# Create pan walls (cylinder with boolean difference)\nbpy.ops.mesh.primitive_cylinder_add(radius=2.1, depth=0.8, location=(0, 0, 0.4))\nouter_wall = bpy.context.active_object\nouter_wall.name = \"Outer_Wall\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=1.9, depth=1.0, location=(0, 0, 0.5))\ninner_wall = bpy.context.active_object\ninner_wall.name = \"Inner_Wall\"\n\n# Boolean difference to create hollow walls\nbool_mod = outer_wall.modifiers.new(type=\"BOOLEAN\", name=\"hollow\")\nbool_mod.object = inner_wall\nbool_mod.operation = 'DIFFERENCE'\n\n# Apply the modifier\nbpy.context.view_layer.objects.active = outer_wall\nbpy.ops.object.modifier_apply(modifier=\"hollow\")\n\n# Delete the inner wall helper\nbpy.data.objects.remove(inner_wall, do_unlink=True)\n\n# Create handle (elongated cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.15, depth=1.5, location=(2.8, 0, 0.3))\nhandle = bpy.context.active_object\nhandle.name = \"Handle\"\nhandle.rotation_euler = (0, 1.5708, 0)  # Rotate 90 degrees\n\n# Create handle attachment (small cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=0.3, location=(2.2, 0, 0.3))\nhandle_attach = bpy.context.active_object\nhandle_attach.name = \"Handle_Attach\"\nhandle_attach.rotation_euler = (0, 1.5708, 0)\n\n# Create spout (cone)\nbpy.ops.mesh.primitive_cone_add(radius1=0.3, radius2=0.15, depth=0.8, location=(-1.8, 1.2, 0.5))\nspout = bpy.context.active_object\nspout.name = \"Spout\"\nspout.rotation_euler = (0.5, 0, -0.7854)\n\n# Select all pan parts\npan_parts = [pan_base, outer_wall, handle, handle_attach, spout]\nfor obj in pan_parts:\n    obj.select_set(True)\n\nbpy.context.view_layer.objects.active = pan_base\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the final object\npan_base.name = \"Acrylic_Pan\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic panel",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create acrylic panel using primitives\npanel_parts = []\n\n# Main panel (scaled cube)\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0))\nmain_panel = bpy.context.active_object\nmain_panel.name = \"Panel_Main\"\nmain_panel.scale = (2, 1.5, 0.05)\nbpy.ops.object.transform_apply(transform=True, location=False, rotation=False, scale=True)\npanel_parts.append(main_panel)\n\n# Frame edges (4 cylinders)\n# Top edge\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 1.5, 0))\ntop_edge = bpy.context.active_object\ntop_edge.name = \"Panel_TopEdge\"\ntop_edge.scale = (2.1, 0.05, 0.1)\ntop_edge.rotation_euler = (0, 1.5708, 0)\nbpy.ops.object.transform_apply(transform=True, location=False, rotation=True, scale=True)\npanel_parts.append(top_edge)\n\n# Bottom edge\nbpy.ops.mesh.primitive_cylinder_add(location=(0, -1.5, 0))\nbottom_edge = bpy.context.active_object\nbottom_edge.name = \"Panel_BottomEdge\"\nbottom_edge.scale = (2.1, 0.05, 0.1)\nbottom_edge.rotation_euler = (0, 1.5708, 0)\nbpy.ops.object.transform_apply(transform=True, location=False, rotation=True, scale=True)\npanel_parts.append(bottom_edge)\n\n# Left edge\nbpy.ops.mesh.primitive_cylinder_add(location=(-2, 0, 0))\nleft_edge = bpy.context.active_object\nleft_edge.name = \"Panel_LeftEdge\"\nleft_edge.scale = (1.5, 0.05, 0.1)\nleft_edge.rotation_euler = (1.5708, 0, 0)\nbpy.ops.object.transform_apply(transform=True, location=False, rotation=True, scale=True)\npanel_parts.append(left_edge)\n\n# Right edge\nbpy.ops.mesh.primitive_cylinder_add(location=(2, 0, 0))\nright_edge = bpy.context.active_object\nright_edge.name = \"Panel_RightEdge\"\nright_edge.scale = (1.5, 0.05, 0.1)\nright_edge.rotation_euler = (1.5708, 0, 0)\nbpy.ops.object.transform_apply(transform=True, location=False, rotation=True, scale=True)\npanel_parts.append(right_edge)\n\n# Corner reinforcements (4 small cubes)\ncorners = [(-2, -1.5, 0), (2, -1.5, 0), (-2, 1.5, 0), (2, 1.5, 0)]\nfor i, corner_pos in enumerate(corners):\n    bpy.ops.mesh.primitive_cube_add(location=corner_pos)\n    corner = bpy.context.active_object\n    corner.name = f\"Panel_Corner_{i}\"\n    corner.scale = (0.1, 0.1, 0.15)\n    bpy.ops.object.transform_apply(transform=True, location=False, rotation=False, scale=True)\n    panel_parts.append(corner)\n\n# Mounting holes (4 cylinders subtracted from corners)\nfor i, corner_pos in enumerate(corners):\n    bpy.ops.mesh.primitive_cylinder_add(location=(corner_pos[0], corner_pos[1], 0))\n    hole = bpy.context.active_object\n    hole.name = f\"Panel_Hole_{i}\"\n    hole.scale = (0.05, 0.05, 0.2)\n    bpy.ops.object.transform_apply(transform=True, location=False, rotation=False, scale=True)\n    panel_parts.append(hole)\n\n# Select all parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in panel_parts:\n    part.select_set(True)\n\n# Join all parts\nbpy.context.view_layer.objects.active = panel_parts[0]\nbpy.ops.object.join()\n\n# Rename the final object\nfinal_panel = bpy.context.active_object\nfinal_panel.name = \"AcrylicPanel\"\n\n# Select the final object\nbpy.ops.object.select_all(action='DESELECT')\nfinal_panel.select_set(True)\nbpy.context.view_layer.objects.active = final_panel\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic picture",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create acrylic picture frame\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0), scale=(2, 1.5, 0.1))\nframe = bpy.context.active_object\nframe.name = \"Frame\"\n\n# Create picture backing\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, -0.08), scale=(1.8, 1.3, 0.02))\nbacking = bpy.context.active_object\nbacking.name = \"Backing\"\n\n# Create acrylic front panel\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0.08), scale=(1.9, 1.4, 0.01))\nacrylic = bpy.context.active_object\nacrylic.name = \"Acrylic\"\n\n# Create corner supports\ncorners = []\npositions = [(-1.7, -1.2, 0), (1.7, -1.2, 0), (1.7, 1.2, 0), (-1.7, 1.2, 0)]\nfor i, pos in enumerate(positions):\n    bpy.ops.mesh.primitive_cylinder_add(location=pos, scale=(0.05, 0.05, 0.15))\n    corner = bpy.context.active_object\n    corner.name = f\"Corner_{i}\"\n    corners.append(corner)\n\n# Create stand base\nbpy.ops.mesh.primitive_cube_add(location=(0, -1.8, -0.3), scale=(1.5, 0.3, 0.1))\nbase = bpy.context.active_object\nbase.name = \"Base\"\n\n# Create stand support\nbpy.ops.mesh.primitive_cube_add(location=(0, -1.2, -0.15), scale=(0.1, 0.5, 0.15))\nsupport = bpy.context.active_object\nsupport.name = \"Support\"\nsupport.rotation_euler = (0.3, 0, 0)\n\n# Create decorative elements on frame\nbpy.ops.mesh.primitive_cylinder_add(location=(-1.5, 1.0, 0.15), scale=(0.1, 0.1, 0.05))\ndeco1 = bpy.context.active_object\ndeco1.name = \"Decoration_1\"\n\nbpy.ops.mesh.primitive_cylinder_add(location=(1.5, 1.0, 0.15), scale=(0.1, 0.1, 0.05))\ndeco2 = bpy.context.active_object\ndeco2.name = \"Decoration_2\"\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects\nbpy.ops.object.join()\n\n# Rename the combined object\nbpy.context.active_object.name = \"Acrylic_Picture\"\n\n# Export as ASCII STL\noutput_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=output_path, use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "acrylic pillow",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create main pillow body - rounded cube\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0))\npillow_body = bpy.context.active_object\npillow_body.name = \"PillowBody\"\npillow_body.scale = (2, 1.5, 0.3)\n\n# Add subdivision surface modifier for rounded edges\nsubsurface = pillow_body.modifiers.new(name=\"Subsurface\", type='SUBSURF')\nsubsurface.levels = 2\n\n# Create corner reinforcements using small cylinders\ncorners = [\n    (1.8, 1.3, 0),\n    (-1.8, 1.3, 0),\n    (1.8, -1.3, 0),\n    (-1.8, -1.3, 0)\n]\n\ncorner_objects = []\nfor i, pos in enumerate(corners):\n    bpy.ops.mesh.primitive_cylinder_add(location=pos, rotation=(1.5708, 0, 0))\n    corner = bpy.context.active_object\n    corner.name = f\"Corner_{i}\"\n    corner.scale = (0.1, 0.3, 0.1)\n    corner_objects.append(corner)\n\n# Create edge reinforcements using cylinders\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 1.3, 0), rotation=(0, 0, 1.5708))\nedge_top = bpy.context.active_object\nedge_top.name = \"EdgeTop\"\nedge_top.scale = (0.05, 3.4, 0.05)\n\nbpy.ops.mesh.primitive_cylinder_add(location=(0, -1.3, 0), rotation=(0, 0, 1.5708))\nedge_bottom = bpy.context.active_object\nedge_bottom.name = \"EdgeBottom\"\nedge_bottom.scale = (0.05, 3.4, 0.05)\n\nbpy.ops.mesh.primitive_cylinder_add(location=(1.8, 0, 0), rotation=(1.5708, 0, 0))\nedge_right = bpy.context.active_object\nedge_right.name = \"EdgeRight\"\nedge_right.scale = (0.05, 0.05, 2.4)\n\nbpy.ops.mesh.primitive_cylinder_add(location=(-1.8, 0, 0), rotation=(1.5708, 0, 0))\nedge_left = bpy.context.active_object\nedge_left.name = \"EdgeLeft\"\nedge_left.scale = (0.05, 0.05, 2.4)\n\n# Create center seam using flattened cylinder\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, 0), rotation=(0, 1.5708, 0))\nseam = bpy.context.active_object\nseam.name = \"Seam\"\nseam.scale = (0.02, 1.8, 0.02)\n\n# Select all objects and join them\nbpy.ops.object.select_all(action='DESELECT')\npillow_body.select_set(True)\nfor corner in corner_objects:\n    corner.select_set(True)\nedge_top.select_set(True)\nedge_bottom.select_set(True)\nedge_right.select_set(True)\nedge_left.select_set(True)\nseam.select_set(True)\n\nbpy.context.view_layer.objects.active = pillow_body\nbpy.ops.object.join()\n\n# Apply all modifiers\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='SELECT')\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Export as STL\nfilepath = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=filepath, use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "acrylic pipe",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create main pipe body (outer cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.0, depth=6.0, location=(0, 0, 0))\nouter_cylinder = bpy.context.active_object\nouter_cylinder.name = \"pipe_outer\"\n\n# Create inner cylinder for hollow effect\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=6.2, location=(0, 0, 0))\ninner_cylinder = bpy.context.active_object\ninner_cylinder.name = \"pipe_inner\"\n\n# Create end caps (rings)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.05, depth=0.2, location=(0, 0, 3.1))\nend_cap1 = bpy.context.active_object\nend_cap1.name = \"end_cap1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=1.05, depth=0.2, location=(0, 0, -3.1))\nend_cap2 = bpy.context.active_object\nend_cap2.name = \"end_cap2\"\n\n# Create connector joints\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=0.5, location=(0, 0, 3.5))\nconnector1 = bpy.context.active_object\nconnector1.name = \"connector1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=0.5, location=(0, 0, -3.5))\nconnector2 = bpy.context.active_object\nconnector2.name = \"connector2\"\n\n# Boolean operation to hollow out the pipe\nbpy.context.view_layer.objects.active = outer_cylinder\nouter_cylinder.select_set(True)\ninner_cylinder.select_set(True)\n\nbool_modifier = outer_cylinder.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nbool_modifier.operation = 'DIFFERENCE'\nbool_modifier.object = inner_cylinder\n\n# Apply the boolean modifier\nbpy.context.view_layer.objects.active = outer_cylinder\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Hide inner cylinder\ninner_cylinder.hide_set(True)\n\n# Select all pipe components\npipe_objects = [outer_cylinder, end_cap1, end_cap2, connector1, connector2]\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in pipe_objects:\n    obj.select_set(True)\n\n# Join all objects\nbpy.context.view_layer.objects.active = outer_cylinder\nbpy.ops.object.join()\n\n# Rename final object\nfinal_pipe = bpy.context.active_object\nfinal_pipe.name = \"acrylic_pipe\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "acrylic plate",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create acrylic plate base\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0))\nplate = bpy.context.active_object\nplate.name = \"AcrylicPlate_Base\"\nplate.scale = (3, 2, 0.1)\n\n# Create frame edges\nbpy.ops.mesh.primitive_cube_add(location=(3.1, 0, 0))\nedge1 = bpy.context.active_object\nedge1.name = \"AcrylicPlate_Edge1\"\nedge1.scale = (0.1, 2.1, 0.2)\n\nbpy.ops.mesh.primitive_cube_add(location=(-3.1, 0, 0))\nedge2 = bpy.context.active_object\nedge2.name = \"AcrylicPlate_Edge2\"\nedge2.scale = (0.1, 2.1, 0.2)\n\nbpy.ops.mesh.primitive_cube_add(location=(0, 2.1, 0))\nedge3 = bpy.context.active_object\nedge3.name = \"AcrylicPlate_Edge3\"\nedge3.scale = (3, 0.1, 0.2)\n\nbpy.ops.mesh.primitive_cube_add(location=(0, -2.1, 0))\nedge4 = bpy.context.active_object\nedge4.name = \"AcrylicPlate_Edge4\"\nedge4.scale = (3, 0.1, 0.2)\n\n# Create corner reinforcements\nbpy.ops.mesh.primitive_cylinder_add(location=(2.9, 1.9, 0))\ncorner1 = bpy.context.active_object\ncorner1.name = \"AcrylicPlate_Corner1\"\ncorner1.scale = (0.15, 0.15, 0.3)\n\nbpy.ops.mesh.primitive_cylinder_add(location=(-2.9, 1.9, 0))\ncorner2 = bpy.context.active_object\ncorner2.name = \"AcrylicPlate_Corner2\"\ncorner2.scale = (0.15, 0.15, 0.3)\n\nbpy.ops.mesh.primitive_cylinder_add(location=(2.9, -1.9, 0))\ncorner3 = bpy.context.active_object\ncorner3.name = \"AcrylicPlate_Corner3\"\ncorner3.scale = (0.15, 0.15, 0.3)\n\nbpy.ops.mesh.primitive_cylinder_add(location=(-2.9, -1.9, 0))\ncorner4 = bpy.context.active_object\ncorner4.name = \"AcrylicPlate_Corner4\"\ncorner4.scale = (0.15, 0.15, 0.3)\n\n# Create mounting holes\nbpy.ops.mesh.primitive_cylinder_add(location=(2, 1.3, 0))\nhole1 = bpy.context.active_object\nhole1.name = \"AcrylicPlate_Hole1\"\nhole1.scale = (0.1, 0.1, 0.4)\n\nbpy.ops.mesh.primitive_cylinder_add(location=(-2, 1.3, 0))\nhole2 = bpy.context.active_object\nhole2.name = \"AcrylicPlate_Hole2\"\nhole2.scale = (0.1, 0.1, 0.4)\n\nbpy.ops.mesh.primitive_cylinder_add(location=(2, -1.3, 0))\nhole3 = bpy.context.active_object\nhole3.name = \"AcrylicPlate_Hole3\"\nhole3.scale = (0.1, 0.1, 0.4)\n\nbpy.ops.mesh.primitive_cylinder_add(location=(-2, -1.3, 0))\nhole4 = bpy.context.active_object\nhole4.name = \"AcrylicPlate_Hole4\"\nhole4.scale = (0.1, 0.1, 0.4)\n\n# Apply transforms to all objects\nobjects = [plate, edge1, edge2, edge3, edge4, corner1, corner2, corner3, corner4, hole1, hole2, hole3, hole4]\nfor obj in objects:\n    bpy.context.view_layer.objects.active = obj\n    bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Select all objects and join them\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in objects:\n    obj.select_set(True)\nbpy.context.view_layer.objects.active = plate\nbpy.ops.object.join()\n\n# Group the final object\nfinal_object = bpy.context.active_object\nfinal_object.name = \"AcrylicPlate\"\n\n# Export as STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_mesh_modifiers=True, ascii=True)\n```"
  }
]