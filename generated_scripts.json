[
  {
    "input": "abs bag",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create main bag body\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1))\nbag_body = bpy.context.active_object\nbag_body.name = \"bag_body\"\nbag_body.scale = (1.5, 0.8, 1.2)\n\n# Create bag bottom\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.2))\nbag_bottom = bpy.context.active_object\nbag_bottom.name = \"bag_bottom\"\nbag_bottom.scale = (1.4, 0.75, 0.1)\n\n# Create left handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=1.5, location=(-0.8, 0, 2.5))\nleft_handle = bpy.context.active_object\nleft_handle.name = \"left_handle\"\nleft_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create right handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=1.5, location=(0.8, 0, 2.5))\nright_handle = bpy.context.active_object\nright_handle.name = \"right_handle\"\nright_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create handle connectors\nbpy.ops.mesh.primitive_cube_add(size=0.2, location=(-0.8, 0, 2.2))\nleft_connector = bpy.context.active_object\nleft_connector.name = \"left_connector\"\nleft_connector.scale = (0.5, 1, 0.3)\n\nbpy.ops.mesh.primitive_cube_add(size=0.2, location=(0.8, 0, 2.2))\nright_connector = bpy.context.active_object\nright_connector.name = \"right_connector\"\nright_connector.scale = (0.5, 1, 0.3)\n\n# Create zipper detail\nbpy.ops.mesh.primitive_cylinder_add(radius=0.02, depth=2.5, location=(0, 0.6, 1.8))\nzipper = bpy.context.active_object\nzipper.name = \"zipper\"\nzipper.rotation_euler = (0, 1.5708, 0)\n\n# Create zipper pull\nbpy.ops.mesh.primitive_cube_add(size=0.1, location=(1.2, 0.6, 1.8))\nzipper_pull = bpy.context.active_object\nzipper_pull.name = \"zipper_pull\"\nzipper_pull.scale = (0.3, 0.5, 1)\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"abs_bag\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs basket",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create basket base\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=0.2, location=(0, 0, 0))\nbase = bpy.context.active_object\nbase.name = \"basket_base\"\n\n# Create basket walls\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=1.5, location=(0, 0, 0.85))\nwalls = bpy.context.active_object\nwalls.name = \"basket_walls\"\n\n# Make walls hollow by scaling inner faces\nbpy.context.view_layer.objects.active = walls\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='DESELECT')\nbm = bmesh.from_mesh(walls.data)\nbm.faces.ensure_lookup_table()\n\n# Select top face\nfor face in bm.faces:\n    if face.normal.z > 0.9:\n        face.select = True\n\nbmesh.update_edit_mesh(walls.data)\nbpy.ops.mesh.inset_faces(thickness=0.2)\nbpy.ops.mesh.delete(type='FACE')\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Create basket handle - left side\nbpy.ops.mesh.primitive_torus_add(major_radius=0.3, minor_radius=0.1, location=(-2.2, 0, 1.2))\nhandle_left = bpy.context.active_object\nhandle_left.name = \"handle_left\"\nhandle_left.rotation_euler = (0, 1.5708, 0)\n\n# Create basket handle - right side\nbpy.ops.mesh.primitive_torus_add(major_radius=0.3, minor_radius=0.1, location=(2.2, 0, 1.2))\nhandle_right = bpy.context.active_object\nhandle_right.name = \"handle_right\"\nhandle_right.rotation_euler = (0, 1.5708, 0)\n\n# Create handle connector\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=4.4, location=(0, 0, 1.2))\nhandle_connector = bpy.context.active_object\nhandle_connector.name = \"handle_connector\"\nhandle_connector.rotation_euler = (0, 1.5708, 0)\n\n# Create basket weave pattern with small cylinders\nweave_objects = []\nfor i in range(8):\n    angle = i * 0.785398  # 45 degrees in radians\n    x = 2.1 * bpy.context.scene.cursor.location[0] + 2.1 * (1 * bpy.context.scene.cursor.location[0] + 1) * 0.866025  # cos approximation\n    y = 2.1 * (1 * bpy.context.scene.cursor.location[1] + 1) * 0.5  # sin approximation\n    \n    # Vertical weave elements\n    for j in range(3):\n        z_pos = 0.3 + j * 0.5\n        bpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.4, location=(2.1, 0, z_pos))\n        weave = bpy.context.active_object\n        weave.rotation_euler = (0, 0, angle)\n        weave_objects.append(weave)\n\n# Select all basket parts\nbpy.ops.object.select_all(action='DESELECT')\nbase.select_set(True)\nwalls.select_set(True)\nhandle_left.select_set(True)\nhandle_right.select_set(True)\nhandle_connector.select_set(True)\n\nfor obj in weave_objects:\n    obj.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = base\n\n# Join all objects\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"basket\"\n\n# Export as STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nif not bpy.path.abspath(\"//\"):\n    export_path = os.path.expanduser(\"~/duck.stl\")\n\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=True,\n    ascii=True\n)\n\nprint(f\"Basket exported as: {export_path}\")\n```"
  },
  {
    "input": "abs beam",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create I-beam cross-section using primitives\nbeam_length = 4.0\nflange_width = 1.0\nflange_thickness = 0.2\nweb_height = 1.0\nweb_thickness = 0.15\n\n# Top flange\nbpy.ops.mesh.primitive_cube_add(\n    size=2,\n    location=(0, 0, web_height/2 + flange_thickness/2)\n)\ntop_flange = bpy.context.active_object\ntop_flange.scale = (beam_length/2, flange_width/2, flange_thickness/2)\ntop_flange.name = \"TopFlange\"\n\n# Bottom flange\nbpy.ops.mesh.primitive_cube_add(\n    size=2,\n    location=(0, 0, -web_height/2 - flange_thickness/2)\n)\nbottom_flange = bpy.context.active_object\nbottom_flange.scale = (beam_length/2, flange_width/2, flange_thickness/2)\nbottom_flange.name = \"BottomFlange\"\n\n# Web (vertical part)\nbpy.ops.mesh.primitive_cube_add(\n    size=2,\n    location=(0, 0, 0)\n)\nweb = bpy.context.active_object\nweb.scale = (beam_length/2, web_thickness/2, web_height/2)\nweb.name = \"Web\"\n\n# Select all beam parts\nbpy.ops.object.select_all(action='DESELECT')\ntop_flange.select_set(True)\nbottom_flange.select_set(True)\nweb.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = top_flange\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"IBeam\"\n\n# Create collection and add beam to it\ncollection = bpy.data.collections.new(\"BeamAssembly\")\nbpy.context.scene.collection.children.link(collection)\ncollection.objects.link(bpy.context.active_object)\nbpy.context.scene.collection.objects.unlink(bpy.context.active_object)\n\n# Export as STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    ascii=True,\n    use_selection=False\n)\n```"
  },
  {
    "input": "abs bed",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bed frame base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.1))\nbed_base = bpy.context.active_object\nbed_base.name = \"bed_base\"\nbed_base.scale = (2, 1.5, 0.1)\n\n# Create mattress\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.3))\nmattress = bpy.context.active_object\nmattress.name = \"mattress\"\nmattress.scale = (1.9, 1.4, 0.2)\n\n# Create headboard\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -1.4, 0.8))\nheadboard = bpy.context.active_object\nheadboard.name = \"headboard\"\nheadboard.scale = (1.9, 0.1, 0.6)\n\n# Create bed legs (4 cylinders)\nleg_positions = [(-3.5, -2, -0.4), (3.5, -2, -0.4), (-3.5, 2, -0.4), (3.5, 2, -0.4)]\nlegs = []\n\nfor i, pos in enumerate(leg_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.8, location=pos)\n    leg = bpy.context.active_object\n    leg.name = f\"leg_{i+1}\"\n    legs.append(leg)\n\n# Create pillow\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -0.8, 0.6))\npillow = bpy.context.active_object\npillow.name = \"pillow\"\npillow.scale = (0.8, 0.4, 0.15)\n\n# Select all bed parts for grouping\nbpy.ops.object.select_all(action='DESELECT')\nbed_parts = [bed_base, mattress, headboard, pillow] + legs\n\nfor part in bed_parts:\n    part.select_set(True)\n\n# Set active object for join operation\nbpy.context.view_layer.objects.active = bed_base\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs bin",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create the main bin body\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nbin_body = bpy.context.active_object\nbin_body.name = \"bin_body\"\nbin_body.scale = (1, 0.8, 0.6)\n\n# Create the bin interior (hollow out effect)\nbpy.ops.mesh.primitive_cube_add(size=1.8, location=(0, 0, 0.1))\nbin_interior = bpy.context.active_object\nbin_interior.name = \"bin_interior\"\nbin_interior.scale = (0.9, 0.7, 0.5)\n\n# Create bin handles - left handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.3, location=(-1.1, 0, 0.2))\nleft_handle = bpy.context.active_object\nleft_handle.name = \"left_handle\"\nleft_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create bin handles - right handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.3, location=(1.1, 0, 0.2))\nright_handle = bpy.context.active_object\nright_handle.name = \"right_handle\"\nright_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create handle supports - left\nbpy.ops.mesh.primitive_cube_add(size=0.1, location=(-1.05, 0, 0))\nleft_support = bpy.context.active_object\nleft_support.name = \"left_support\"\nleft_support.scale = (1, 1, 2)\n\n# Create handle supports - right\nbpy.ops.mesh.primitive_cube_add(size=0.1, location=(1.05, 0, 0))\nright_support = bpy.context.active_object\nright_support.name = \"right_support\"\nright_support.scale = (1, 1, 2)\n\n# Create bin feet\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(-0.7, -0.5, -0.65))\nfoot1 = bpy.context.active_object\nfoot1.name = \"foot1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(0.7, -0.5, -0.65))\nfoot2 = bpy.context.active_object\nfoot2.name = \"foot2\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(-0.7, 0.5, -0.65))\nfoot3 = bpy.context.active_object\nfoot3.name = \"foot3\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(0.7, 0.5, -0.65))\nfoot4 = bpy.context.active_object\nfoot4.name = \"foot4\"\n\n# Boolean operation to hollow out the bin\nbpy.context.view_layer.objects.active = bin_body\nbin_body.select_set(True)\nbin_interior.select_set(True)\n\nmodifier = bin_body.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nmodifier.operation = 'DIFFERENCE'\nmodifier.object = bin_interior\n\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete the interior object\nbpy.ops.object.select_all(action='DESELECT')\nbin_interior.select_set(True)\nbpy.ops.object.delete()\n\n# Select all remaining objects and join them\nbpy.ops.object.select_all(action='SELECT')\nbpy.context.view_layer.objects.active = bin_body\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"abs_bin\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "abs blanket",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create blanket using subdivided plane\nbpy.ops.mesh.primitive_plane_add(size=4, location=(0, 0, 0))\nblanket = bpy.context.active_object\nblanket.name = \"Blanket\"\n\n# Add subdivision surface modifier for smoothness\nblanket.modifiers.new(name=\"Subdivision\", type='SUBSURF')\nblanket.modifiers[\"Subdivision\"].levels = 2\n\n# Enter edit mode to add wave deformation\nbpy.context.view_layer.objects.active = blanket\nbpy.ops.object.mode_set(mode='EDIT')\n\n# Add more geometry for better deformation\nbpy.ops.mesh.subdivide(number_cuts=8)\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Add wave modifier for blanket-like appearance\nwave_modifier = blanket.modifiers.new(name=\"Wave\", type='WAVE')\nwave_modifier.use_x = True\nwave_modifier.use_y = True\nwave_modifier.height = 0.1\nwave_modifier.width = 1.0\nwave_modifier.speed = 0\n\n# Add displace modifier for more organic look\ndisplace_modifier = blanket.modifiers.new(name=\"Displace\", type='DISPLACE')\ndisplace_modifier.strength = 0.05\n\n# Create corner weights using spheres (to simulate blanket corners)\ncorners = []\ncorner_positions = [(-1.8, -1.8, -0.1), (1.8, -1.8, -0.1), (-1.8, 1.8, -0.1), (1.8, 1.8, -0.1)]\n\nfor i, pos in enumerate(corner_positions):\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.1, location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"Corner_{i+1}\"\n    corner.scale = (1, 1, 0.5)\n    corners.append(corner)\n\n# Create blanket edges using cylinders\nedges = []\nedge_configs = [\n    ((0, -2, 0), (0, 0, 1.57), (2, 0.05, 0.05)),  # front edge\n    ((0, 2, 0), (0, 0, 1.57), (2, 0.05, 0.05)),   # back edge\n    ((-2, 0, 0), (0, 0, 0), (2, 0.05, 0.05)),     # left edge\n    ((2, 0, 0), (0, 0, 0), (2, 0.05, 0.05))       # right edge\n]\n\nfor i, (pos, rot, scale) in enumerate(edge_configs):\n    bpy.ops.mesh.primitive_cylinder_add(radius=1, depth=1, location=pos)\n    edge = bpy.context.active_object\n    edge.name = f\"Edge_{i+1}\"\n    edge.rotation_euler = rot\n    edge.scale = scale\n    edges.append(edge)\n\n# Select all blanket objects\nall_objects = [blanket] + corners + edges\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set blanket as active object\nbpy.context.view_layer.objects.active = blanket\n\n# Join all objects\nbpy.ops.object.join()\n\n# Create collection and add the blanket\ncollection = bpy.data.collections.new(\"Blanket_Collection\")\nbpy.context.scene.collection.children.link(collection)\ncollection.objects.link(blanket)\nbpy.context.scene.collection.objects.unlink(blanket)\n\n# Apply all modifiers\nbpy.context.view_layer.objects.active = blanket\nfor modifier in blanket.modifiers:\n    bpy.ops.object.modifier_apply(modifier=modifier.name)\n\n# Export as ASCII STL\nfilepath = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=filepath, use_selection=False, ascii=True)\n```"
  },
  {
    "input": "abs bolt",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bolt head (hexagonal approximation using cylinder)\nbpy.ops.mesh.primitive_cylinder_add(vertices=6, radius=0.4, depth=0.2, location=(0, 0, 0.1))\nbolt_head = bpy.context.active_object\nbolt_head.name = \"BoltHead\"\n\n# Create bolt shaft\nbpy.ops.mesh.primitive_cylinder_add(vertices=16, radius=0.15, depth=2.0, location=(0, 0, -1.0))\nbolt_shaft = bpy.context.active_object\nbolt_shaft.name = \"BoltShaft\"\n\n# Create thread ridges using scaled toruses\nthread_positions = [-0.2, -0.4, -0.6, -0.8, -1.0, -1.2, -1.4, -1.6, -1.8]\nthread_objects = []\n\nfor i, z_pos in enumerate(thread_positions):\n    bpy.ops.mesh.primitive_torus_add(major_radius=0.18, minor_radius=0.03, location=(0, 0, z_pos))\n    thread = bpy.context.active_object\n    thread.name = f\"Thread_{i}\"\n    thread_objects.append(thread)\n\n# Create bolt tip (cone)\nbpy.ops.mesh.primitive_cone_add(radius1=0.15, radius2=0.05, depth=0.3, location=(0, 0, -2.15))\nbolt_tip = bpy.context.active_object\nbolt_tip.name = \"BoltTip\"\n\n# Select all bolt parts\nall_objects = [bolt_head, bolt_shaft, bolt_tip] + thread_objects\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set the active object to bolt_head for joining\nbpy.context.view_layer.objects.active = bolt_head\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Bolt\"\n\n# Select the bolt for export\nbolt = bpy.context.active_object\nbolt.select_set(True)\nbpy.context.view_layer.objects.active = bolt\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  }
]