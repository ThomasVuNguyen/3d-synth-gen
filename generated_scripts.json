[
  {
    "input": "abs bag",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create main bag body\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1))\nbag_body = bpy.context.active_object\nbag_body.name = \"bag_body\"\nbag_body.scale = (1.5, 0.8, 1.2)\n\n# Create bag bottom\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.2))\nbag_bottom = bpy.context.active_object\nbag_bottom.name = \"bag_bottom\"\nbag_bottom.scale = (1.4, 0.75, 0.1)\n\n# Create left handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=1.5, location=(-0.8, 0, 2.5))\nleft_handle = bpy.context.active_object\nleft_handle.name = \"left_handle\"\nleft_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create right handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=1.5, location=(0.8, 0, 2.5))\nright_handle = bpy.context.active_object\nright_handle.name = \"right_handle\"\nright_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create handle connectors\nbpy.ops.mesh.primitive_cube_add(size=0.2, location=(-0.8, 0, 2.2))\nleft_connector = bpy.context.active_object\nleft_connector.name = \"left_connector\"\nleft_connector.scale = (0.5, 1, 0.3)\n\nbpy.ops.mesh.primitive_cube_add(size=0.2, location=(0.8, 0, 2.2))\nright_connector = bpy.context.active_object\nright_connector.name = \"right_connector\"\nright_connector.scale = (0.5, 1, 0.3)\n\n# Create zipper detail\nbpy.ops.mesh.primitive_cylinder_add(radius=0.02, depth=2.5, location=(0, 0.6, 1.8))\nzipper = bpy.context.active_object\nzipper.name = \"zipper\"\nzipper.rotation_euler = (0, 1.5708, 0)\n\n# Create zipper pull\nbpy.ops.mesh.primitive_cube_add(size=0.1, location=(1.2, 0.6, 1.8))\nzipper_pull = bpy.context.active_object\nzipper_pull.name = \"zipper_pull\"\nzipper_pull.scale = (0.3, 0.5, 1)\n\n# Select all objects\nbpy.ops.object.select_all(action='SELECT')\n\n# Join all objects into one\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"abs_bag\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs basket",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create basket base\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=0.2, location=(0, 0, 0))\nbase = bpy.context.active_object\nbase.name = \"basket_base\"\n\n# Create basket walls\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=1.5, location=(0, 0, 0.85))\nwalls = bpy.context.active_object\nwalls.name = \"basket_walls\"\n\n# Make walls hollow by scaling inner faces\nbpy.context.view_layer.objects.active = walls\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='DESELECT')\nbm = bmesh.from_mesh(walls.data)\nbm.faces.ensure_lookup_table()\n\n# Select top face\nfor face in bm.faces:\n    if face.normal.z > 0.9:\n        face.select = True\n\nbmesh.update_edit_mesh(walls.data)\nbpy.ops.mesh.inset_faces(thickness=0.2)\nbpy.ops.mesh.delete(type='FACE')\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Create basket handle - left side\nbpy.ops.mesh.primitive_torus_add(major_radius=0.3, minor_radius=0.1, location=(-2.2, 0, 1.2))\nhandle_left = bpy.context.active_object\nhandle_left.name = \"handle_left\"\nhandle_left.rotation_euler = (0, 1.5708, 0)\n\n# Create basket handle - right side\nbpy.ops.mesh.primitive_torus_add(major_radius=0.3, minor_radius=0.1, location=(2.2, 0, 1.2))\nhandle_right = bpy.context.active_object\nhandle_right.name = \"handle_right\"\nhandle_right.rotation_euler = (0, 1.5708, 0)\n\n# Create handle connector\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=4.4, location=(0, 0, 1.2))\nhandle_connector = bpy.context.active_object\nhandle_connector.name = \"handle_connector\"\nhandle_connector.rotation_euler = (0, 1.5708, 0)\n\n# Create basket weave pattern with small cylinders\nweave_objects = []\nfor i in range(8):\n    angle = i * 0.785398  # 45 degrees in radians\n    x = 2.1 * bpy.context.scene.cursor.location[0] + 2.1 * (1 * bpy.context.scene.cursor.location[0] + 1) * 0.866025  # cos approximation\n    y = 2.1 * (1 * bpy.context.scene.cursor.location[1] + 1) * 0.5  # sin approximation\n    \n    # Vertical weave elements\n    for j in range(3):\n        z_pos = 0.3 + j * 0.5\n        bpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.4, location=(2.1, 0, z_pos))\n        weave = bpy.context.active_object\n        weave.rotation_euler = (0, 0, angle)\n        weave_objects.append(weave)\n\n# Select all basket parts\nbpy.ops.object.select_all(action='DESELECT')\nbase.select_set(True)\nwalls.select_set(True)\nhandle_left.select_set(True)\nhandle_right.select_set(True)\nhandle_connector.select_set(True)\n\nfor obj in weave_objects:\n    obj.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = base\n\n# Join all objects\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"basket\"\n\n# Export as STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nif not bpy.path.abspath(\"//\"):\n    export_path = os.path.expanduser(\"~/duck.stl\")\n\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=True,\n    ascii=True\n)\n\nprint(f\"Basket exported as: {export_path}\")\n```"
  },
  {
    "input": "abs beam",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create I-beam cross-section using primitives\nbeam_length = 4.0\nflange_width = 1.0\nflange_thickness = 0.2\nweb_height = 1.0\nweb_thickness = 0.15\n\n# Top flange\nbpy.ops.mesh.primitive_cube_add(\n    size=2,\n    location=(0, 0, web_height/2 + flange_thickness/2)\n)\ntop_flange = bpy.context.active_object\ntop_flange.scale = (beam_length/2, flange_width/2, flange_thickness/2)\ntop_flange.name = \"TopFlange\"\n\n# Bottom flange\nbpy.ops.mesh.primitive_cube_add(\n    size=2,\n    location=(0, 0, -web_height/2 - flange_thickness/2)\n)\nbottom_flange = bpy.context.active_object\nbottom_flange.scale = (beam_length/2, flange_width/2, flange_thickness/2)\nbottom_flange.name = \"BottomFlange\"\n\n# Web (vertical part)\nbpy.ops.mesh.primitive_cube_add(\n    size=2,\n    location=(0, 0, 0)\n)\nweb = bpy.context.active_object\nweb.scale = (beam_length/2, web_thickness/2, web_height/2)\nweb.name = \"Web\"\n\n# Select all beam parts\nbpy.ops.object.select_all(action='DESELECT')\ntop_flange.select_set(True)\nbottom_flange.select_set(True)\nweb.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = top_flange\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"IBeam\"\n\n# Create collection and add beam to it\ncollection = bpy.data.collections.new(\"BeamAssembly\")\nbpy.context.scene.collection.children.link(collection)\ncollection.objects.link(bpy.context.active_object)\nbpy.context.scene.collection.objects.unlink(bpy.context.active_object)\n\n# Export as STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    ascii=True,\n    use_selection=False\n)\n```"
  },
  {
    "input": "abs bed",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bed frame base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.1))\nbed_base = bpy.context.active_object\nbed_base.name = \"bed_base\"\nbed_base.scale = (2, 1.5, 0.1)\n\n# Create mattress\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.3))\nmattress = bpy.context.active_object\nmattress.name = \"mattress\"\nmattress.scale = (1.9, 1.4, 0.2)\n\n# Create headboard\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -1.4, 0.8))\nheadboard = bpy.context.active_object\nheadboard.name = \"headboard\"\nheadboard.scale = (1.9, 0.1, 0.6)\n\n# Create bed legs (4 cylinders)\nleg_positions = [(-3.5, -2, -0.4), (3.5, -2, -0.4), (-3.5, 2, -0.4), (3.5, 2, -0.4)]\nlegs = []\n\nfor i, pos in enumerate(leg_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.8, location=pos)\n    leg = bpy.context.active_object\n    leg.name = f\"leg_{i+1}\"\n    legs.append(leg)\n\n# Create pillow\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -0.8, 0.6))\npillow = bpy.context.active_object\npillow.name = \"pillow\"\npillow.scale = (0.8, 0.4, 0.15)\n\n# Select all bed parts for grouping\nbpy.ops.object.select_all(action='DESELECT')\nbed_parts = [bed_base, mattress, headboard, pillow] + legs\n\nfor part in bed_parts:\n    part.select_set(True)\n\n# Set active object for join operation\nbpy.context.view_layer.objects.active = bed_base\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs bin",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create the main bin body\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\nbin_body = bpy.context.active_object\nbin_body.name = \"bin_body\"\nbin_body.scale = (1, 0.8, 0.6)\n\n# Create the bin interior (hollow out effect)\nbpy.ops.mesh.primitive_cube_add(size=1.8, location=(0, 0, 0.1))\nbin_interior = bpy.context.active_object\nbin_interior.name = \"bin_interior\"\nbin_interior.scale = (0.9, 0.7, 0.5)\n\n# Create bin handles - left handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.3, location=(-1.1, 0, 0.2))\nleft_handle = bpy.context.active_object\nleft_handle.name = \"left_handle\"\nleft_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create bin handles - right handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.3, location=(1.1, 0, 0.2))\nright_handle = bpy.context.active_object\nright_handle.name = \"right_handle\"\nright_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create handle supports - left\nbpy.ops.mesh.primitive_cube_add(size=0.1, location=(-1.05, 0, 0))\nleft_support = bpy.context.active_object\nleft_support.name = \"left_support\"\nleft_support.scale = (1, 1, 2)\n\n# Create handle supports - right\nbpy.ops.mesh.primitive_cube_add(size=0.1, location=(1.05, 0, 0))\nright_support = bpy.context.active_object\nright_support.name = \"right_support\"\nright_support.scale = (1, 1, 2)\n\n# Create bin feet\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(-0.7, -0.5, -0.65))\nfoot1 = bpy.context.active_object\nfoot1.name = \"foot1\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(0.7, -0.5, -0.65))\nfoot2 = bpy.context.active_object\nfoot2.name = \"foot2\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(-0.7, 0.5, -0.65))\nfoot3 = bpy.context.active_object\nfoot3.name = \"foot3\"\n\nbpy.ops.mesh.primitive_cylinder_add(radius=0.08, depth=0.1, location=(0.7, 0.5, -0.65))\nfoot4 = bpy.context.active_object\nfoot4.name = \"foot4\"\n\n# Boolean operation to hollow out the bin\nbpy.context.view_layer.objects.active = bin_body\nbin_body.select_set(True)\nbin_interior.select_set(True)\n\nmodifier = bin_body.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nmodifier.operation = 'DIFFERENCE'\nmodifier.object = bin_interior\n\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete the interior object\nbpy.ops.object.select_all(action='DESELECT')\nbin_interior.select_set(True)\nbpy.ops.object.delete()\n\n# Select all remaining objects and join them\nbpy.ops.object.select_all(action='SELECT')\nbpy.context.view_layer.objects.active = bin_body\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"abs_bin\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(filepath=\"duck.stl\", use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "abs blanket",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create blanket using subdivided plane\nbpy.ops.mesh.primitive_plane_add(size=4, location=(0, 0, 0))\nblanket = bpy.context.active_object\nblanket.name = \"Blanket\"\n\n# Add subdivision surface modifier for smoothness\nblanket.modifiers.new(name=\"Subdivision\", type='SUBSURF')\nblanket.modifiers[\"Subdivision\"].levels = 2\n\n# Enter edit mode to add wave deformation\nbpy.context.view_layer.objects.active = blanket\nbpy.ops.object.mode_set(mode='EDIT')\n\n# Add more geometry for better deformation\nbpy.ops.mesh.subdivide(number_cuts=8)\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Add wave modifier for blanket-like appearance\nwave_modifier = blanket.modifiers.new(name=\"Wave\", type='WAVE')\nwave_modifier.use_x = True\nwave_modifier.use_y = True\nwave_modifier.height = 0.1\nwave_modifier.width = 1.0\nwave_modifier.speed = 0\n\n# Add displace modifier for more organic look\ndisplace_modifier = blanket.modifiers.new(name=\"Displace\", type='DISPLACE')\ndisplace_modifier.strength = 0.05\n\n# Create corner weights using spheres (to simulate blanket corners)\ncorners = []\ncorner_positions = [(-1.8, -1.8, -0.1), (1.8, -1.8, -0.1), (-1.8, 1.8, -0.1), (1.8, 1.8, -0.1)]\n\nfor i, pos in enumerate(corner_positions):\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.1, location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"Corner_{i+1}\"\n    corner.scale = (1, 1, 0.5)\n    corners.append(corner)\n\n# Create blanket edges using cylinders\nedges = []\nedge_configs = [\n    ((0, -2, 0), (0, 0, 1.57), (2, 0.05, 0.05)),  # front edge\n    ((0, 2, 0), (0, 0, 1.57), (2, 0.05, 0.05)),   # back edge\n    ((-2, 0, 0), (0, 0, 0), (2, 0.05, 0.05)),     # left edge\n    ((2, 0, 0), (0, 0, 0), (2, 0.05, 0.05))       # right edge\n]\n\nfor i, (pos, rot, scale) in enumerate(edge_configs):\n    bpy.ops.mesh.primitive_cylinder_add(radius=1, depth=1, location=pos)\n    edge = bpy.context.active_object\n    edge.name = f\"Edge_{i+1}\"\n    edge.rotation_euler = rot\n    edge.scale = scale\n    edges.append(edge)\n\n# Select all blanket objects\nall_objects = [blanket] + corners + edges\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set blanket as active object\nbpy.context.view_layer.objects.active = blanket\n\n# Join all objects\nbpy.ops.object.join()\n\n# Create collection and add the blanket\ncollection = bpy.data.collections.new(\"Blanket_Collection\")\nbpy.context.scene.collection.children.link(collection)\ncollection.objects.link(blanket)\nbpy.context.scene.collection.objects.unlink(blanket)\n\n# Apply all modifiers\nbpy.context.view_layer.objects.active = blanket\nfor modifier in blanket.modifiers:\n    bpy.ops.object.modifier_apply(modifier=modifier.name)\n\n# Export as ASCII STL\nfilepath = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=filepath, use_selection=False, ascii=True)\n```"
  },
  {
    "input": "abs bolt",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bolt head (hexagonal approximation using cylinder)\nbpy.ops.mesh.primitive_cylinder_add(vertices=6, radius=0.4, depth=0.2, location=(0, 0, 0.1))\nbolt_head = bpy.context.active_object\nbolt_head.name = \"BoltHead\"\n\n# Create bolt shaft\nbpy.ops.mesh.primitive_cylinder_add(vertices=16, radius=0.15, depth=2.0, location=(0, 0, -1.0))\nbolt_shaft = bpy.context.active_object\nbolt_shaft.name = \"BoltShaft\"\n\n# Create thread ridges using scaled toruses\nthread_positions = [-0.2, -0.4, -0.6, -0.8, -1.0, -1.2, -1.4, -1.6, -1.8]\nthread_objects = []\n\nfor i, z_pos in enumerate(thread_positions):\n    bpy.ops.mesh.primitive_torus_add(major_radius=0.18, minor_radius=0.03, location=(0, 0, z_pos))\n    thread = bpy.context.active_object\n    thread.name = f\"Thread_{i}\"\n    thread_objects.append(thread)\n\n# Create bolt tip (cone)\nbpy.ops.mesh.primitive_cone_add(radius1=0.15, radius2=0.05, depth=0.3, location=(0, 0, -2.15))\nbolt_tip = bpy.context.active_object\nbolt_tip.name = \"BoltTip\"\n\n# Select all bolt parts\nall_objects = [bolt_head, bolt_shaft, bolt_tip] + thread_objects\nfor obj in all_objects:\n    obj.select_set(True)\n\n# Set the active object to bolt_head for joining\nbpy.context.view_layer.objects.active = bolt_head\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Bolt\"\n\n# Select the bolt for export\nbolt = bpy.context.active_object\nbolt.select_set(True)\nbpy.context.view_layer.objects.active = bolt\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs bottle",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bottle body (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=4, location=(0, 0, 0))\nbottle_body = bpy.context.active_object\nbottle_body.name = \"BottleBody\"\nbottle_body.scale = (0.8, 0.8, 1.2)\n\n# Create bottle neck (smaller cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.4, depth=1, location=(0, 0, 2.8))\nbottle_neck = bpy.context.active_object\nbottle_neck.name = \"BottleNeck\"\n\n# Create bottle cap (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.45, depth=0.3, location=(0, 0, 3.4))\nbottle_cap = bpy.context.active_object\nbottle_cap.name = \"BottleCap\"\n\n# Create bottle bottom (flattened sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.8, location=(0, 0, -2.2))\nbottle_bottom = bpy.context.active_object\nbottle_bottom.name = \"BottleBottom\"\nbottle_bottom.scale = (1, 1, 0.3)\n\n# Create label area (flattened cube)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0.85, 0))\nlabel = bpy.context.active_object\nlabel.name = \"Label\"\nlabel.scale = (0.6, 0.05, 0.8)\n\n# Select all bottle parts\nbottle_parts = [bottle_body, bottle_neck, bottle_cap, bottle_bottom, label]\nbpy.ops.object.select_all(action='DESELECT')\n\nfor part in bottle_parts:\n    part.select_set(True)\n\n# Set the first object as active\nbpy.context.view_layer.objects.active = bottle_body\n\n# Join all parts\nbpy.ops.object.join()\n\n# Rename the joined object\nbottle_body.name = \"AbsBottle\"\n\n# Apply all transforms\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Export as ASCII STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=export_path, use_mesh_modifiers=True, ascii=True)\n```"
  },
  {
    "input": "abs bowl",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bowl base using UV sphere\nbpy.ops.mesh.primitive_uv_sphere_add(location=(0, 0, 0), scale=(2, 2, 1.5))\nbowl_base = bpy.context.active_object\nbowl_base.name = \"Bowl_Base\"\n\n# Enter edit mode and delete top half to create bowl shape\nbpy.context.view_layer.objects.active = bowl_base\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='DESELECT')\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Use boolean modifier approach - create inner sphere to hollow out\nbpy.ops.mesh.primitive_uv_sphere_add(location=(0, 0, 0.2), scale=(1.7, 1.7, 1.3))\ninner_sphere = bpy.context.active_object\ninner_sphere.name = \"Inner_Sphere\"\n\n# Add boolean modifier to bowl base\nbowl_base.select_set(True)\nbpy.context.view_layer.objects.active = bowl_base\nbool_modifier = bowl_base.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nbool_modifier.operation = 'DIFFERENCE'\nbool_modifier.object = inner_sphere\n\n# Apply boolean modifier\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete inner sphere\nbpy.data.objects.remove(inner_sphere, do_unlink=True)\n\n# Create bowl rim using torus\nbpy.ops.mesh.primitive_torus_add(location=(0, 0, 1.2), major_radius=2, minor_radius=0.1)\nbowl_rim = bpy.context.active_object\nbowl_rim.name = \"Bowl_Rim\"\n\n# Select both objects and join them\nbowl_base.select_set(True)\nbowl_rim.select_set(True)\nbpy.context.view_layer.objects.active = bowl_base\nbpy.ops.object.join()\n\n# Rename final object\nbowl_base.name = \"Bowl\"\n\n# Create collection and add bowl to it\ncollection = bpy.data.collections.new(\"Bowl_Collection\")\nbpy.context.scene.collection.children.link(collection)\nbpy.context.scene.collection.objects.unlink(bowl_base)\ncollection.objects.link(bowl_base)\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=False,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs box",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create abs box parts\nparts = []\n\n# Main box body\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0))\nmain_box = bpy.context.active_object\nmain_box.name = \"MainBox\"\nmain_box.scale = (2, 1.5, 0.3)\nparts.append(main_box)\n\n# Top cover (slightly smaller)\nbpy.ops.mesh.primitive_cube_add(location=(0, 0, 0.35))\ntop_cover = bpy.context.active_object\ntop_cover.name = \"TopCover\"\ntop_cover.scale = (1.9, 1.4, 0.1)\nparts.append(top_cover)\n\n# Corner reinforcements\ncorner_positions = [\n    (1.8, 1.3, 0),\n    (-1.8, 1.3, 0),\n    (1.8, -1.3, 0),\n    (-1.8, -1.3, 0)\n]\n\nfor i, pos in enumerate(corner_positions):\n    bpy.ops.mesh.primitive_cylinder_add(location=pos)\n    corner = bpy.context.active_object\n    corner.name = f\"Corner_{i}\"\n    corner.scale = (0.1, 0.1, 0.3)\n    parts.append(corner)\n\n# Mounting holes (cylinders to subtract)\nhole_positions = [\n    (1.5, 1, 0),\n    (-1.5, 1, 0),\n    (1.5, -1, 0),\n    (-1.5, -1, 0)\n]\n\nfor i, pos in enumerate(hole_positions):\n    bpy.ops.mesh.primitive_cylinder_add(location=pos)\n    hole = bpy.context.active_object\n    hole.name = f\"MountHole_{i}\"\n    hole.scale = (0.08, 0.08, 0.4)\n    parts.append(hole)\n\n# LED indicator\nbpy.ops.mesh.primitive_cylinder_add(location=(1.6, 0, 0.36))\nled = bpy.context.active_object\nled.name = \"LED\"\nled.scale = (0.05, 0.05, 0.02)\nparts.append(led)\n\n# Ventilation grilles (small cylinders)\nfor x in range(-3, 4):\n    for y in range(-2, 3):\n        bpy.ops.mesh.primitive_cylinder_add(location=(x * 0.3, y * 0.3, 0.31))\n        vent = bpy.context.active_object\n        vent.name = f\"Vent_{x}_{y}\"\n        vent.scale = (0.03, 0.03, 0.05)\n        parts.append(vent)\n\n# Connector port\nbpy.ops.mesh.primitive_cube_add(location=(0, -1.6, 0))\nconnector = bpy.context.active_object\nconnector.name = \"Connector\"\nconnector.scale = (0.3, 0.2, 0.15)\nparts.append(connector)\n\n# Select all parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = parts[0]\n\n# Join all parts\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs bulb",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create bulb components\n# Main bulb body (sphere)\nbpy.ops.mesh.primitive_uv_sphere_add(location=(0, 0, 0), scale=(1, 1, 1.2))\nbulb_body = bpy.context.active_object\nbulb_body.name = \"BulbBody\"\n\n# Screw threads base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, -1.4), scale=(0.6, 0.6, 0.4))\nscrew_base = bpy.context.active_object\nscrew_base.name = \"ScrewBase\"\n\n# Screw threads detail (smaller cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, -1.7), scale=(0.55, 0.55, 0.15))\nscrew_threads = bpy.context.active_object\nscrew_threads.name = \"ScrewThreads\"\n\n# Contact point at bottom (small cylinder)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, -1.95), scale=(0.15, 0.15, 0.1))\ncontact_point = bpy.context.active_object\ncontact_point.name = \"ContactPoint\"\n\n# Filament support (thin cylinder inside bulb)\nbpy.ops.mesh.primitive_cylinder_add(location=(0, 0, -0.3), scale=(0.02, 0.02, 0.8))\nfilament_support = bpy.context.active_object\nfilament_support.name = \"FilamentSupport\"\n\n# Select all bulb parts\nbulb_parts = [bulb_body, screw_base, screw_threads, contact_point, filament_support]\nfor obj in bulb_parts:\n    obj.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = bulb_body\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the final object\nbulb_body.name = \"LightBulb\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs cabinet",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cabinet frame (main body)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1))\ncabinet_body = bpy.context.active_object\ncabinet_body.name = \"Cabinet_Body\"\ncabinet_body.scale = (1.5, 0.8, 2)\n\n# Create cabinet door\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-1.45, 0, 1))\ncabinet_door = bpy.context.active_object\ncabinet_door.name = \"Cabinet_Door\"\ncabinet_door.scale = (0.05, 0.75, 1.8)\n\n# Create door handle\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.3, location=(-1.3, 0.3, 1.2))\ndoor_handle = bpy.context.active_object\ndoor_handle.name = \"Door_Handle\"\ndoor_handle.rotation_euler = (1.5708, 0, 0)\n\n# Create cabinet top\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 3.1))\ncabinet_top = bpy.context.active_object\ncabinet_top.name = \"Cabinet_Top\"\ncabinet_top.scale = (1.6, 0.9, 0.1)\n\n# Create cabinet bottom/base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, -1.1))\ncabinet_bottom = bpy.context.active_object\ncabinet_bottom.name = \"Cabinet_Bottom\"\ncabinet_bottom.scale = (1.6, 0.9, 0.1)\n\n# Create left side panel\nbpy.ops.mesh.primitive_cube_add(size=2, location=(1.45, 0, 1))\nleft_panel = bpy.context.active_object\nleft_panel.name = \"Left_Panel\"\nleft_panel.scale = (0.05, 0.75, 1.8)\n\n# Create right side panel\nbpy.ops.mesh.primitive_cube_add(size=2, location=(-1.45, -0.65, 1))\nright_panel = bpy.context.active_object\nright_panel.name = \"Right_Panel\"\nright_panel.scale = (1.4, 0.05, 1.8)\n\n# Create back panel\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0.75, 1))\nback_panel = bpy.context.active_object\nback_panel.name = \"Back_Panel\"\nback_panel.scale = (1.4, 0.05, 1.8)\n\n# Create shelf inside\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0.5))\nshelf = bpy.context.active_object\nshelf.name = \"Shelf\"\nshelf.scale = (1.4, 0.7, 0.05)\n\n# Create cabinet legs (4 cylinders)\nleg_positions = [\n    (1.2, 0.5, -1.5),\n    (1.2, -0.5, -1.5),\n    (-1.2, 0.5, -1.5),\n    (-1.2, -0.5, -1.5)\n]\n\nlegs = []\nfor i, pos in enumerate(leg_positions):\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.1, depth=0.8, location=pos)\n    leg = bpy.context.active_object\n    leg.name = f\"Cabinet_Leg_{i+1}\"\n    legs.append(leg)\n\n# Select all cabinet parts\ncabinet_parts = [cabinet_body, cabinet_door, door_handle, cabinet_top, \n                cabinet_bottom, left_panel, right_panel, back_panel, shelf] + legs\n\nbpy.ops.object.select_all(action='DESELECT')\nfor part in cabinet_parts:\n    part.select_set(True)\n\n# Join all parts into one object\nbpy.context.view_layer.objects.active = cabinet_body\nbpy.ops.object.join()\n\n# Export as ASCII STL\nexport_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(\n    filepath=export_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs cable",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create ABS cable components\ncable_parts = []\n\n# Main cable body (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2.0, location=(0, 0, 0))\ncable_body = bpy.context.active_object\ncable_body.name = \"cable_body\"\ncable_parts.append(cable_body)\n\n# Cable connector housing (cube scaled)\nbpy.ops.mesh.primitive_cube_add(size=0.3, location=(-1.2, 0, 0))\nconnector1 = bpy.context.active_object\nconnector1.name = \"connector1\"\nconnector1.scale = (0.8, 0.6, 0.4)\ncable_parts.append(connector1)\n\n# Other end connector (cube scaled)\nbpy.ops.mesh.primitive_cube_add(size=0.25, location=(1.2, 0, 0))\nconnector2 = bpy.context.active_object\nconnector2.name = \"connector2\"\nconnector2.scale = (0.6, 0.5, 0.3)\ncable_parts.append(connector2)\n\n# Cable strain relief 1 (cone)\nbpy.ops.mesh.primitive_cone_add(radius1=0.08, radius2=0.05, depth=0.2, location=(-0.9, 0, 0))\nstrain_relief1 = bpy.context.active_object\nstrain_relief1.name = \"strain_relief1\"\nstrain_relief1.rotation_euler = (0, 1.5708, 0)\ncable_parts.append(strain_relief1)\n\n# Cable strain relief 2 (cone)\nbpy.ops.mesh.primitive_cone_add(radius1=0.07, radius2=0.05, depth=0.15, location=(0.9, 0, 0))\nstrain_relief2 = bpy.context.active_object\nstrain_relief2.name = \"strain_relief2\"\nstrain_relief2.rotation_euler = (0, -1.5708, 0)\ncable_parts.append(strain_relief2)\n\n# Connector pins (small cylinders)\nfor i in range(4):\n    x_pos = -1.35 + (i * 0.05)\n    bpy.ops.mesh.primitive_cylinder_add(radius=0.01, depth=0.1, location=(x_pos, 0, 0))\n    pin = bpy.context.active_object\n    pin.name = f\"pin_{i}\"\n    pin.rotation_euler = (0, 1.5708, 0)\n    cable_parts.append(pin)\n\n# Select all cable parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in cable_parts:\n    part.select_set(True)\n\n# Set active object for grouping\nbpy.context.view_layer.objects.active = cable_parts[0]\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Get the final object\ncable_assembly = bpy.context.active_object\ncable_assembly.name = \"abs_cable\"\n\n# Select the cable assembly\nbpy.ops.object.select_all(action='DESELECT')\ncable_assembly.select_set(True)\nbpy.context.view_layer.objects.active = cable_assembly\n\n# Export as ASCII STL\noutput_path = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nif bpy.path.abspath(\"//\") == \"\":\n    output_path = \"duck.stl\"\n\nbpy.ops.export_mesh.stl(\n    filepath=output_path,\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs carpet",
    "output": "```python\nimport bpy\nimport bmesh\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create carpet base\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncarpet_base = bpy.context.active_object\ncarpet_base.name = \"carpet_base\"\ncarpet_base.scale = (3, 2, 0.05)\n\n# Create carpet fibers using cylinders\nfiber_objects = []\nfor x in range(-15, 16, 2):\n    for y in range(-10, 11, 2):\n        bpy.ops.mesh.primitive_cylinder_add(\n            radius=0.02, \n            depth=0.15, \n            location=(x*0.2, y*0.2, 0.1)\n        )\n        fiber = bpy.context.active_object\n        fiber.name = f\"fiber_{x}_{y}\"\n        fiber_objects.append(fiber)\n\n# Create carpet edges using cubes\nedge_objects = []\n# Front and back edges\nfor i in range(2):\n    y_pos = 2 if i == 0 else -2\n    bpy.ops.mesh.primitive_cube_add(location=(0, y_pos, 0.08))\n    edge = bpy.context.active_object\n    edge.name = f\"edge_front_back_{i}\"\n    edge.scale = (3, 0.05, 0.08)\n    edge_objects.append(edge)\n\n# Left and right edges\nfor i in range(2):\n    x_pos = 3 if i == 0 else -3\n    bpy.ops.mesh.primitive_cube_add(location=(x_pos, 0, 0.08))\n    edge = bpy.context.active_object\n    edge.name = f\"edge_left_right_{i}\"\n    edge.scale = (0.05, 2, 0.08)\n    edge_objects.append(edge)\n\n# Select all carpet parts\nbpy.ops.object.select_all(action='DESELECT')\ncarpet_base.select_set(True)\nfor fiber in fiber_objects:\n    fiber.select_set(True)\nfor edge in edge_objects:\n    edge.select_set(True)\n\n# Set carpet_base as active object for grouping\nbpy.context.view_layer.objects.active = carpet_base\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs chain",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create abs chain links\nchain_parts = []\n\n# Create multiple chain links\nfor i in range(5):\n    # Main link body (torus-like shape using scaled cylinder)\n    bpy.ops.mesh.primitive_cylinder_add(\n        radius=0.8, \n        depth=0.3, \n        location=(i * 2.5, 0, 0)\n    )\n    link_outer = bpy.context.active_object\n    link_outer.name = f\"link_outer_{i}\"\n    \n    # Inner hole (cylinder to subtract - represented as smaller cylinder)\n    bpy.ops.mesh.primitive_cylinder_add(\n        radius=0.5, \n        depth=0.4, \n        location=(i * 2.5, 0, 0)\n    )\n    link_inner = bpy.context.active_object\n    link_inner.name = f\"link_inner_{i}\"\n    \n    # Rotate every other link 90 degrees to create interlocking pattern\n    if i % 2 == 1:\n        link_outer.rotation_euler = (0, 0, 1.5708)  # 90 degrees in radians\n        link_inner.rotation_euler = (0, 0, 1.5708)\n    \n    # Side reinforcements (small cylinders)\n    for side in [-1, 1]:\n        bpy.ops.mesh.primitive_cylinder_add(\n            radius=0.15, \n            depth=0.6, \n            location=(i * 2.5, side * 0.65, 0)\n        )\n        reinforcement = bpy.context.active_object\n        reinforcement.name = f\"reinforcement_{i}_{side}\"\n        if i % 2 == 1:\n            reinforcement.rotation_euler = (1.5708, 0, 0)  # 90 degrees\n            reinforcement.location = (i * 2.5, 0, side * 0.65)\n        \n        chain_parts.append(reinforcement)\n    \n    chain_parts.extend([link_outer, link_inner])\n\n# Add connecting elements between links\nfor i in range(4):\n    if i % 2 == 0:\n        # Horizontal connector\n        bpy.ops.mesh.primitive_cube_add(\n            size=0.3,\n            location=((i + 0.5) * 2.5, 0, 0)\n        )\n    else:\n        # Vertical connector\n        bpy.ops.mesh.primitive_cube_add(\n            size=0.3,\n            location=((i + 0.5) * 2.5, 0, 0)\n        )\n        bpy.context.active_object.rotation_euler = (0, 0, 1.5708)\n    \n    connector = bpy.context.active_object\n    connector.name = f\"connector_{i}\"\n    chain_parts.append(connector)\n\n# Add end caps\nfor end in [0, 4]:\n    bpy.ops.mesh.primitive_uv_sphere_add(\n        radius=0.4,\n        location=(end * 2.5, 0, 0)\n    )\n    cap = bpy.context.active_object\n    cap.name = f\"end_cap_{end}\"\n    chain_parts.append(cap)\n\n# Select all chain parts\nbpy.ops.object.select_all(action='DESELECT')\nfor part in chain_parts:\n    part.select_set(True)\n\n# Set active object\nbpy.context.view_layer.objects.active = chain_parts[0]\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the combined object\ncombined_chain = bpy.context.active_object\ncombined_chain.name = \"abs_chain\"\n\n# Center the chain\nbpy.ops.object.origin_set(type='GEOMETRY_ORIGIN', center='BOUNDS')\ncombined_chain.location = (0, 0, 0)\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs chair",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create chair seat\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1))\nseat = bpy.context.active_object\nseat.name = \"Chair_Seat\"\nseat.scale = (1.2, 1.2, 0.1)\n\n# Create chair back\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, -1.1, 1.8))\nback = bpy.context.active_object\nback.name = \"Chair_Back\"\nback.scale = (1.2, 0.1, 0.9)\n\n# Create front left leg\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2, location=(-1, 1, 0))\nleg1 = bpy.context.active_object\nleg1.name = \"Chair_Leg_FL\"\n\n# Create front right leg\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2, location=(1, 1, 0))\nleg2 = bpy.context.active_object\nleg2.name = \"Chair_Leg_FR\"\n\n# Create back left leg\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2, location=(-1, -1, 0))\nleg3 = bpy.context.active_object\nleg3.name = \"Chair_Leg_BL\"\n\n# Create back right leg\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=2, location=(1, -1, 0))\nleg4 = bpy.context.active_object\nleg4.name = \"Chair_Leg_BR\"\n\n# Select all chair parts\nchair_parts = [seat, back, leg1, leg2, leg3, leg4]\nbpy.ops.object.select_all(action='DESELECT')\nfor part in chair_parts:\n    part.select_set(True)\n\n# Set seat as active object for joining\nbpy.context.view_layer.objects.active = seat\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"Chair\"\n\n# Export as ASCII STL\nfilepath = os.path.join(bpy.path.abspath(\"//\"), \"duck.stl\")\nbpy.ops.export_mesh.stl(filepath=filepath, use_selection=True, ascii=True)\n```"
  },
  {
    "input": "abs clock",
    "output": "```python\nimport bpy\nimport bmesh\nimport mathutils\nfrom mathutils import Vector\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create clock face (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=0.2, location=(0, 0, 0))\nclock_face = bpy.context.active_object\nclock_face.name = \"clock_face\"\n\n# Create clock frame (torus)\nbpy.ops.mesh.primitive_torus_add(major_radius=2.1, minor_radius=0.1, location=(0, 0, 0))\nclock_frame = bpy.context.active_object\nclock_frame.name = \"clock_frame\"\n\n# Create hour hand\nbpy.ops.mesh.primitive_cube_add(size=0.05, location=(0, 0.6, 0.15))\nbpy.ops.transform.resize(value=(1, 12, 1))\nhour_hand = bpy.context.active_object\nhour_hand.name = \"hour_hand\"\nhour_hand.rotation_euler = (0, 0, math.radians(30))\n\n# Create minute hand\nbpy.ops.mesh.primitive_cube_add(size=0.04, location=(0, 0.8, 0.17))\nbpy.ops.transform.resize(value=(1, 20, 1))\nminute_hand = bpy.context.active_object\nminute_hand.name = \"minute_hand\"\nminute_hand.rotation_euler = (0, 0, math.radians(90))\n\n# Create center pin\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=0.4, location=(0, 0, 0.2))\ncenter_pin = bpy.context.active_object\ncenter_pin.name = \"center_pin\"\n\n# Create hour markers\nhour_markers = []\nfor i in range(12):\n    angle = i * math.radians(30)\n    x = 1.7 * math.cos(angle)\n    y = 1.7 * math.sin(angle)\n    bpy.ops.mesh.primitive_cube_add(size=0.1, location=(x, y, 0.12))\n    marker = bpy.context.active_object\n    marker.name = f\"hour_marker_{i+1}\"\n    hour_markers.append(marker)\n\n# Create pendulum support\nbpy.ops.mesh.primitive_cylinder_add(radius=0.05, depth=1.5, location=(0, 0, -0.75))\npendulum_support = bpy.context.active_object\npendulum_support.name = \"pendulum_support\"\n\n# Create pendulum weight\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.3, location=(0, 0, -1.5))\npendulum_weight = bpy.context.active_object\npendulum_weight.name = \"pendulum_weight\"\n\n# Select all clock parts\nclock_parts = [clock_face, clock_frame, hour_hand, minute_hand, center_pin, pendulum_support, pendulum_weight] + hour_markers\n\nbpy.ops.object.select_all(action='DESELECT')\nfor part in clock_parts:\n    part.select_set(True)\n\n# Set active object for grouping\nbpy.context.view_layer.objects.active = clock_face\n\n# Join all parts\nbpy.ops.object.join()\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs column",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create column base\nbpy.ops.mesh.primitive_cylinder_add(radius=1.5, depth=0.3, location=(0, 0, 0.15))\nbase = bpy.context.active_object\nbase.name = \"Column_Base\"\n\n# Create column shaft\nbpy.ops.mesh.primitive_cylinder_add(radius=0.8, depth=8, location=(0, 0, 4.5))\nshaft = bpy.context.active_object\nshaft.name = \"Column_Shaft\"\n\n# Create column capital (top)\nbpy.ops.mesh.primitive_cylinder_add(radius=1.2, depth=0.5, location=(0, 0, 9))\ncapital = bpy.context.active_object\ncapital.name = \"Column_Capital\"\n\n# Create decorative top\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 9.5))\ntop_decoration = bpy.context.active_object\ntop_decoration.name = \"Column_Top\"\ntop_decoration.scale[2] = 0.2\n\n# Add some decorative elements to the shaft\nfor i in range(3):\n    z_pos = 2 + (i * 2)\n    bpy.ops.mesh.primitive_torus_add(major_radius=0.9, minor_radius=0.1, location=(0, 0, z_pos))\n    ring = bpy.context.active_object\n    ring.name = f\"Decorative_Ring_{i+1}\"\n\n# Select all column parts\ncolumn_objects = [obj for obj in bpy.context.scene.objects if obj.type == 'MESH']\nfor obj in column_objects:\n    obj.select_set(True)\n\n# Set the first object as active\nbpy.context.view_layer.objects.active = column_objects[0]\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the joined object\nbpy.context.active_object.name = \"Column\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    ascii=True,\n    use_selection=True\n)\n```"
  },
  {
    "input": "abs container",
    "output": "```python\nimport bpy\nimport bmesh\nimport os\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create ABS container body (main cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2, depth=3, location=(0, 0, 1.5))\nbody = bpy.context.active_object\nbody.name = \"Container_Body\"\n\n# Create container bottom (flattened cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2.1, depth=0.2, location=(0, 0, 0.1))\nbottom = bpy.context.active_object\nbottom.name = \"Container_Bottom\"\n\n# Create container lid (flattened cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=2.05, depth=0.15, location=(0, 0, 3.075))\nlid = bpy.context.active_object\nlid.name = \"Container_Lid\"\n\n# Create handle (torus-like structure using scaled cylinder)\nbpy.ops.mesh.primitive_cylinder_add(radius=0.3, depth=1.5, location=(2.5, 0, 2.5))\nbpy.ops.transform.rotate(value=1.5708, orient_axis='Y')\nhandle = bpy.context.active_object\nhandle.name = \"Container_Handle\"\n\n# Create spout (cone)\nbpy.ops.mesh.primitive_cone_add(radius1=0.4, radius2=0.2, depth=0.8, location=(0, 2.2, 2.8))\nbpy.ops.transform.rotate(value=1.5708, orient_axis='X')\nspout = bpy.context.active_object\nspout.name = \"Container_Spout\"\n\n# Create label area (flattened cube)\nbpy.ops.mesh.primitive_cube_add(size=1.5, location=(0, 2, 1.8))\nbpy.ops.transform.resize(value=(1, 0.05, 0.8))\nlabel = bpy.context.active_object\nlabel.name = \"Container_Label\"\n\n# Select all container parts\ncontainer_parts = [body, bottom, lid, handle, spout, label]\nbpy.ops.object.select_all(action='DESELECT')\n\nfor part in container_parts:\n    part.select_set(True)\n\n# Set active object for joining\nbpy.context.view_layer.objects.active = body\n\n# Join all parts into one object\nbpy.ops.object.join()\n\n# Rename the final object\nbpy.context.active_object.name = \"ABS_Container\"\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  },
  {
    "input": "abs cup",
    "output": "```python\nimport bpy\nimport bmesh\nfrom mathutils import Vector\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cup base (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.0,\n    depth=1.5,\n    location=(0, 0, 0.75)\n)\ncup_base = bpy.context.active_object\ncup_base.name = \"Cup_Base\"\n\n# Create cup interior (smaller cylinder for boolean)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.85,\n    depth=1.6,\n    location=(0, 0, 0.8)\n)\ncup_interior = bpy.context.active_object\ncup_interior.name = \"Cup_Interior\"\n\n# Boolean operation to hollow out the cup\nmodifier = cup_base.modifiers.new(name=\"Boolean\", type='BOOLEAN')\nmodifier.operation = 'DIFFERENCE'\nmodifier.object = cup_interior\n\n# Apply the modifier\nbpy.context.view_layer.objects.active = cup_base\nbpy.ops.object.modifier_apply(modifier=\"Boolean\")\n\n# Delete the interior cylinder\nbpy.ops.object.select_all(action='DESELECT')\ncup_interior.select_set(True)\nbpy.ops.object.delete()\n\n# Create cup handle (torus)\nbpy.ops.mesh.primitive_torus_add(\n    major_radius=0.4,\n    minor_radius=0.1,\n    location=(1.2, 0, 0.75)\n)\ncup_handle = bpy.context.active_object\ncup_handle.name = \"Cup_Handle\"\ncup_handle.rotation_euler = (0, 1.5708, 0)  # Rotate 90 degrees\n\n# Create cup bottom (cylinder)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.9,\n    depth=0.1,\n    location=(0, 0, 0.05)\n)\ncup_bottom = bpy.context.active_object\ncup_bottom.name = \"Cup_Bottom\"\n\n# Select all cup parts\nbpy.ops.object.select_all(action='DESELECT')\ncup_base.select_set(True)\ncup_handle.select_set(True)\ncup_bottom.select_set(True)\n\n# Set the base as active object\nbpy.context.view_layer.objects.active = cup_base\n\n# Join all parts together\nbpy.ops.object.join()\n\n# Rename the final object\nfinal_cup = bpy.context.active_object\nfinal_cup.name = \"Coffee_Cup\"\n\n# Select the cup for export\nbpy.ops.object.select_all(action='DESELECT')\nfinal_cup.select_set(True)\n\n# Export as ASCII STL\nbpy.ops.export_mesh.stl(\n    filepath=\"duck.stl\",\n    use_selection=True,\n    ascii=True\n)\n```"
  }
]